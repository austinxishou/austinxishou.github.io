[{"title":"python 解析xml相关问题","date":"2018-03-09T02:54:01.946Z","path":"2018/03/09/python/python-parse-xml-usage/","text":"python常用的解析xml库在python脚本或者其他应用场景,对xml文件进行读写和修改再正常不过; 常用的xml解析库有: [ElementTree](https://docs.python.org/2.7/library/xml.etree.elementtree.html?highlight=elementtree#module-xml.etree.ElementTree) [Beautiful Soup](http://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/#id57) 优缺点分析: ElementTree 基本使用123import xml.etree.ElementTree as ETtree = ET.parse(&apos;country_data.xml&apos;)root = tree.getroot() 问题集锦namespace xml的命名空间问题ElementTree 解析xml命名空间时 如以下的: 1&lt;resources xmlns:tools=&quot;http://schemas.android.com/tools&quot; tools:ignore=&quot;MissingTranslation&quot; xmlns:xliff=&quot;urn:oasis:names:tc:xliff:document:1.2&quot;&gt; 解析出来的属性值为: 1&#123;&apos;&#123;http://schemas.android.com/tools&#125;ignore&apos;: &apos;MissingTranslation&apos;&#125; 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources xmlns:tools=&quot;http://schemas.android.com/tools&quot; tools:ignore=&quot;MissingTranslation&quot; xmlns:xliff=&quot;urn:oasis:names:tc:xliff:document:1.2&quot;&gt; &lt;!-- 应用黑白名单 --&gt; &lt;string name=&quot;back_app_fork_stop&quot;&gt;The application has been blacklisted and unable to start,It is recommended to&lt;/string&gt; &lt;string name=&quot;back_app_uninstall&quot;&gt;uninstall&lt;/string&gt; &lt;string name=&quot;timer_format&quot; translatable=&quot;false&quot;&gt;&lt;/string&gt; &lt;string name=&quot;audio_db_title_format&quot;&gt;&lt;xliff:g id=&quot;format&quot;&gt;yyyy-MM-dd HH:mm:ss&lt;/xliff:g&gt;&lt;/string&gt;&lt;/resources&gt; 解析后的12345678&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;&lt;resources xmlns:ns0=&quot;http://schemas.android.com/tools&quot; xmlns:ns1=&quot;urn:oasis:names:tc:xliff:document:1.2&quot; ns0:ignore=&quot;MissingTranslation&quot;&gt; &lt;string name=&quot;back_app_fork_stop&quot;&gt;dsadfqwef&lt;/string&gt; &lt;string name=&quot;back_app_uninstall&quot;&gt;dsadfqwef&lt;/string&gt; &lt;string name=&quot;timer_format&quot; translatable=&quot;false&quot;&gt;dsadfqwef&lt;/string&gt; &lt;string name=&quot;audio_db_title_format&quot;&gt;dsadfqwef&lt;ns1:g id=&quot;format&quot;&gt;yyyy-MM-dd HH:mm:ss&lt;/ns1:g&gt;&lt;/string&gt;&lt;/resources&gt; 虽然也是正确,但是把命名空间对应为了ns1 [ElementTree: Working with Namespaces and Qualified Names](http://effbot.org/zone/element-namespaces.htm) 这边英文文章解释的很细致,唯一的缺点就是太长了; 所以关键点就是,注册命名空间 12ET.register_namespace(&quot;xliff&quot;,&quot;urn:oasis:names:tc:xliff:document:1.2&quot;)ET.register_namespace(&quot;tools&quot;,&quot;http://schemas.android.com/tools&quot;) 这就可以正确输出 ### (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"python","slug":"python","permalink":"https://austinxishou.github.io/tags/python/"}]},{"title":"mysql使用","date":"2018-03-05T01:13:26.790Z","path":"2018/03/05/server/php-mysql-usage-1/","text":"mysql 中多表联合删除https://www.cnblogs.com/sunss/archive/2011/01/20/1940306.html 使用场景123456789//删除 项目与图片的中间表//别名只能在关联中给出//正确: delete t1,t2 from table_name as t1 left join table2_name as t2 on t1.id=t2.id where table_name.id=25//错误: delete table_name,table2_name from table_name as t1 left join table2_name as t2 on t1.id=t2.id where table_name.id=25$delete = &quot;delete t1,t2 from &quot;;$fromStr = $Base-&gt;table(&apos;imgs_works&apos;).&quot; as t1 left join &quot;.$Base-&gt;table(&apos;imgsmain&apos;).&quot; as t2 &quot;;$whereStr = &quot;on t1.pk_img_main=t2.pk_img_main where t1.pk_works_main=&quot;.$pid;$execSqlStr = $delete.$fromStr.$whereStr;$delete = $Db -&gt;execSql($execSqlStr);(function(){ var bp = document.createElement(‘script’); var curProtocol = window.location.protocol.split(‘:’)[0]; if (curProtocol === ‘https’) { bp.src = ‘https://zz.bdstatic.com/linksubmit/push.js‘; } else { bp.src = ‘http://push.zhanzhang.baidu.com/push.js‘; } var s = document.getElementsByTagName(“script”)[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == &quot;http:&quot;) ? &quot;http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;:&quot;https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;; document.write(&apos;&lt;script src=&quot;&apos; + sozzsrc + &apos;&quot; id=&quot;sozz&quot;&gt;&lt;\\/script&gt;&apos;); })();","tags":[{"name":"server","slug":"server","permalink":"https://austinxishou.github.io/tags/server/"}]},{"title":"Android-OTA(五) Block-base 模式适配","date":"2018-02-28T02:00:29.297Z","path":"2018/02/28/android/android-ota-5-block-base/","text":"About 安卓关于OTA更新Android-doc 优点 因为块 OTA 可确保每个设备使用相同的分区，所以它能够使用 dm-verity 以加密的方式为系统分区签名 验证启动 device-mapper-verity (dm-verity)&lt;script&gt; (function(){ var bp = document.createElement(‘script’); var curProtocol = window.location.protocol.split(‘:’)[0]; if (curProtocol === ‘https’) { bp.src = ‘https://zz.bdstatic.com/linksubmit/push.js‘; } else { bp.src = ‘http://push.zhanzhang.baidu.com/push.js‘; } var s = document.getElementsByTagName(“script”)[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == &quot;http:&quot;) ? &quot;http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;:&quot;https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;; document.write(&apos;&lt;script src=&quot;&apos; + sozzsrc + &apos;&quot; id=&quot;sozz&quot;&gt;&lt;\\/script&gt;&apos;); })();","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"OTA","slug":"OTA","permalink":"https://austinxishou.github.io/tags/OTA/"},{"name":"recovery","slug":"recovery","permalink":"https://austinxishou.github.io/tags/recovery/"}]},{"title":"JavaScript的异步回调函数内部this的指向问题","date":"2018-02-27T02:27:33.699Z","path":"2018/02/27/webdesign/ecs6-series-0/","text":"问题说明常见回调函数内部的this指向问题先看下面这段代码： 1234567891011121314151617181920212223242526272829303132333435class _Menu&#123; constructor()&#123; &#125; _setFollowButtonFollowed = ()=&gt;&#123; console.log(&quot;austin test _setFollowButtonFollowed&quot;); this._frame.find(&apos;.follow-btn&apos;).addClass(&apos;followed&apos;).find(&apos;span&apos;).text(&apos;已关注&apos;); &#125; render = ()=&gt;&#123; this._frame = $(` &lt;div class=&quot;menu&quot;&gt; &lt;a class=&quot;follow-btn btn&quot; href=&quot;javascript:;&quot;&gt; &lt;i class=&quot;icon&quot;&gt;&lt;/i&gt; &lt;span&gt;关注店铺&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; `); this._frame // .on(touchEvent.click, (&apos;.plan-select&apos;), this._reportPlanSelectClick) .on(touchEvent.click, (&apos;.follow-btn:not(.followed)&apos;), ()=&gt;&#123; console.log(&apos;点击关注&apos;); if (Tida.appinfo.isTaobao) &#123; Tida.social(&#123; sellerId: _storeApi.sellerId, action: &apos;follow&apos; &#125;, function (e) &#123;//匿名回调函数 const ret = typeof e.ret === &apos;object&apos; ? e.ret[0] : e.ret; if (ret === &apos;HY_SUCCESS&apos;) &#123; this._setFollowButtonFollowed(); &#125; &#125;) &#125; &#125;) 在匿名回调函数中,调用了 `this._setFollowButtonFollowed()` 函数,提示的结果是 1this._setFollowButtonFollowed is not a function 这是因为this作用域指向问题 ，success函数实际是一个闭包 ， 无法直接通过 `this` 来 `_setFollowButtonFollowed` 那么需要怎么修改呢？ 我们通过将当前对象赋给一个新的对象 var _this = this; 然后使用 _this 来 _setFollowButtonFollowed 就行了 完整代码如下: 123456789101112131415161718192021222324252627282930313233343536class _Menu&#123;constructor()&#123;&#125;_setFollowButtonFollowed = ()=&gt;&#123; console.log(&quot;austin test _setFollowButtonFollowed&quot;); this._frame.find(&apos;.follow-btn&apos;).addClass(&apos;followed&apos;).find(&apos;span&apos;).text(&apos;已关注&apos;);&#125;var _this = this; //修改1 重点render = ()=&gt;&#123; this._frame = $(` &lt;div class=&quot;menu&quot;&gt; &lt;a class=&quot;follow-btn btn&quot; href=&quot;javascript:;&quot;&gt; &lt;i class=&quot;icon&quot;&gt;&lt;/i&gt; &lt;span&gt;关注店铺&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; `); this._frame // .on(touchEvent.click, (&apos;.plan-select&apos;), this._reportPlanSelectClick) .on(touchEvent.click, (&apos;.follow-btn:not(.followed)&apos;), ()=&gt;&#123; console.log(&apos;点击关注&apos;); if (Tida.appinfo.isTaobao) &#123; Tida.social(&#123; sellerId: _storeApi.sellerId, action: &apos;follow&apos; &#125;, function (e) &#123;//匿名回调函数 const ret = typeof e.ret === &apos;object&apos; ? e.ret[0] : e.ret; if (ret === &apos;HY_SUCCESS&apos;) &#123; _this._setFollowButtonFollowed();//修改2 重点 &#125; &#125;) &#125; &#125;) (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://austinxishou.github.io/tags/JavaScript/"}]},{"title":"淘宝开放平台文档记录","date":"2018-01-20T01:15:36.234Z","path":"2018/01/20/server/open-taobao-note-usage/","text":"云数据库购买ECS和RDS,应用部署在ECS上，数据库迁移至RDS上.ECS允许安装数据库客户端管理RDS数据库(DB), 数据库(DB)不允许安装在ECS服务器上阿里云-hub 授权及安全等级相关文档链接 开放平台安全等级说明 API调用方法详解官方文档 官方SDK使用说明官方文档 用户授权拼接授权url12https://oauth.taobao.com/authorize?response_type=code&amp;client_id=24747068&amp;redirect_uri=http://wiki.kulchao.com/api/taobao/addcode&amp;state=1212&amp;view=wap 多点共享 token全局存储,定时刷新 Access_Token全局存储 服务端保存token到文件 根据 sellerId 获取相同的授权 sellerid token refresh_token 定时任务: 自定义镜像部署 修改listen端口-service nginx restart 修改时区 1cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 安装cron并设置定时任务 12345apt-get install croncrontab -u www-data -eservice cron restart 接口测试 1https://kuchaoyun.ews.m.jaeapp.com/api/taobao/favor/?sellerId=2636801283&amp;storeId=111&amp;saleId=123 跨域设置 123add_header Access-Control-Allow-Origin *;add_header Access-Control-Allow-Headers X-Requested-With;add_header Access-Control-Allow-Methods GET,POST; &lt;script&gt; (function(){ var bp = document.createElement(‘script’); var curProtocol = window.location.protocol.split(‘:’)[0]; if (curProtocol === ‘https’) { bp.src = ‘https://zz.bdstatic.com/linksubmit/push.js‘; } else { bp.src = ‘http://push.zhanzhang.baidu.com/push.js‘; } var s = document.getElementsByTagName(“script”)[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == &quot;http:&quot;) ? &quot;http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;:&quot;https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;; document.write(&apos;&lt;script src=&quot;&apos; + sozzsrc + &apos;&quot; id=&quot;sozz&quot;&gt;&lt;\\/script&gt;&apos;); })();","tags":[{"name":"server","slug":"server","permalink":"https://austinxishou.github.io/tags/server/"}]},{"title":"composer使用","date":"2018-01-18T13:19:11.241Z","path":"2018/01/18/server/php-composer-usage/","text":"http://www.pfinal.cn/ composer 包管理composer autoload - 自动加载12345678910&quot;autoload&quot;: &#123; &quot;classmap&quot;: [ &quot;database/seeds&quot;, &quot;database/factories&quot; ], &quot;psr-4&quot;: &#123; &quot;App\\\\&quot;: &quot;app/&quot;, &quot;&quot; &#125; &#125;, 更新自动加载文件1composer dump-autoload 当然也可以自行在 autoload_psr4.php 中添加1&apos;App\\\\&apos; =&gt; array($baseDir . &apos;/app&apos;),(function(){ var bp = document.createElement(‘script’); var curProtocol = window.location.protocol.split(‘:’)[0]; if (curProtocol === ‘https’) { bp.src = ‘https://zz.bdstatic.com/linksubmit/push.js‘; } else { bp.src = ‘http://push.zhanzhang.baidu.com/push.js‘; } var s = document.getElementsByTagName(“script”)[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == &quot;http:&quot;) ? &quot;http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;:&quot;https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;; document.write(&apos;&lt;script src=&quot;&apos; + sozzsrc + &apos;&quot; id=&quot;sozz&quot;&gt;&lt;\\/script&gt;&apos;); })();","tags":[{"name":"server","slug":"server","permalink":"https://austinxishou.github.io/tags/server/"}]},{"title":"server admin usage and note","date":"2018-01-17T02:18:46.864Z","path":"2018/01/17/server/server-admin-usage-note/","text":"服务端环境搭建配置ssh-sftp 在服务器上开通SFTP文件服务，允许某些用户上传及下载文件。但是这些用户只能使用SFTP传输文件，不能使用SSH终端访问服务器，并且SFTP不能访问系统文件（即所谓的“Jail（监狱）”）。系统管理员则既能使用SFTP传输文件，也能使用SSH远程管理服务器。 安装OpenSSH服务器 1sudo apt-get install openssh-server 为SFTP访问创建用户组，便于管理权限 1sudo addgroup sftp-users 创建SFTP用户，并配置相应权限 1234sudo adduser austinsudo usermod -G sftp-users -s /bin/false austin //将austin从所有其他用户组中移除并加入到sftp-users组，并且关闭其Shell访问// -s /bin/false 指定登录shell,这里不允许ssh登录 创建SSH用户组，并把管理员加入到该组 123sudo addgroup ssh-users sudo usermod -a -G ssh-users admin \\\\-a参数的意思是不从其他用户组用移除sudo usermod -a -G ssh-users root \\\\额外增加root用户ssh访问 准备“监狱”的根目录及共享目录 1234sudo mkdir /home/sftp_rootsudo mkdir /home/sftp_root/sharedsudo chown admin:sftp-users /home/sftp_root/sharedsudo chmod 770 /home/sftp_root/shared “监狱”的根目录必须满足以下要求：所有者为root，其他任何用户都不能拥有写入权限。因此，为了让SFTP用户能够上传文件，还必须在“监狱”根目录下再创建一个普通用户能够写入的共享文件目录。为了便于管理员通过SFTP管理上传的文件，我把这个共享文件目录配置为：由admin所有，允许sftp-users读写。这样，管理员和SFTP用户组成员就都能读写这个目录了。 修改SSH配置文件 sudo nano /etc/ssh/sshd_config 在sshd_config文件的最后，添加以下内容： 123456AllowGroups ssh-users sftp-usersMatch Group sftp-users ChrootDirectory /home/sftp_root AllowTcpForwarding no X11Forwarding no ForceCommand internal-sftp 这些内容的意思是： 只允许ssh-uers及sftp-users通过SSH访问系统； 针对sftp-users用户，额外增加一些设置：将“/home/sftp_root”设置为该组用户的系统根目录（因此它们将不能访问该目录之外的其他系统文件）；禁止TCP Forwarding和X11 Forwarding；强制该组用户仅仅使用SFTP。 service sshd reload 问题记录&gt; SFTP – subsystem request failed on channel X 修改: You are using sftp to connect your server in a chrooted environment and you met the error below. subsystem request failed on channel 0Couldn’t read packet: Connection reset by peer This causes because of wrong external library configured in your sshd_config. So, edit your sshd_config and use internal-sftp. Because openssh already has internal sftp functionality and you dont need any external libraries. Find the line beginning with “Subsystem”. Comment out and add the following line. 12#Subsystem sftp /usr/lib/openssh/sftp-serverSubsystem sftp internal-sftp 配置定时任务 crontabl命令 123456789crontab: invalid option -- &apos;h&apos;crontab: usage error: unrecognized optionusage: crontab [-u user] file crontab [ -u user ] [ -i ] &#123; -e | -l | -r &#125; (default operation is replace, per 1003.2) -e (edit user&apos;s crontab) -l (list user&apos;s crontab) -r (delete user&apos;s crontab) -i (prompt before deleting user&apos;s crontab) 编辑添加定时任务 crontabl -u root -e 123* * * * * php /home/forge/default/artisan schedule:run &gt;&gt; /dev/null 2&gt;&amp;1//下面是crontab的格式：//分 时 日 月 星期 要运行的命令 确保cmd能够正常执行 1php /home/forge/default/artisan schedule:run 查看cron服务 12345//查看状态/etc/init.d/cron status//重启cron服务/etc/init.d/cron restart (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"server","slug":"server","permalink":"https://austinxishou.github.io/tags/server/"}]},{"title":"docker 使用笔记","date":"2018-01-15T01:18:42.376Z","path":"2018/01/15/server/docker-note-useage/","text":"About-简介参考文档官方docker-doc Docker是使用go语言基于LINUX内核的cgroup，namespace以及AUFS 类的 Union FS 等技术，对进程进行封装隔离的一种操作系统层面的虚拟化技术，由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。 Docker和传统虚拟化技术的对比 kvm-vs-docker 为什么要使用 Docker 更高效的利用系统资源 由于Docker工作在进程级别，不需要进行硬件虚拟以及运行完整操作系统等额外开销，所以Docker对系统资源的利用率更高。相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。 更快速的启动时间 传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。 一致的运行环境 由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊” 这类问题。 持续交付和部署 一次创建，多次运行。通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合持续集成(Continuous Integration)系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。 更轻松的迁移 Docker 确保了执行环境的一致性，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此可以很轻易迁移到任意上，而不用担心运行环境的变化导致应用无法正常运行的情况。 更轻松的维护和扩展 Docker 使用的分层存储以及镜像的技术，Docker 团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制。 Docker的基本概念Docker 镜像我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载根文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个根文件系统。Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 分层存储因为镜像包含操作系统完整的根文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。 分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。 Docker 容器镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的根文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。 前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。 容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。 按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。 数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器可以随意删除、重新运行，数据却不会丢失。 Docker RegistryDocker Registry 提供了镜像的集中的存储、分发功能。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。Docker Registry 分为公有服务和私有服务，我们可以搭建一个基于本地的registry Docker 操作安装docker例如在Ubuntu中,可以直接运行: 1apt-get install docker 配置镜像加速由于国内访问docker原站点非常困难，国内的云服务提供商提供了加速功能。我们使用阿里云进行docker加速地址为: https://dev.aliyun.com/search.html 123sed -i &quot;s|ExecStart=/usr/bin/dockerd|ExecStart=/usr/bin/dockerd --registry-mirror=https://fz5yth0r.mirror.aliyuncs.com|g&quot; /usr/lib/systemd/system/docker.servicesystemctl daemon-reloadsystemctl restart docker 使用镜像 获取镜像 1docker pull [OPTIONS] NAME[:TAG|@DIGEST] 列出镜像 123456789[root@node1 docker]# docker images#仓库名 #标签 #镜像ID #创建时间 #大小REPOSITORY TAG IMAGE ID CREATED SIZEcentos latest 98d35105a391 7 days ago 192 MBdocker images -a //使用-a参数来显示中间层镜像。//按照指定格式输出docker images --format &quot;table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Repository&#125;&#125;\\t&#123;&#123;.Tag&#125;&#125;&quot; Docker 运行 12//使用nginx 镜像启动一个容器，命名为 webserver，并且把容器的80端口映射在宿主机的80端口。docker run --name webserver -d -p 80:80 nginx Docker commit 我们修改了容器的存储层，使用docker diff 查看文件的改动 定制好页面之后，保存为镜像，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。 而 Docker 提供了一个 docker commit 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。 12345docker commit \\ --author &quot;austin &lt;xxx@163.com&gt;&quot; \\ --message &quot;修改初始网页&quot; \\ webserver \\ nginx:v2 - 还可以用 docker history 具体查看镜像内的历史记录，如果比较 nginx:latest 的历史记录 - 慎用 docker commit 观察之前的 docker diff webserver 的结果，你会发现除了真正想要修改的 /usr/share/nginx/html/index.html 文件外，还有很多文件被改动或添加了。如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，将会导致镜像极为臃肿。 使用 docker commit 意味着除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体在操作的。 如果使用 docker commit 制作镜像，由于只在当前层操作，后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到?。这会让镜像更加臃肿。 docker commit 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 docker commit 定制镜像，定制行为应该使用 Dockerfile 来完成。 DockerfileDockerfile是一个文本文件，用来来构建、定制镜像。之前使用 docker commit 提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。使用docker file 定制nginx镜像 12FROM nginxRUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html FROM 指定一个基础镜像，可以直接拿来使用的服务类的镜像，如ubuntu、debian、centos、fedora、alpine、nginx、redis、mongo、mysql、httpd、php、tomcat 等。 指定一个空白镜像 12FROM scratchRUN ... RUN RUN 指令是用来执行命令行命令。其格式有两种。 SHELL格式： 1RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html exec 格式: 1RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;] 在使用shell模式编写时，不建议每个命令都写一层RUN，每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。 正确dockerfile写法 1234567891011121314FROM debian:jessieRUN buildDeps=&apos;gcc libc6-dev make&apos; \\ &amp;&amp; apt-get update \\ &amp;&amp; apt-get install -y $buildDeps \\ &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot; \\ &amp;&amp; mkdir -p /usr/src/redis \\ &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \\ &amp;&amp; make -C /usr/src/redis \\ &amp;&amp; make -C /usr/src/redis install \\ &amp;&amp; rm -rf /var/lib/apt/lists/* \\ &amp;&amp; rm redis.tar.gz \\ &amp;&amp; rm -r /usr/src/redis \\ &amp;&amp; apt-get purge -y --auto-remove $buildDeps - 不建议的写法： 123456789FROM debian:jessieRUN apt-get updateRUN apt-get install -y gcc libc6-dev makeRUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;RUN mkdir -p /usr/src/redisRUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1RUN make -C /usr/src/redisRUN make -C /usr/src/redis install 构建镜像 1docker build -t nginx:v3 . 镜像构建上下文（Context） COPY SHELL格式： 1COPY &lt;源路径&gt;... &lt;目标路径&gt; exec 格式:123 COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;] ``` - 源路径&quot;可以是多个，也可以是通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如： COPY hom* /mydir/COPY hom?.txt /mydir/ 1234567891011 &gt; &quot;目标路径&quot;可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。 使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。- **ADD** &quot;源路径&quot;可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到&quot;目标路径&quot;。下载后的文件权限自动设置为600。 如果这并不是想要的权限，那么还需要增加额外的一层 RUN 进行权限调整。 如果&quot;源路径&quot;为一个 tar.gzip,tar.bzip2,tar.xz的文件，ADD 指令将会自动解压缩这个压缩文件到&quot;目标路径&quot;去。 FROM scratchADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz / 1234567 在 Docker 官方的最佳实践文档中要求，尽可能的使用 COPY，因为 COPY 的语义很明确，就是复制文件而已，而 ADD 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 ADD 的场合，就是所提及的需要自动解压缩的场合。 - **CMD** - CMD 指令的格式和 RUN 相似，也是两种格式： - SHELL格式： CMD &lt;命令&gt; 1- exec 格式: CMD [“可执行文件”, “参数1”, “参数2”…] 1- 参数列表格式 CMD [“参数1”, “参数2”…]。 123456789在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。&gt; 之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。CMD 指令就是用于指定默认的容器主进程的启动命令的。&gt; 在运行时可以指定新的命令来替代镜像设置中的这个默认命令，镜像默认的 CMD 是 `/bin/bash` ，如果我们直接 `docker run -it centos` 的话，会直接进入 `bash`。我们也可以在运行时指定运行别的命令，如 `docker run -it ubuntu cat /etc/os-release`。这就是用 `cat /etc/os-release`命令替换了默认的 `/bin/bash `命令了，输出了系统版本信息。在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 &quot;，而不要使用单引号。如果使用 shell 格式的话，实际的命令会被包装为sh -c 的参数的形式进行执行。比如： CMD echo $HOME 12在实际执行中，会将其变更为： CMD [ “sh”, “-c”, “echo $HOME” ] 12345这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。一些初学者将 CMD 写为： CMD service nginx start 12345678然后发现容器执行后就立即退出了。甚至在容器内去使用 `systemctl `命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。对于容器而言，其启动程序就是`容器应用进程`，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。而使用`service nginx start`命令，则是希望 `upstart` 来以后台守护进程形式启动 `nginx` 服务。而刚才说了 `CMD service nginx start` 会被理解为 `CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]`，因此主进程实际上是` sh`。那么当 `service nginx start` 命令结束后，`sh` 也就结束了，`sh` 作为主进程退出了，自然就会令容器退出。正确的做法是直接执行 `nginx` 可执行文件，并且要求以前台形式运行。比如： CMD [“nginx”, “-g”, “daemon off;”] 12345- **ENTRYPOINT** &gt; `ENTRYPOINT` 的目的和 `CMD` 一样，都是在指定容器启动程序及参数。`ENTRYPOINT` 在运行时也可以替代，不过比 `CMD` 要略显繁琐，需要通过 `docker run` 的参数 `--entrypoint` 来指定。 当指定了 ENTRYPOINT 后，`CMD` 的含义就发生了改变，不再是直接的运行其命令，而是将 `CMD` 的内容作为参数传给 `ENTRYPOINT` 指令，换句话说实际执行时，将变为： ““ 123场景一：让镜像变成像命令一样使用假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 CMD 来实现： mkdir ~/myip/cd ~/myip/tee Dockerfile &lt;&lt;’EOF’FROM centosRUN yum -y install wget \\ &amp;&amp; wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo \\ &amp;&amp;wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo \\ &amp;&amp;yum -y install curlCMD [ “curl”, “-s”, “http://ip.cn“ ]EOFdocker build -t myip . 12启动一个容器测试 [root@node1 myip]# docker run myip当前 IP：123.117.85.77 来自：北京市 联通 123这么看起来好像可以直接把镜像当做命令使用了，如果我们希望加参数呢？从上面的 CMD 中可以看到实质的命令是 curl，那么如果我们希望显示 HTTP 头信息，就需要加上 -i 参数。那么我们可以直接加 -i 参数给 docker run myip 么？ [root@node1 myip]# docker rum myip -iunknown shorthand flag: ‘i’ in -iSee ‘docker –help’.… 1234跟在镜像名后面的是 command，运行时会替换 CMD 的默认值。因此这里的 -i 替换了原来的 CMD，而不是添加在原来的 curl -s http://ip.cn 后面。而 -i 根本不是命令，所以自然找不到。如果我们希望加入 -i 这参数，我们就必须重新完整的输入这个命令： [root@node1 myip]# docker run myip curl -s http://ip.cn -iHTTP/1.1 200 OKServer: nginx/1.10.0 (Ubuntu)Date: Fri, 24 Mar 2017 02:21:43 GMTContent-Type: text/html; charset=UTF-8Transfer-Encoding: chunkedConnection: keep-alive 当前 IP：123.117.85.77 来自：北京市 12而使用 ENTRYPOINT 就可以给 docker 传参，修改docker镜像 cd ~/myip/tee Dockerfile &lt;&lt;’EOF’FROM centosRUN yum -y install wget \\ &amp;&amp; wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo \\ &amp;&amp;wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo \\ &amp;&amp;yum -y install curlENTRYPOINT [ “curl”, “-s”, “http://ip.cn“ ]EOFdocker build -t myip . 12再次运行 [root@node1 myip]# docker run myip当前 IP：123.117.85.77 来自：北京市 [root@node1 myip]# docker run myip -i HTTP/1.1 200 OK Server: nginx/1.10.0 (Ubuntu) Date: Fri, 24 Mar 2017 02:24:42 GMT Content-Type: text/html; charset=UTF-8 Transfer-Encoding: chunked Connection: keep-alive 当前 IP：123.117.85.77 来自：北京市 123场景二：应用运行前的准备工作[redis的官方dockerfile]( https://github.com/docker-library/redis/blob/master/3.2/alpine/Dockerfile) FROM alpine:3.5 ... RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis ... ENTRYPOINT [&quot;docker-entrypoint.sh&quot;] EXPOSE 6379 CMD [ &quot;redis-server&quot; ] 12可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 ENTRYPOINT 为 docker-entrypoint.sh 脚本。 #!/bin/sh ... # allow the container to be started with `--user` if [ &quot;$1&quot; = &apos;redis-server&apos; -a &quot;$(id -u)&quot; = &apos;0&apos; ]; then chown -R redis . exec su-exec redis &quot;$0&quot; &quot;$@&quot; fi exec &quot;$@&quot; 12该脚本的内容就是根据 CMD 的内容来判断，如果是 `redis-server` 的话，则切换到 `redis` 用户身份启动服务器，否则依旧使用 `root `身份执行。比如： $ docker run -it redis id uid=0(root) gid=0(root) groups=0(root) 123456- **ENV 设置环境变量** 格式有两种： - `ENV &lt;key&gt; &lt;value&gt;` - `ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...` 这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。 ENV VERSION=1.0 DEBUG=on \\ NAME=&quot;Happy Feet&quot; 1234567- **ARG 构建参数** - 格式： `ARG &lt;参数名&gt;[=&lt;默认值&gt;]` 构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是，ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。不建议 ARG 保存密码之类的信息，因为 docker history 还是可以看到所有值的。 - **VOLUME 定义匿名卷** - 格式: VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...] VOLUME &lt;路径&gt; 1&gt; 之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。 VOLUME /data 1也可以运行时覆盖这个挂载设置。比如： docker run -d -v mydata:/data xxxx 1234 在这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。 - **EXPOSE 声明端口** - 格式: EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...] 12345678910 EXPOSE 指令是声明运行时容器提供服务端口，在运行时并不会因为这个声明应用就会开启这个端口的服务。 - 在 Dockerfile 中写入这样的声明有两个好处: - 帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射 - 在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。 &gt; 此外，在早期 Docker 版本中还有一个特殊的用处。以前所有容器都运行于默认桥接网络中，因此所有容器互相之间都可以直接访问，这样存在一定的安全性问题。于是有了一个 Docker 引擎参数 --icc=false，当指定该参数后，容器间将默认无法互访，除非互相间使用了 --links 参数的容器才可以互通，并且只有镜像中 EXPOSE 所声明的端口才可以被访问。这个 --icc=false 的用法，在引入了 docker network 后已经基本不用了，通过自定义网络可以很轻松的实现容器间的互联与隔离。 - **WORKDIR 指定工作目录** - 格式: WORKDIR &lt;工作目录路径&gt; 12使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。之前提到一些初学者常犯的错误是把 Dockerfile 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误： RUN cd /app RUN echo &quot;hello&quot; &gt; world.txt 1234567 &gt; 如果将这个 Dockerfile 进行构建镜像运行后，会发现找不到 /app/world.txt 文件，或者其内容不是hello。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 Dockerfile 中，这两行 RUN 命令的执行环境根本不同，是两个完全不同的容器。这就是对 Dokerfile 构建分层存储的概念不了解所导致的错误。 &gt; 之前说过每一个 `RUN `都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 `RUN cd /app `的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。 因此如果需要改变以后各层的工作目录的位置，那么应该使用 `WORKDIR` 指令。- **USER 指定当前用户** - 格式: USER &lt;用户名&gt; 123USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER 则是改变之后层的执行 RUN, CMD 以及 ENTRYPOINT 这类命令的身份。当然，和 WORKDIR 一样，USER 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。 RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis USER redis RUN [ &quot;redis-server&quot; ] 123 - **HEALTHCHECK 健康检查** - 格式: HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令 HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令 123456789HEALTHCHECK 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。在没有 HEALTHCHECK 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。而自 1.12 之后，Docker 提供了 HEALTHCHECK 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。当在一个镜像指定了 HEALTHCHECK 指令后，用其启动容器，初始状态会为 starting，在 HEALTHCHECK 指令检查成功后变为 healthy，如果连续一定次数失败，则会变为 unhealthy。HEALTHCHECK 支持下列选项： --interval=&lt;间隔&gt;：两次健康检查的间隔，默认为 30 秒； --timeout=&lt;时长&gt;：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒； --retries=&lt;次数&gt;：当连续失败指定次数后，则将容器状态视为 unhealthy，默认 3 次。 123456&gt; 和 CMD, ENTRYPOINT 一样，HEALTHCHECK 只可以出现一次，如果写了多个，只有最后一个生效。在 HEALTHCHECK [选项] CMD 后面的命令，格式和 ENTRYPOINT 一样，分为 shell 格式，和 exec 格式。命令的返回值决定了该次健康检查的成功与否：0：成功；1：失败；2：保留，不要使用这个值。假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 curl 来帮助判断，其 Dockerfile 的 HEALTHCHECK 可以这么写： mkdir ~/nginxcheck cd ~/nginxcheck vim Dockerfile FROM nginx RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/* HEALTHCHECK --interval=5s --timeout=3s \\ CMD curl -fs http://localhost/ || exit 1 docker build -t myweb:v1 . 1234这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 curl -fs http://localhost/ || exit 1 作为健康检查命令。启动测试 docker run -d --name myweb -p 80:82 myweb:v1 12查看 [root@node1 nginxcheck]# docker ps -f name=myweb CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES beb18dcc15fe myweb:v1 &quot;nginx -g &apos;daemon ...&quot; 22 seconds ago Up 21 seconds (healthy) 80/tcp, 443/tcp, 0.0.0.0:80-&gt;82/tcp myweb 1234567 如果健康检查连续失败超过了重试次数，状态就会变为 (unhealthy)。 健康检查命令的输出（包括 stdout 以及 stderr）都会被存储于健康状态里，可以用 docker inspect 来查看。 - **ONBUILD 为他人做嫁衣** ONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN, COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。 例如： FROM node:slim RUN &quot;mkdir /app&quot; WORKDIR /app ONBUILD COPY ./package.json /app ONBUILD RUN [ &quot;npm&quot;, &quot;install&quot; ] ONBUILD COPY . /app/ CMD [ &quot;npm&quot;, &quot;start&quot; ] 1在构建基础镜像的时候，包含ONBUILD这三行并不会被执行，但是当把这个镜像作为基础镜像构建时，这三行就会执行。 #首先构建基础镜像 docker build -t my-node . #在其他项目需要使用这个Dockerfile制作的镜像作为基础镜像时，直接写Dockerfile，基础镜像的三行会在子Dockerfile中执行 FROM my-node 1234- **其他制作镜像方法** 除了标准的使用 Dockerfile 生成镜像的方法外，由于各种特殊需求和历史原因，还提供了一些其它方法用以生成镜像。 - 从 rootfs 压缩包导入 格式：docker import [选项] &lt;文件&gt;|&lt;URL&gt;|- [&lt;仓库名&gt;[:&lt;标签&gt;]] 123压缩包可以是本地文件、远程 Web 文件，甚至是从标准输入中得到。压缩包将会在镜像 / 目录展开，并直接作为镜像第一层提交。比如我们想要创建一个 OpenVZ 的 Ubuntu 14.04 模板的镜像： docker import \\ http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz \\ openvz/ubuntu:14.04 1234567 这条命令自动下载了 ubuntu-14.04-x86_64-minimal.tar.gz 文件，并且作为根文件系统展开导入，并保存为镜像 openvz/ubuntu:14.04。 - docker save 和 docker load Docker 还提供了 docker load 和 docker save 命令，用以将镜像保存为一个 tar 文件，然后传输到另一个位置上，再加载进来。这是在没有 Docker Registry 时的做法，现在已经不推荐，镜像迁移应该直接使用 Docker Registry，无论是直接使用 Docker Hub 还是使用内网私有 Registry 都可以。 使用 docker save 命令可以将镜像保存为归档文件。 docker pull alpine docker save alpine |gzip &gt; alpine.tar.gz 12然后我们将 alpine-latest.tar.gz 文件复制到了到了另一个机器上，可以用下面这个命令加载镜像： docker load -i alpine-latest.tar.gz 123456789101112131415161718## 使用容器### 启动容器 启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。 - **容器的启动流程** 当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括： 1. 检查本地是否存在指定的镜像，不存在就从公有仓库下载 1. 利用镜像创建并启动一个容器 1. 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层 1. 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去 1. 从地址池配置一个 ip 地址给容器 1. 执行用户指定的应用程序 1. 执行完毕后容器被终止 - **使用docker run启动** 下面的命令输出一个 “Hello World”，之后终止容器。 docker run centos /bin/echo &apos;Hello world&apos; 12启动一个前台的bash进程，-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上，-i 则让容器的标准输入保持打开。 docker run -t -i centos /bin/bash 1- **使用docker start启动已终止容器** docker start 容器名字或ID 1查看容器的资源占用,只有一个bash进程 [root@94b57792acbf /]# ps aux USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0.0 0.1 11768 1932 ? Ss 07:19 0:00 /bin/bash root 56 0.0 0.1 47440 1672 ? R+ 07:27 0:00 ps aux 12345 - **让容器以后台进程模式运行** 更多的时候，需要让 Docker在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 -d 参数来实现。 使用例子来体验区别：不使用 -d 参数： [root@node1 ~]# docker run centos /bin/bash -c &quot;while true; do echo hello world; sleep 1; done&quot; hello world hello world hello world hello world 123所有的输出都输出到宿主机。加-d参数 [root@node1 ~]# docker run -d centos /bin/bash -c &quot;while true; do echo hello world; sleep 1; done&quot; a8e42575a9ff340c65f0023c77926b0f80051f53ade13c38847f0e8a6319ee63 1此时容器会在后台运行并不会把输出的结果打印到宿主机上，可以使用 docker logs 查看 [root@node1 ~]# docker logs a8e42575a9ff 1234 &gt; 注： 容器是否会长久运行，是和docker run指定的命令有关，和 -d 参数无关。 - **终止容器** docker stop {CONTAINER ID| NAMES} 1234 对于上一章节中只启动了一个bash的容器，用户通过 exit 命令或 Ctrl+d 来退出终端时，所创建的容器立刻终止。 - **进入容器** attach 命令 [root@node1 ~]# docker run -dit centos /bin/bash 14c0b4a935f57317f25111aa55beed0f3329afe60871ca06c44a12acc4172140 [root@node1 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 14c0b4a935f5 centos &quot;/bin/bash&quot; 25 seconds ago Up 24 seconds dreamy_wiles [root@node1 ~]# docker attach dreamy_wiles 1234 &gt; 但是使用 attach 命令有时候并不方便。当多个窗口同时 attach 到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞时,其他窗口也无法执行操作了,使用attach命令退出使用ctrl+p+q 退出不影响容器运行。- **nsenter 命令** 安装命令 yum -y install util-linux 1获取容器PID PID=$(docker inspect --format &quot;{{ .State.Pid }}&quot; dreamy_wiles) 1进入容器 nsenter --target $PID --mount --uts --ipc --net --pid 123 - **导入导出容器** 导出容器快照 docker export 7691a814370e &gt; centos.tar 12导入容器快照 cat centos.tar | sudo docker import - myimages/centos:v1.0 12删除容器 docker rm {CONTAINER ID| NAMES} 1234567891011121314### Docer 数据管理 Docker 内部管理数据主要有两种方式： - 数据卷（Data volumes） - 数据卷容器（Data volume containers） - **数据卷** 数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性： - 数据卷可以在容器之间共享和重用 - 对数据卷的修改会立马生效 - 对数据卷的更新，不会影响镜像 - 数据卷默认会一直存在，即使容器被删除 &gt; 注意：数据卷的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的数据卷。 使用 `-v` 标记也可以指定挂载一个本地主机的目录到容器中去。 docker run -dit --name test -v /tmp:/opt:ro centos /bin/bash 123 - **数据卷容器** 数据卷容器，其实就是一个正常的容器，专门用来提供数据卷供其它容器挂载的。 docker run -dit -v /dbdata --name dbdata centos /bin/bash [root@node1 ~]# docker attach dbdata [root@a9642e6adf7b /]# touch /dbdata/{1..10}.txt 1在其他容器中使用 --volumes-from 来挂载 dbdata 容器中的数据卷。 docker run -dit --volumes-from dbdata --name db1 centos /bin/bash docker run -dit --volumes-from dbdata --name db2 centos /bin/bash 1验证 [root@node1 ~]# docker attach db1 [root@87f964ea0f31 /]# ls /dbdata/ 1.txt 10.txt 2.txt 3.txt 4.txt 5.txt 6.txt 7.txt 8.txt 9.txt 123456789 &gt; 注意：使用 --volumes-from 参数所挂载数据卷的容器自己并不需要保持在运行状态。 如果删除了挂载的容器（包括 dbdata、db1 和 db2），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时使用 docker rm -v 命令来指定同时删除关联的容器。 这可以让用户在容器之间升级和移动数据卷。- **利用数据卷容器来备份、恢复、迁移数据卷** 可以利用数据卷对其中的数据进行进行备份、恢复和迁移。 `备份` 首先使用 --volumes-from 标记来创建一个加载 dbdata 容器卷的容器，并从主机挂载/opt/backup到容器的 /backup 目录。命令如下： docker run --volumes-from dbdata -v /opt/backup:/backup centos tar cvf /backup/backup.tar /dbdata 123`恢复`如果要恢复数据到一个容器，首先创建一个带有空数据卷的容器 dbdata2。 docker run --volumes-from dbdata2 -v /opt/backup:/backup centos tar xvf /backup/backup.tar 1为了查看/验证恢复的数据，可以再启动一个容器挂载同样的容器卷来查看 docker run --volumes-from dbdata2 centos /bin/ls /dbdata 12345678## Docker registry### Registry 和 Repository 的区别 注册服务器（Registry），是管理仓库的具体服务器，每个服务器上可以有多个仓库（Repository），而每个仓库（Repository）下面有多个镜像。### 配置registry registry如果想要别人可以使用，需要https才可以，我们可以利用openssl来搭建私有的CA服务器，用以签名、颁发证书，管理已签名证书和已吊销证书等。### 搭建私有CA 初始化CA环境，在/etc/pki/CA/下建立证书索引数据库文件index.txt和序列号文件serial，并为证书序列号文件提供初始值。 touch /etc/pki/CA/{index.txt,serial} echo 01 &gt; /etc/pki/CA/serial 12生成密钥并保存到/etc/pki/CA/private/cakey.pem (umask 077;openssl genrsa -out /etc/pki/CA/private/cakey.pem 2048) 12生成根证书 openssl req -new -x509 -key /etc/pki/CA/private/cakey.pem -out /etc/pki/CA/cacert.pem -days 3650 12填写的信息 Country Name (2 letter code) [XX]:CN State or Province Name (full name) []:Beijing Locality Name (eg, city) [Default City]:Beijing Organization Name (eg, company) [Default Company Ltd]:mycompany Organizational Unit Name (eg, section) []:ops Common Name (eg, your name or your server&apos;s hostname) []:registry.mycompany.com Email Address []:admin@mycompany.com 12使Linux系统信任根证书 cat /etc/pki/CA/cacert.pem &gt;&gt; /etc/pki/tls/certs/ca-bundle.crt 12签发证书 yum -y install nginx //安装nginx mkdir /etc/nginx/ssl //创建ssl目录用来存放密钥文件和证书申请文件 //创建密钥文件和证书申请文件 (umask 077;openssl genrsa -out /etc/nginx/ssl/docker.key 2048) openssl req -new -key /etc/nginx/ssl/docker.key -out /etc/nginx/ssl/docker.csr 12填写的申请信息前四项要和私有CA的信息一致 Country Name (2 letter code) [XX]:CN State or Province Name (full name) []:Beijing Locality Name (eg, city) [Default City]:Beijing Organization Name (eg, company) [Default Company Ltd]:mycompany Organizational Unit Name (eg, section) []:ops Common Name (eg, your name or your server&apos;s hostname) []:registry.mycompany.com Email Address []:admin@mycompany.com #直接回车 A challenge password []: An optional company name []: 12签署，证书 [root@node1 ~]# openssl ca -in /etc/nginx/ssl/docker.csr -out /etc/nginx/ssl/docker.crt -days 3650 Using configuration from /etc/pki/tls/openssl.cnf Check that the request matches the signature Signature ok Certificate Details: Serial Number: 1 (0x1) Validity Not Before: Mar 30 08:12:58 2017 GMT Not After : Mar 28 08:12:58 2027 GMT Subject: countryName = CN stateOrProvinceName = Beijing organizationName = mycompany organizationalUnitName = ops commonName = registry.mycompany.com emailAddress = admin@mycompany.com X509v3 extensions: X509v3 Basic Constraints: CA:FALSE Netscape Comment: OpenSSL Generated Certificate X509v3 Subject Key Identifier: 59:27:56:F3:67:46:4B:6D:A5:1B:66:C0:D8:C7:7D:0F:CA:90:C2:ED X509v3 Authority Key Identifier: keyid:76:4A:E0:BB:91:F5:0C:B2:67:2E:D1:3C:74:2B:05:F6:2C:A9:9B:7B Certificate is to be certified until Mar 28 08:12:58 2027 GMT (3650 days) Sign the certificate? [y/n]:y 1 out of 1 certificate requests certified, commit? [y/n]y Write out database with 1 new entries Data Base Updated 12检查index.txt和serial序列号更新 [root@node1 ~]# cat /etc/pki/CA/index.txt V 270328055023Z 01 unknown /C=CN/ST=Beijing/O=mycompany/OU=ops/CN=registry.mycompany.com/emailAddress=admin@mycompany.com [root@node1 ~]# cat /etc/pki/CA/serial 02 123 ### 基于localhost搭建docker-registry 启动registry docker run -d -p 5000:5000 --restart=always --name registry -v /opt/registry:/var/lib/registry registry:2 12从dockerhub下载centos镜像，使用docker tag 将 centos 这个镜像标记为 localhost:5000/centos docker pull centos &amp;&amp; docker tag centos localhost:5000/centos 12使用docker push 上传标记的镜像 docker push localhost:5000/centos 12从私有仓库下载镜像 docker pull localhost:5000/centos 1234 ### 配置nginx反向代理docker registry - **为nginx添加认证** yum -y install httpd-tools htpasswd -cb /etc/nginx/conf.d/docker-registry.htpasswd admin admin 1- **添加nginx的server** [root@node1 ~]# cat /etc/nginx/conf.d/docker-registry.conf upstream docker-registry { server 127.0.0.1:5000; } server { listen 443; server_name registry.mycompany.com; ssl on; ssl_certificate /etc/nginx/ssl/docker.crt; ssl_certificate_key /etc/nginx/ssl/docker.key; client_max_body_size 0; chunked_transfer_encoding on; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location / { auth_basic &quot;Docker registry&quot;; auth_basic_user_file /etc/nginx/conf.d/docker-registry.htpasswd; proxy_pass http://docker-registry; } location /_ping{ auth_basic off; proxy_pass http://docker-registry; } location /v1/_ping{ auth_basic off; proxy_pass http://docker-registry; } } 12- **重启nginx** systemctl restart nginx 12- **修改hosts** 10.0.7.1 registry.mycompany.com 12- **测试** [root@node1 ~]# docker login registry.mycompany.com Username: admin Password: Login Succeeded 12- **上传镜像** docker tag centos registry.mycompany.com/centos docker push registry.mycompany.com/centos 12- **查看** curl --user admin:admin https://registry.mycompany.com/v2/_catalog {&quot;repositories&quot;:[&quot;centos&quot;]} 12- **配置局域网内其他机器认证** // 修改hosts vim /etc/hosts 10.0.7.1 registry.mycompany.com //同样的系统版本,直接覆盖ca-bundle.crt， scp -rp /etc/pki/tls/certs/ca-bundle.crt root@10.0.7.2:/etc/pki/tls/certs/ca-bundle.crt 12不同版本把CA的密钥发送到客户机，并添加到ca-bundle.crt scp -rp /etc/pki/CA/cacert.pem root@10.0.7.2:/etc/pki/CA/cacert.pem cat /etc/pki/CA/cacert.pem &gt;&gt; /etc/pki/tls/certs/ca-bundle.crt 12重启docker，如果不重启会出现docker提示x509证书没有授权 systemctl daemon-reload systemctl restart docker 12验证 [root@node1 ~]# curl --user admin:admin https://registry.mycompany.com/v2/_catalog {&quot;repositories&quot;:[&quot;centos&quot;]} [root@node1 ~]# docker login registry.mycompany.com Username: admin Password: Login Succeeded [root@node1 ~]# docker pull registry.mycompany.com/centos Using default tag: latest latest: Pulling from centos 4969bbd91a1e: Pull complete Digest: sha256:d7f3db1caf4ea76117abce89709ebfc66c9339e13866016b8b2e4eee3ab4bea0 Status: Downloaded newer image for registry.mycompany.com/centos:latest 1234 ## Docker 网络### 查看容器IP - ** 第一种方法 ** docker run -d --name nginx nginx docker inspect --format &apos;{{ .NetworkSettings.IPAddress }}&apos; nginx 1- ** 第二种方法 ** docker exec -ti nginx ip add | grep global 1- ** 第三种方法 ** docker exec -ti nginx cat /etc/hosts 123 ### 端口映射 把Docker的内部端口通过端口映射的方法映射到宿主机的某一个端口，当使用 -P 标记时，Docker 会随机映射一个 `49000~49900` 的端口到内部容器开放的网络端口。 docker run -d -P nginx docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 3a5ec1bc2837 nginx &quot;nginx -g &apos;daemon ...&quot; About an hour ago Up About an hour 0.0.0.0:2049-&gt;80/tcp, 0.0.0.0:2048-&gt;443/tcp adoring_pike 12通过docker logs查看应用信息 [root@node1 ~]# docker logs -f adoring_pike 172.17.0.1 - - [30/Mar/2017:15:02:40 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.29.0&quot; &quot;-&quot; 10.0.7.1 - - [30/Mar/2017:15:02:47 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.29.0&quot; &quot;-&quot; 1234-p（小写的）则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有`ip:hostPort:containerPort` | `ip::containerPort` | `hostPort:containerPort`。映射到本机所有IP的 80 端口映射到容器的 80 端口 docker run -d -p 80：80 nginx 12查看映射的端口 docker port adoring_pike 123## 容器互联 使用 `--link` 参数可以让容器之间安全的进行交互。 下面先创建一个新的数据库容器。 docker run -d --name db training/postgres 12然后创建一个 web 容器，并将它连接到 db 容器 docker run -d -P --name web --link db:db training/webapp python app.py 12345此时，db 容器和 web 容器建立互联关系。`--link` 参数的格式为 `--link name:alias`，其中 name 是要链接的容器的名称，alias 是这个连接的别名。使用 `env` 命令来查看 web 容器的环境变量 [root@node1 ~]# docker run --rm --name web2 --link db:db training/webapp env PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin HOSTNAME=f2868b0479d8 DB_PORT=tcp://172.17.0.8:5432 DB_PORT_5432_TCP=tcp://172.17.0.8:5432 DB_PORT_5432_TCP_ADDR=172.17.0.8 DB_PORT_5432_TCP_PORT=5432 DB_PORT_5432_TCP_PROTO=tcp DB_NAME=/web2/db DB_ENV_PG_VERSION=9.3 HOME=/root 1234其中 DB_ 开头的环境变量是供 web 容器连接 db 容器使用，前缀采用大写的连接别名。除了环境变量，`Docker` 还添加 `host` 信息到父容器的 `/etc/hosts `的文件。下面是父容器 web 的 hosts 文件 [root@node1 ~]# docker run -t -i --rm --link db:db training/webapp /bin/bash root@8299f9685894:/opt/webapp# cat /etc/hosts 127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters 172.17.0.8 db d65ebb9124a4 172.17.0.10 8299f9685894 1234567891011121314## docker的网络模式 Docker的网络模式分为四种### Bridge模式 当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。 从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。在主机上创建一对虚拟网卡veth pair设备，Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0（容器的网卡），另一端放在主机中，以vethxxx这样类似的名字命名，并将这个网络设备加入到docker0网桥中。可以通过brctl show命令查看。 bridge模式是docker的默认网络模式，不写--net参数，就是bridge模式。使用docker run -p时，docker实际是在iptables做了DNAT规则，实现端口转发功能。 可以使用iptables -t nat -vnL查看。 bridge模式如下图所示： ![bridge模式](/images/bridge-mode.png) 演示： docker run -tid --net=bridge --name docker_bri1 ubuntu-base:v3 docker run -tid --net=bridge --name docker_bri2 ubuntu-base:v3 brctl show docker exec -ti docker_bri1 /bin/bash docker exec -ti docker_bri1 /bin/bash ifconfig –a route –n 1234567891011121314151617181920212223242526272829303132 ### Host模式 如果启动容器的时候使用`host`模式，那么这个容器将不会获得一个独立的`Network Namespace`，而是和宿主机共用一个`Network Namespace`。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。 Host模式如下图所示： ![Host模式](/images/docker-host-mode.png) ### Container模式 这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。 Container模式示意图： ![Container模式](/images/docker-container-mode.png) ### None模式 使用none模式，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。 ![None模式](/images/docker-none-mode.png) ## Docker网络设置### 配置 DNS 在docker run时使用以下参数： 参数 说明 -h HOSTNAME or --hostname=HOSTNAME 设定容器的主机名，它会被写到容器内的 /etc/hostname 和/etc/hosts。但它在容器外部看不到，既不会在 docker ps 中显示，也不会在其他的容器的/etc/hosts 看到。 --link=CONTAINER_NAME:ALIAS 选项会在创建容器的时候，添加一个其他容器的主机名到 /etc/hosts 文件中，让新容器的进程可以使用主机名 ALIAS 就可以连接它。 --dns=IP_ADDRESS 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。 --dns-search=DOMAIN 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索host，还会搜索 host.example.com。 注意：如果没有上述最后 2 个选项，Docker 会默认用主机上的 /etc/resolv.conf 来配置容器。 ### 容器访问控制 - ** 容器访问外部网络 ** 容器要想访问外部网络，需要本地系统的转发支持。在Linux 系统中，检查转发是否打开。 sysctl net.ipv4.ip_forward net.ipv4.ip_forward = 1 1234567891011121314- ** 容器之间访问 ** 容器之间相互访问，需要两方面的支持。 - 容器的网络拓扑是否已经互联。默认情况下，所有容器都会被连接到 `docker0` 网桥上。 - 本地系统的防火墙软件 `-- iptables `是否允许通过。- ** 访问所有端口 ** 当启动 Docker 服务时候，默认会添加一条转发策略到 iptables 的 FORWARD 链上。策略为通过（ACCEPT）还是禁止（DROP）取决于配置 --icc=true（缺省值）还是 --icc=false。当然，如果手动指定 --iptables=false 则不会添加 iptables 规则。 可见，默认情况下，不同容器之间是允许网络互通的。如果为了安全考虑，可以在docker服务修改/usr/lib/systemd/system/docker.service启动时添加--icc=false。 - ** 访问指定端口 ** 在通过 -icc=false 关闭网络访问后，可以通过 `--link=CONTAINER_NAME:ALIAS` 选项来访问容器的开放端口。 例如，在启动 Docker 服务时，可以同时使用 `--icc=false --iptables=true` 参数来关闭允许相互的网络访问，并让 `Docker` 可以修改系统中的 `iptables` 规则。此时，系统中的 `iptables` 规则可能是类似 iptables -nL ... Chain FORWARD (policy ACCEPT) target prot opt source destination DROP all -- 0.0.0.0/0 0.0.0.0/0 ... 12345678 ## 国内加速 由于国外的docker镜像仓库一般都比较慢，所以一般会使用国内的一些加速仓库，如阿里云 申请：https://cr.console.aliyun.com/#/accelerator 配置 mkdir -p /etc/docker cat /etc/docker/daemon.json { &quot;registry-mirrors&quot;: [&quot;https://xxxxxxx.mirror.aliyuncs.com&quot;] } https://xxxxxxx.mirror.aliyuncs.com替换成你申请到的地址。//https://5f2jam6c.mirror.aliyuncs.com sudo systemctl daemon-reload sudo systemctl restart docker 1234567891011 ## Docker Compose使用### 简介&gt; Docker Compose是一个用来定义和运行复杂应用的Docker工具。使用Compose，你可以在一个文件中定义一个多容器应用，然后使用一条命令来启动你的应用，完成一切准备工作。&gt; 一个使用Docker容器的应用，通常由多个容器组成。使用Docker Compose，不再需要使用shell脚本来启动容器。在配置文件中，所有的容器通过services来定义，然后使用docker-compose脚本来启动，停止和重启应用，和应用中的服务以及所有依赖服务的容器。### 安装## 安装 docker-compose curl -L https://get.daocloud.io/docker/compose/releases/download/1.18.0/docker-compose-`uname -s-uname -m` &gt; /usr/local/bin/docker-composechmod +x /usr/bin/docker-composedocker-compose –version1234### 配置文件 下面为一份 `docker-compose` 参考配置文件: version: &apos;2&apos; services: web: image: dockercloud/hello-world ports: - 8080 networks: - front-tier - back-tier redis: image: redis links: - web networks: - back-tier lb: image: dockercloud/haproxy ports: - 80:80 links: - web networks: - front-tier - back-tier volumes: - /var/run/docker.sock:/var/run/docker.sock networks: front-tier: driver: bridge back-tier: driver: bridge 1234 可以看到一份标准配置文件应该包含 version、services、networks 三大部分，其中最关键的就是 services 和 networks 两个部分，下面先来看 services 的书写规则。 ### image services: web: image: hello-world 123在 services 标签下的第二级标签是 web，这个名字是用户自己自定义，它就是服务名称。image 则是指定服务的镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。例如下面这些格式都是可以的： image: redis image: ubuntu:14.04 image: tutum/influxdb image: example-registry.com:4000/postgresql image: a4bc65fd 123 ### build 服务除了可以基于指定的镜像，还可以基于一份 Dockerfile，在使用 up 启动之时执行构建任务，这个构建标签就是 build，它可以指定 Dockerfile 所在文件夹的路径。Compose 将会利用它自动构建这个镜像，然后使用这个镜像启动服务容器。 build: /path/to/build/dir 12也可以是相对路径，只要上下文确定就可以读取到 Dockerfile。 build: ./dir 12设定上下文根目录，然后以该目录为准指定 Dockerfile。 build: context: ../ dockerfile: path/of/Dockerfile 123注意 build 都是一个目录，如果你要指定 Dockerfile 文件需要在 build 标签的子级标签中使用 dockerfile 标签指定，如上面的例子。如果你同时指定了 image 和 build 两个标签，那么 Compose 会构建镜像并且把镜像命名为 image 后面的那个名字。 build: ./dir image: webapp:tag 12既然可以在 docker-compose.yml 中定义构建任务，那么一定少不了 arg 这个标签，就像 Dockerfile 中的 ARG 指令，它可以在构建过程中指定环境变量，但是在构建成功后取消，在 docker-compose.yml 文件中也支持这样的写法： build: context: . args: buildno: 1 password: secret 12下面这种写法也是支持的，一般来说下面的写法更适合阅读。 build: context: . args: - buildno=1 - password=secret 12与 ENV 不同的是，ARG 是允许空值的。例如： args: - buildno - password 1234567 这样构建过程可以向它们赋值。 &gt; 注意：YAML 的布尔值（true, false, yes, no, on, off）必须要使用引号引起来（单引号、双引号均可），否则会当成字符串解析。 ### command 使用 command 可以覆盖容器启动后默认执行的命令。 command: bundle exec thin -p 3000 12也可以写成类似 Dockerfile 中的格式： command: [bundle, exec, thin, -p, 3000] 1234 ### container_name 前面说过 Compose 的容器名称格式是：&lt;项目名称&gt;&lt;服务名称&gt;&lt;序号&gt; 虽然可以自定义项目名称、服务名称，但是如果你想完全控制容器的命名，可以使用这个标签指定： container_name: app 123456 这样容器的名字就指定为 app 了。### depends_on 在使用 Compose 时，最大的好处就是少打启动命令，但是一般项目容器启动的顺序是有要求的，如果直接从上到下启动容器，必然会因为容器依赖问题而启动失败。 例如在没启动数据库容器的时候启动了应用容器，这时候应用容器会因为找不到数据库而退出，为了避免这种情况我们需要加入一个标签，就是 depends_on，这个标签解决了容器的依赖、启动先后的问题。 例如下面容器会先启动 redis 和 db 两个服务，最后才启动 web 服务： version: &apos;2&apos; services: web: build: . depends_on: - db - redis redis: image: redis db: image: postgres 12345 &gt; 注意的是，默认情况下使用 docker-compose up web 这样的方式启动 web 服务时，也会启动 redis 和 db 两个服务，因为在配置文件中定义了依赖关系。 ### dns 和 --dns 参数一样用途，格式如下： dns: 8.8.8.8 12也可以是一个列表： dns: - 8.8.8.8 - 9.9.9.9 12此外 dns_search 的配置也类似： dns_search: example.com dns_search: - dc1.example.com - dc2.example.com 123 ### tmpfs 挂载临时目录到容器内部，与 run 的参数一样效果： tmpfs: /run tmpfs: - /run - /tmp 1234 ### entrypoint 在 Dockerfile 中有一个指令叫做 ENTRYPOINT 指令，用于指定接入点，第四章有对比过与 CMD 的区别。 在 docker-compose.yml 中可以定义接入点，覆盖 Dockerfile 中的定义： entrypoint: /code/entrypoint.sh 12格式和 Docker 类似，不过还可以写成这样： entrypoint: - php - -d - zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so - -d - memory_limit=-1 - vendor/bin/phpunit 1234567 ### env_file 还记得前面提到的 .env 文件吧，这个文件可以设置 Compose 的变量。而在 docker-compose.yml 中可以定义一个专门存放变量的文件。 如果通过 docker-compose -f FILE 指定了配置文件，则 env_file 中路径会使用配置文件路径。 如果有变量名称与 environment 指令冲突，则以后者为准。格式如下： env_file: .env 1或者根据 docker-compose.yml 设置多个： env_file: - ./common.env - ./apps/web.env - /opt/secrets.env 123456 &gt; 注意的是这里所说的环境变量是对宿主机的 Compose 而言的，如果在配置文件中有 build 操作，这些变量并不会进入构建过程中，如果要在构建中使用变量还是首选前面刚讲的 arg 标签。 ### environment 与上面的 env_file 标签完全不同，反而和 arg 有几分类似，这个标签的作用是设置镜像变量，它可以保存变量到镜像里面，也就是说启动的容器也会包含这些变量设置，这是与 arg 最大的不同。 一般 arg 标签的变量仅用在构建过程中。而 environment 和 Dockerfile 中的 ENV 指令一样会把变量一直保存在镜像、容器中，类似 docker run -e 的效果。 environment: RACK_ENV: development SHOW: &apos;true&apos; SESSION_SECRET: environment: - RACK_ENV=development - SHOW=true - SESSION_SECRET 1234 ### expose 这个标签与Dockerfile中的EXPOSE指令一样，用于指定暴露的端口，但是只是作为一种参考，实际上docker-compose.yml的端口映射还得ports这样的标签。 expose: - &quot;3000&quot; - &quot;8000&quot; 12345 ### external_links 在使用Docker过程中，我们会有许多单独使用docker run启动的容器，为了使Compose能够连接这些不在docker-compose.yml中定义的容器，我们需要一个特殊的标签，就是external_links，它可以让Compose项目里面的容器连接到那些项目配置外部的容器（前提是外部容器中必须至少有一个容器是连接到与项目内的服务的同一个网络里面）。 格式如下： external_links: - redis_1 - project_db_1:mysql - project_db_1:postgresql 123 ### extra_hosts 添加主机名的标签，就是往/etc/hosts文件中添加一些记录，与Docker client的--add-host类似： extra_hosts: - &quot;somehost:162.242.195.82&quot; - &quot;otherhost:50.31.209.229&quot; 1启动之后查看容器内部hosts： 162.242.195.82 somehost 50.31.209.229 otherhost 123 ### labels 向容器添加元数据，和Dockerfile的LABEL指令一个意思，格式如下： labels: com.example.description: &quot;Accounting webapp&quot; com.example.department: &quot;Finance&quot; com.example.label-with-empty-value: &quot;&quot; labels: - &quot;com.example.description=Accounting webapp&quot; - &quot;com.example.department=Finance&quot; - &quot;com.example.label-with-empty-value&quot; 123### links 还记得上面的depends_on吧，那个标签解决的是启动顺序问题，这个标签解决的是容器连接问题，与Docker client的--link一样效果，会连接到其它服务中的容器。 格式如下： links: - db - db:database - redis 1使用的别名将会自动在服务容器中的/etc/hosts里创建。例如： 172.12.2.186 db 172.12.2.186 database 172.12.2.187 redis 123 相应的环境变量也将被创建。### logging 这个标签用于配置日志服务。格式如下： logging: driver: syslog options: syslog-address: &quot;tcp://192.168.0.42:123&quot; 12345 默认的driver是json-file。只有json-file和journald可以通过docker-compose logs显示日志，其他方式有其他日志查看方式，但目前Compose不支持。对于可选值可以使用options指定。 ### pid pid: &quot;host&quot; 1234 将PID模式设置为主机PID模式，跟主机系统共享进程命名空间。容器使用这个标签将能够访问和操纵其他容器和宿主机的名称空间。### ports 映射端口的标签。 使用HOST:CONTAINER格式或者只是指定容器的端口，宿主机会随机映射端口。 ports: - &quot;3000&quot; - &quot;8000:8000&quot; - &quot;49100:22&quot; - &quot;127.0.0.1:8001:8001&quot; 12345 &gt; 注意：当使用HOST:CONTAINER格式来映射端口时，如果你使用的容器端口小于60你可能会得到错误得结果，因为YAML将会解析xx:yy这种数字格式为60进制。所以建议采用字符串格式。 ### security_opt 为每个容器覆盖默认的标签。简单说来就是管理全部服务的标签。比如设置全部服务的user标签值为USER。 security_opt: - label:user:USER - label:role:ROLE 1234 ### stop_signal 设置另一个信号来停止容器。在默认情况下使用的是SIGTERM停止容器。设置另一个信号可以使用stop_signal标签。 stop_signal: SIGUSR1 1234### volumes 挂载一个目录或者一个已存在的数据卷容器，可以直接使用 [HOST:CONTAINER] 这样的格式，或者使用 [HOST:CONTAINER:ro] 这样的格式，后者对于容器来说，数据卷是只读的，这样可以有效保护宿主机的文件系统。 Compose的数据卷指定路径可以是相对路径，使用 . 或者 .. 来指定相对目录。 数据卷的格式可以是下面多种形式： volumes: // 只是指定一个路径，Docker 会自动在创建一个数据卷（这个路径是容器内部的）。 - /var/lib/mysql // 使用绝对路径挂载数据卷 - /opt/data:/var/lib/mysql // 以 Compose 配置文件为中心的相对路径作为数据卷挂载到容器。 - ./cache:/tmp/cache // 使用用户的相对路径（~/ 表示的目录是 /home/&lt;用户目录&gt;/ 或者 /root/）。 - ~/configs:/etc/configs/:ro // 已经存在的命名的数据卷。 - datavolume:/var/lib/mysql 12如果你不使用宿主机的路径，你可以指定一个volume_driver。 volume_driver: mydriver 12### volumes_from 从其它容器或者服务挂载数据卷，可选的参数是 :ro或者 :rw，前者表示容器只读，后者表示容器对数据卷是可读可写的。默认情况下是可读可写的。 volumes_from: - service_name - service_name:ro - container:container_name - container:container_name:rw 123 ### cap_add, cap_drop 添加或删除容器的内核功能。详细信息在前面容器章节有讲解，此处不再赘述。 cap_add: - ALL cap_drop: - NET_ADMIN - SYS_ADMIN 12### cgroup_parent 指定一个容器的父级cgroup cgroup_parent: m-executor-abcd 12### devices 设备映射列表。与Docker client的--device参数类似。 devices: - &quot;/dev/ttyUSB0:/dev/ttyUSB0&quot; 12### extends 这个标签可以扩展另一个服务，扩展内容可以是来自在当前文件，也可以是来自其他文件，相同服务的情况下，后来者会有选择地覆盖原有配置。 extends: file: common.yml service: webapp 123456 用户可以在任何地方使用这个标签，只要标签内容包含file和service两个值就可以了。 file的值可以是相对或者绝对路径，如果不指定file的值，那么Compose会读取当前YML文件的信息。### network_mode 网络模式，与Docker client的--net参数类似，只是相对多了一个service:[service name] 的格式。 network_mode: &quot;bridge&quot; network_mode: &quot;host&quot; network_mode: &quot;none&quot; network_mode: &quot;service:[service name]&quot; network_mode: &quot;container:[container name/id]&quot; 1234 可以指定使用服务或者容器的网络。 ### networks 加入指定网络，格式如下： services: some-service: networks: - some-network - other-network 1关于这个标签还有一个特别的子标签aliases，这是一个用来设置服务别名的标签，例如： services: some-service: networks: some-network: aliases: - alias1 - alias3 other-network: aliases: - alias2 123456 相同的服务可以在不同的网络有不同的别名。## 阿里自定义镜像[阿里容器HUB控制台](https://cr.console.aliyun.com/)### 登录 docker login -u 1012202451213731 -p {passwd} https://registry.acs.aliyun.com 123### 打标签https://registry.acs.aliyun.com docker tag bf46626ea2a8 registry.acs.aliyun.com/1012202451213731/laravel_taobao:v1.01### 配置加速器 echo “DOCKER_OPTS=\\”\\$DOCKER_OPTS –registry-mirror=https://lqjizur.mirror.acs.aliyun.com\\“” | sudo tee -a /etc/default/dockersudo service docker restart12### docker push docker push registry.acs.aliyun.com/1012202451213731/austin_laravel_taobao:v1.0``` 常用操作命令 查看当前启动的容器sudo docker ps 启动部分服务在后边加服务名，不加表示启动所有，-d 表示在后台运行sudo docker-compose up [nginx|php71|mysql|redis] -d 停止和启动类似sudo docker-compose stop [nginx|php71|mysql|redis] 删除所有未运行的容器sudo docker rm $(docker ps -qf status=exited) 删除所有镜像，-f 可以强制删除sudo docker rmi $(docker images -q) (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"docker","slug":"docker","permalink":"https://austinxishou.github.io/tags/docker/"}]},{"title":"fileinput.js 实现文件上传功能","date":"2018-01-01T11:28:22.096Z","path":"2018/01/01/webdesign/wantu-cdn-sdk/","text":"About-简介官方文档 官方jssdk实现 顽兔html5 js上传组件 使用方法window.uploadJSSDK({ file: File, //文件，必填,html5 file类型，不需要读数据流 token: &apos;test&apos;, //鉴权token，必填 dir: &apos;&apos;, //目录，选填，默认根目录&apos;&apos; retries: 0, //重试次数，选填，默认0不重试 maxSize: 0, //上传大小限制，选填，默认0没有限制 chunkSize: 4*1024*1024, //分片上传每片大小，选填，默认4M name: &quot;test&quot;, //文件名称，选填，默认为文件名称 callback: function (percent, result) { //percent（上传百分比）：-1失败；0-100上传的百分比；100即完成上传 //result(服务端返回的responseText，json格式) } }); upfile.js分析1234567891011121314151617if (!file || !token) &#123; callback(-1, &apos;上传文件参数必须配置file以及token&apos;); return; &#125; if (maxSize &amp;&amp; file.size &gt; maxSize) &#123; callback(-1, &quot;文件大小不能超过&quot;+maxSize); return; &#125; if (file.size &gt; chunkSize) &#123; //分块上传 startChunks(); &#125; else &#123; //普通上传 uploadSingle(); &#125; uploadSingle-普通上传123456789101112131415161718function uploadSingle() &#123; var formData = new FormData(); formData.append(&apos;dir&apos;, dir); formData.append(&apos;name&apos;, configName); formData.append(&apos;size&apos;, file.size); formData.append(&apos;content&apos;, file); var url = upload_url; ajax(url, formData, function (e) &#123; var status = e.status, message = e.statusText || &quot;&quot;; if (status == 200 &amp;&amp; message == &quot;OK&quot;) &#123; callback(100, JSON.parse(e.responseText)); &#125; else &#123; handleError(JSON.parse(e.responseText), &quot;&quot;, &quot;&quot;, status); &#125; &#125;); &#125; 123456789101112131415function ajax(url,data,complete)&#123; var request = new XMLHttpRequest(); var query = &apos;Authorization=&apos; + token + &apos;&amp;UserAgent=ALIMEDIASDK_WORKSTATION&apos;; if(url.indexOf(&apos;?&apos;) &gt; -1)&#123; url += &apos;&amp;&apos; + query; &#125;else&#123; url += &apos;?&apos; + query; &#125; request.open(&apos;POST&apos;, url); request.onload = function(e) &#123; complete(request); &#125;; request.send(data);&#125; 配合plupload.js使用 (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://austinxishou.github.io/tags/JavaScript/"}]},{"title":"移动Web前端知识库","date":"2017-12-19T09:38:15.801Z","path":"2017/12/19/webdesign/iframe-cross-domain-control/","text":"iframe与主框架跨域相互访问方法iframe closed by itself123456789//close by myselfwindow.parent.document.body.removeChild(window.frameElement);//close by parent window //not cross domaintop.window.close_iframe();//parent.close_iframe();//close by id //not allowed with cross originlet iframeRoom = window.parent.document.getElementById(&apos;iframe_room&apos;);iframeRoom.parentNode.removeChild(iframeRoom); 1.同域相互访问假设A.html 与 b.html domain都是localhost （同域） A.html中iframe 嵌入 B.html，name=myframe A.html有js function fMain() B.html有js function fIframe() 需要实现 A.html 调用 B.html 的 fIframe()，B.html 调用 A.html 的 fMain() A.html 1234567891011121314151617181920212223242526&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt; main window &lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; // main js function function fMain()&#123; alert(&apos;main function execute success&apos;); &#125; // exec iframe function function exec_iframe()&#123; window.myframe.fIframe(); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;A.html main&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;exec iframe function&quot; onclick=&quot;exec_iframe()&quot;&gt;&lt;/p&gt; &lt;iframe src=&quot;B.html&quot; name=&quot;myframe&quot; width=&quot;500&quot; height=&quot;100&quot;&gt;&lt;/iframe&gt; &lt;/body&gt; &lt;/html&gt; B.html 12345678910111213141516171819202122232425&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt; iframe window &lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; // iframe js function function fIframe()&#123; alert(&apos;iframe function execute success&apos;); &#125; // exec main function function exec_main()&#123; parent.fMain(); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;B.html iframe&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;exec main function&quot; onclick=&quot;exec_main()&quot;&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 点击A.html 的 exec iframe function button，执行成功 跨域互相访问假设 A.html domain是 localhost， B.html domain 是 127.0.0.1 （跨域） 这里使用 localhost 与 127.0.0.1 只是方便测试，localhost 与 127.0.0.1已经不同一个域，因此执行效果是一样的。 实际使用时换成 www.domaina.com 与 www.domainb.com 即可。 A.html中iframe 嵌入 B.html，name=myframe A.html有js function fMain() B.html有js function fIframe() 需要实现 A.html 调用 B.html 的 fIframe()，B.html 调用 A.html 的 fMain() （跨域调用） 如果使用上面同域的方法，浏览器判断A.html 与 B.html 不同域，会有错误提示。 Uncaught SecurityError: Blocked a frame with origin “http://localhost“ from accessing a frame with origin “http://127.0.0.1“. Protocols, domains, and ports must match. 实现原理： 因为浏览器为了安全，禁止了不同域访问。因此只要调用与执行的双方是同域则可以相互访问。 首先，A.html 如何调用B.html的 fIframe方法 1.在A.html 创建一个 iframe 2.iframe的页面放在 B.html 同域下，命名为execB.html 3.execB.html 里有调用B.html fIframe方法的js调用 123&lt;script type=&quot;text/javascript&quot;&gt; parent.window.myframe.fIframe(); // execute parent myframe fIframe function &lt;/script&gt; 这样就能实现 A.html 与 B.html 跨域相互调用。 A.html1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt; main window &lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; // main js function function fMain()&#123; alert(&apos;main function execute success&apos;); &#125; // exec iframe function function exec_iframe()&#123; if(typeof(exec_obj)==&apos;undefined&apos;)&#123; exec_obj = document.createElement(&apos;iframe&apos;); exec_obj.name = &apos;tmp_frame&apos;; exec_obj.src = &apos;http://127.0.0.1/execB.html&apos;; exec_obj.style.display = &apos;none&apos;; document.body.appendChild(exec_obj); &#125;else&#123; exec_obj.src = &apos;http://127.0.0.1/execB.html?&apos; + Math.random(); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;A.html main&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;exec iframe function&quot; onclick=&quot;exec_iframe()&quot;&gt;&lt;/p&gt; &lt;iframe src=&quot;http://127.0.0.1/B.html&quot; name=&quot;myframe&quot; width=&quot;500&quot; height=&quot;100&quot;&gt;&lt;/iframe&gt; &lt;/body&gt; &lt;/html&gt; B.html123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt; iframe window &lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; // iframe js function function fIframe()&#123; alert(&apos;iframe function execute success&apos;); &#125; // exec main function function exec_main()&#123; if(typeof(exec_obj)==&apos;undefined&apos;)&#123; exec_obj = document.createElement(&apos;iframe&apos;); exec_obj.name = &apos;tmp_frame&apos;; exec_obj.src = &apos;http://localhost/execA.html&apos;; exec_obj.style.display = &apos;none&apos;; document.body.appendChild(exec_obj); &#125;else&#123; exec_obj.src = &apos;http://localhost/execA.html?&apos; + Math.random(); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;B.html iframe&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;exec main function&quot; onclick=&quot;exec_main()&quot;&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; execA.html12345678910111213&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt; exec main function &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; parent.parent.fMain(); // execute main function &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; execB.html12345678910111213&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt; exec iframe function &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; parent.window.myframe.fIframe(); // execute parent myframe fIframe function &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"html","slug":"html","permalink":"https://austinxishou.github.io/tags/html/"}]},{"title":"","date":"2017-12-18T11:42:44.110Z","path":"2017/12/18/webdesign/JavaScript-parse-url-parameter/","text":"(function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[]},{"title":"docker-lnmp 多容器部署 Laravel 方案","date":"2017-12-05T08:37:33.278Z","path":"2017/12/05/server/docker-lnmp-laravel/","text":"参考文档使用Docker搭建Laravel环境 利用docker快速搭建 laravel 环境 docker-composedocker-compose.yml简单介绍docker-compose是用来管理编排多个容器协作的。 通过docker-compose.yml来编排nginx、php、mysql之间的通信和协作。 在docker-lnmp目录下通过命令 docker-compose up 启动容器 然后通过 localhost或者localhost:8000就可以访问index.php了 MysqlMysql镜像直接来自与官方,没有做任何修改。官方Mysql镜像构建参考 12345678mysql: ### 容器名称 image: mysql:5.7 ### 官方镜像 版本号5.7 volumes: - mysql-data:/var/lib/mysql ### 数据卷，mysql数据就存放在这里 ports: - &quot;3306:3306&quot; ###端口映射，主机端口:容器对外端口 environment: - MYSQL_ROOT_PASSWORD=123456 ### 设置环境变量，这个变量名是官方镜像定义的。 PHPPHP镜像也来自与官方，但是官方镜像并没有提供连接Mysql相关的pdo_mysql扩展，这里做了一点修改，所以不能直接用image来依赖官方镜像，需要单独写一个Dockerfile来自定义PHP镜像。 123456789php-fpm: build: context: ./php ### 自定义PHP镜像的配置目录 volumes: - ./www:/var/www/html ### 主机文件与容器文件映射共享，PHP代码存这里 expose: - &quot;9000&quot; ### 容器对外暴露的端口 depends_on: - mysql ### 依赖并链接Mysql容器，这样在PHP容器就可以通过mysql作为主机名来访问Mysql容器了 自定义PHP镜像的配置文件 Dockerfile 1234567891011121314151617181920### 来自官方的PHP镜像版本为7.1-fpm.### 该版本只包含FPM不包括CLI,所以这里并不能执行composer### 如果需要用PHP-CLI 需要再开一个CLI容器，或者安装同时包含FPM和CLI的版本FROM php:7.1-fpm ### 设置环境变量ENV TZ=Asia/Shanghai### 执行bash命令安装php所需的扩展RUN apt-get update &amp;&amp; apt-get install -y \\ libfreetype6-dev \\ libjpeg62-turbo-dev \\ libmcrypt-dev \\ libpng12-dev \\ ### 这里是docker提供的安装php扩展的方法，在这里安装了pdo_mysql扩展还有GD库等 &amp;&amp; docker-php-ext-install -j$(nproc) iconv mcrypt mysqli pdo_mysql \\ &amp;&amp; docker-php-ext-configure gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ \\ &amp;&amp; docker-php-ext-install -j$(nproc) gd### 扩展php.iniCOPY ./php.ini /usr/local/etc/php/conf.d/php.ini NginxNginx需要配置一个server,所以也需要一点简单的定制 12345678910nginx: build: context: ./nginx ### 自定义Nginx镜像的配置目录 volumes: - ./www:/var/www/html 主机文件与容器文件映射共享，PHP代码存这里 ports: - &quot;80:80&quot; ### 端口映射，如果你主机80端口被占用，可以用8000:80 - &quot;443:443&quot; depends_on: - php-fpm ### 依赖并连接PHP容器，这样在Nginx容器就可以通过php-fpm作为主机名来访问PHP容器了 自定义Nginx镜像的配置文件Dockerfile 12345FROM nginx:1.11 ### 官方镜像ENV TZ=Asia/Shanghai ### 环境变量COPY ./nginx.conf /etc/nginx/conf.d/default.conf ### server配置 1234567891011121314151617181920212223242526272829server &#123; listen 80 default_server; listen [::]:80 default_server ipv6only=on; server_name localhost; root /var/www/html; index index.php index.html index.htm; location / &#123; try_files $uri $uri/ /index.php$is_args$args; &#125; location ~ \\.php$ &#123; try_files $uri /index.php =404; ### 主要是这里用 php-fpm:9000来访问PHP容器 fastcgi_pass php-fpm:9000; fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; location ~ /\\.ht &#123; deny all; &#125;&#125; 获取镜像1docker-compose pull 修改权限1sudo chown www-data:www-data -R www/ 多docker 容器部署laravel 环境&gt; 获取和启动运行Lavavel应用程序,我们不仅仅需要一个可以运行PHP的web服务器,我们也需要能够运行PHP命令行应用程序的composer和artisan.也许还有更好运行环境的方式(例如浏览器).但是这是一个好的基础整合Dokcer和Laravel.每个进程都有一个自己的容器. &gt; 有分离的`composer`和`artisan`容器对我们来说真是一大优势,我们可以只选择推送`docker-laravel-data`,`docker-laravel-nginx`和`docker-laravel-phpfpm`容器到生产环境. ![流程图框图](/images/docker-lnmp-map.png) docker-laravel-data1234567FROM debian:jessieMAINTAINER &quot;Dylan Lindgren&quot; &lt;dylan.lindgren@gmail.com&gt;RUN mkdir -p /dataVOLUME [&quot;/data&quot;]CMD [&quot;true&quot;] docker-laravel-nginx1234567891011121314151617181920212223242526272829FROM debian:jessieMAINTAINER &quot;Dylan Lindgren&quot; &lt;dylan.lindgren@gmail.com&gt;WORKDIR /tmp//Install NginxRUN apt-get update -y &amp;&amp; \\ apt-get install -y nginx//Apply Nginx configurationADD config/nginx.conf /opt/etc/nginx.confADD config/laravel /etc/nginx/sites-available/laravelRUN ln -s /etc/nginx/sites-available/laravel /etc/nginx/sites-enabled/laravel &amp;&amp; \\ rm /etc/nginx/sites-enabled/default//Nginx startup scriptADD config/nginx-start.sh /opt/bin/nginx-start.shRUN chmod u=rwx /opt/bin/nginx-start.shRUN mkdir -p /dataVOLUME [&quot;/data&quot;]//PORTSEXPOSE 80EXPOSE 443WORKDIR /opt/binENTRYPOINT [&quot;/opt/bin/nginx-start.sh&quot;] docker-laravel-phpfpmInstall Composer123RUN curl -sS https://getcomposer.org/installer | phpRUN mv composer.phar /usr/local/bin/composerRUN chmod a+x /usr/local/bin/composer Install MySQL package12345RUN echo &quot;mysql-server mysql-server/root_password password devpass&quot; | debconf-set-selectionsRUN echo &quot;mysql-server mysql-server/root_password_again password devpass&quot; | debconf-set-selectionsRUN apt-get update &amp;&amp; apt-get install -y mysql-server mysql-clientRUN usermod -d /var/lib/mysql/ mysqlRUN update-rc.d mysql defaults Access-Control-Allow-Origin 解决跨域权限问题Nginx 解决办法：add_header Access-Control-Allow-Origin *;add_header Access-Control-Allow-Headers X-Requested-With;add_header Access-Control-Allow-Methods GET,POST,OPTIONS;将这段代码添加到 http{} 或者静态资源对应的 server{} 中 如果只为自己的网站使用可以将第一行代码的星号改为自己的域名，例如 *.fbzl.org (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"docker","slug":"docker","permalink":"https://austinxishou.github.io/tags/docker/"}]},{"title":"移动Web前端知识库","date":"2017-12-05T02:32:37.189Z","path":"2017/12/05/webdesign/web-front-lib/","text":"(代码结构规范)[https://html5boilerplate.com/mobile/] (资源与工具)[https://github.com/AlloyTeam/Mars/tree/master/tools] 移动Web开发调试发布错误监控上报用户问题定位(function(){ var bp = document.createElement(‘script’); var curProtocol = window.location.protocol.split(‘:’)[0]; if (curProtocol === ‘https’) { bp.src = &apos;https://zz.bdstatic.com/linksubmit/push.js&apos;; } else { bp.src = &apos;http://push.zhanzhang.baidu.com/push.js&apos;; } var s = document.getElementsByTagName(“script”)[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == “http:”) ? “http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;:&quot;https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a“; document.write(‘&lt;\\/script&gt;’);})();","tags":[{"name":"html","slug":"html","permalink":"https://austinxishou.github.io/tags/html/"}]},{"title":"Javascript常用函数方法","date":"2017-12-05T02:08:23.446Z","path":"2017/12/05/webdesign/js-common-method/","text":"getParameter12345function getParameter(n) &#123; var m = window.location.hash.match(new RegExp(&apos;(?:#|&amp;)&apos; + n + &apos;=([^&amp;]*)(&amp;|$)&apos;)), result = !m ? &apos;&apos; : decodeURIComponent(m[1]) return result ||getParameterByName(n)&#125; 123456789function getParameterByName(name, url) &#123; if (!url) url = window.location.href name = name.replace(/[\\[\\]]/g, &quot;\\\\$&amp;&quot;) var regex = new RegExp(&quot;[?&amp;]&quot; + name + &quot;(=([^&amp;#]*)|&amp;|#|$)&quot;), results = regex.exec(url) if (!results) return null if (!results[2]) return &apos;&apos; return decodeURIComponent(results[2].replace(/\\+/g, &quot; &quot;))&#125; getCookie12345678function getCookie(name)&#123; var arr,reg=new RegExp(&quot;(^| )&quot;+name+&quot;=([^;]*)(;|$)&quot;) if(arr=document.cookie.match(reg)) return unescape(arr[2]) else return null&#125;(function(){ var bp = document.createElement(‘script’); var curProtocol = window.location.protocol.split(‘:’)[0]; if (curProtocol === ‘https’) { bp.src = ‘https://zz.bdstatic.com/linksubmit/push.js‘; } else { bp.src = ‘http://push.zhanzhang.baidu.com/push.js‘; } var s = document.getElementsByTagName(“script”)[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == &quot;http:&quot;) ? &quot;http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;:&quot;https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;; document.write(&apos;&lt;script src=&quot;&apos; + sozzsrc + &apos;&quot; id=&quot;sozz&quot;&gt;&lt;\\/script&gt;&apos;); })();","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://austinxishou.github.io/tags/JavaScript/"}]},{"title":"Laravel加Vue技术应用系列-1","date":"2017-12-01T01:12:49.531Z","path":"2017/12/01/webdesign/Laravel-vue-series-1/","text":"Start-起步 起步说明: 选择Github资源: phanan/koel 官方文档-Official Documentation Install-安装初始环境需求 All requirements by Laravel – PHP, OpenSSL, composer and such. Consider setting PHP’s memory_limit to a good value (512M or better) if you have a big library. MySQL or MariaDB. Actually, any DBMS supported by Laravel should work. NodeJS latest stable with yarn(function(){ var bp = document.createElement(‘script’); var curProtocol = window.location.protocol.split(‘:’)[0]; if (curProtocol === ‘https’) { bp.src = &apos;https://zz.bdstatic.com/linksubmit/push.js&apos;; } else { bp.src = &apos;http://push.zhanzhang.baidu.com/push.js&apos;; } var s = document.getElementsByTagName(“script”)[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == “http:”) ? “http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;:&quot;https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a“; document.write(‘&lt;\\/script&gt;’);})();","tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://austinxishou.github.io/tags/Laravel/"},{"name":"Vue","slug":"Vue","permalink":"https://austinxishou.github.io/tags/Vue/"}]},{"title":"Laravel","date":"2017-11-28T03:08:39.181Z","path":"2017/11/28/webdesign/Laravel-vue-series-0/","text":"基本概念Request Lifecycle-请求生命周期1. `public/index.php` 加载框架 &gt; loads the Composer generated autoloader definition &gt; retrieves an instance of the Laravel application from bootstrap/app.php script 路由路由组&gt; 需要为一组路由配置一个中间件,另外排除特定的路由 1234567891011121314Route::group([&apos;prefix&apos; =&gt; &apos;admin&apos;, &apos;namespace&apos; =&gt; &apos;Admin&apos;], function() &#123; Route::get(&apos;login&apos;, &apos;AuthController@login&apos;); Route::get(&apos;logout&apos;, &apos;AuthController@logout&apos;); Route::group([&apos;middleware&apos; =&gt; &apos;authAdmin&apos;], function()&#123; Route::resource(&apos;page&apos;, &apos;PageController&apos;); Route::resource(&apos;article&apos;, &apos;ArticleController&apos;); Route::resource(&apos;gallery&apos;, &apos;GalleryController&apos;); Route::resource(&apos;user&apos;, &apos;UserController&apos;); // ... &#125;);&#125;); 12345678Route::group([&apos;prefix&apos;=&gt;&apos;taobao&apos;, &apos;namespace&apos; =&gt; &apos;Taobao&apos;],function()&#123; Route::match([&apos;get&apos;, &apos;post&apos;],&quot;addcode&quot;,&quot;TaobaoApiController@addcode&quot;); Route::group([&apos;middleware&apos; =&gt; &apos;tbtoken&apos;],function ()&#123; Route::match([&apos;get&apos;, &apos;post&apos;],&quot;test&quot;,&quot;TaobaoApiController@test&quot;); Route::match([&apos;get&apos;, &apos;post&apos;],&quot;getitem&quot;,&quot;TaobaoApiController@getitem&quot;); &#125;);&#125;); (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://austinxishou.github.io/tags/Laravel/"}]},{"title":"全景图编辑器js部分代码解析","date":"2017-11-27T02:24:55.493Z","path":"2017/11/27/webdesign/krpano-main-edit-js/","text":"资源管理 统一的资源管理弹窗, id=media_icon 各个需要选择资源的入口 统一的资源管理弹窗, id=media_icon123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;div class=&quot;modal fade in&quot; id=&quot;media_icon&quot; data-backdrop=&quot;static&quot; data-keyboard=&quot;false&quot; data-position=&quot;5%&quot; aria-hidden=&quot;false&quot; style=&quot;display: block;&quot;&gt; &lt;div class=&quot;modal-dialog modal-lg&quot; style=&quot;margin-top: 5%;&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-body&quot;&gt; &lt;ul id=&quot;myTab&quot; class=&quot;nav nav-tabs&quot;&gt; &lt;li class=&quot;&quot; style=&quot;display: none;&quot;&gt;&lt;a href=&quot;#music&quot; data-toggle=&quot;tab&quot; id=&quot;music_tab&quot;&gt;音乐&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;&quot;&gt;&lt;a href=&quot;#pic&quot; data-toggle=&quot;tab&quot; class=&quot;img_tab&quot;&gt;图片&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#upload&quot; data-toggle=&quot;tab&quot; id=&quot;upload_tab&quot;&gt;上传&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;find&quot; style=&quot;display: none;&quot;&gt;&lt;input type=&quot;text&quot; id=&quot;searchMediaInput&quot; placeholder=&quot;输入文件名，快速搜素&quot; class=&quot;form-control&quot;&gt;&lt;/li&gt; &lt;div class=&quot;btn_confirm&quot;&gt; &lt;li&gt; &lt;button class=&quot;btn btn-primary confirm-choose&quot; type=&quot;button&quot; onclick=&quot;chooseMediaResImg()&quot; style=&quot;display: none;&quot;&gt;确定选择&lt;/button&gt; &lt;/li&gt; &lt;li&gt; &lt;button class=&quot;btn&quot; type=&quot;button&quot; id=&quot;cancel_icon&quot; data-dismiss=&quot;modal&quot;&gt;取消 &lt;/button&gt; &lt;/li&gt; &lt;/div&gt; &lt;/ul&gt; &lt;div id=&quot;myTabContent&quot; class=&quot;tab-content&quot; style=&quot;height:410px;overflow: auto;&quot;&gt; &lt;div class=&quot;tab-pane fade clearfix&quot; id=&quot;music&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tab-pane fade clearfix&quot; id=&quot;pic&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tab-pane fade active in&quot; id=&quot;upload&quot;&gt; &lt;div class=&quot;file-input file-input-ajax-new&quot;&gt;&lt;div class=&quot;file-preview&quot;&gt; &lt;div class=&quot;close fileinput-remove&quot;&gt;×&lt;/div&gt; &lt;div class=&quot; file-drop-zone&quot;&gt;&lt;div class=&quot;file-drop-zone-title&quot;&gt;拖拽文件/或者点击下方选择图片按钮 …&lt;/div&gt; &lt;div class=&quot;file-preview-thumbnails&quot;&gt;&lt;/div&gt; &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt; &lt;div class=&quot;file-preview-status text-center text-success&quot;&gt;&lt;/div&gt; &lt;div class=&quot;kv-fileinput-error file-error-message&quot; style=&quot;display: none;&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;div class=&quot;kv-upload-progress hide&quot;&gt;&lt;div class=&quot;progress&quot;&gt; &lt;div class=&quot;progress-bar progress-bar-success&quot; role=&quot;progressbar&quot; aria-valuenow=&quot;100&quot; aria-valuemin=&quot;0&quot; aria-valuemax=&quot;100&quot; style=&quot;width:100%;&quot;&gt; 100% &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div tabindex=&quot;500&quot; class=&quot;btn btn-primary btn-file&quot;&gt;&lt;i class=&quot;icon icon-file-o&quot;&gt;&lt;/i&gt; &lt;span class=&quot;undefined&quot;&gt;选择图片文件&lt;/span&gt;&lt;input id=&quot;imgUpload&quot; name=&quot;file&quot; type=&quot;file&quot; class=&quot;&quot; accept=&quot;image/jpeg,image/png&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;kvFileinputModal&quot; class=&quot;file-zoom-dialog modal fade&quot; tabindex=&quot;-1&quot; aria-labelledby=&quot;kvFileinputModalLabel&quot;&gt;&lt;div class=&quot;modal-dialog modal-lg&quot; role=&quot;document&quot; style=&quot;margin-top: 5%;&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;div class=&quot;kv-zoom-actions pull-right&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-default btn-header-toggle btn-toggleheader&quot; title=&quot;Toggle header&quot; data-toggle=&quot;button&quot; aria-pressed=&quot;false&quot; autocomplete=&quot;off&quot;&gt;&lt;i class=&quot;icon icon-resize&quot;&gt;&lt;/i&gt;&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-default btn-fullscreen&quot; title=&quot;Toggle full screen&quot; data-toggle=&quot;button&quot; aria-pressed=&quot;false&quot; autocomplete=&quot;off&quot;&gt;&lt;i class=&quot;icon icon-fullscreen&quot;&gt;&lt;/i&gt;&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-default btn-borderless&quot; title=&quot;Toggle borderless mode&quot; data-toggle=&quot;button&quot; aria-pressed=&quot;false&quot; autocomplete=&quot;off&quot;&gt;&lt;i class=&quot;icon icon-resize-full&quot;&gt;&lt;/i&gt;&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-default btn-close&quot; title=&quot;Close detailed preview&quot; data-dismiss=&quot;modal&quot; aria-hidden=&quot;true&quot;&gt;&lt;i class=&quot;icon icon-remove&quot;&gt;&lt;/i&gt;&lt;/button&gt;&lt;/div&gt; &lt;h3 class=&quot;modal-title&quot;&gt;详细预览 &lt;small&gt;&lt;span class=&quot;kv-zoom-title&quot;&gt;&lt;/span&gt;&lt;/small&gt;&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot;&gt; &lt;div class=&quot;floating-buttons&quot;&gt;&lt;/div&gt; &lt;div class=&quot;kv-zoom-body file-zoom-content&quot;&gt;&lt;/div&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-navigate btn-prev&quot; title=&quot;View previous file&quot;&gt;&lt;i class=&quot;icon icon-long-arrow-left&quot;&gt;&lt;/i&gt;&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-navigate btn-next&quot; title=&quot;View next file&quot;&gt;&lt;i class=&quot;icon icon-long-arrow-right&quot;&gt;&lt;/i&gt;&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; &lt;p id=&quot;mediaTyPrompt&quot;&gt;上传文件格式：图片：png、jpg格式。&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 各个需要选择资源的入口1234&lt;div class=&quot;col-md-4&quot;&gt; &lt;a data-modalid=&quot;#media_icon&quot; data-mediatype=&quot;1&quot; data-imgtype=&quot;custom&quot; href=&quot;javascript:void(0);&quot; class=&quot;icon_media&quot;&gt;个人媒体库音乐&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a data-modalid=&quot;#media_icon&quot; data-mediatype=&quot;1&quot; data-imgtype=&quot;system&quot; data-subtype=&quot;def_msc&quot; href=&quot;javascript:void(0);&quot; class=&quot;icon_media&quot;&gt;系统音乐&lt;/a&gt;&lt;/div&gt; 1&lt;div class=&quot;col-md-2&quot; style=&quot;width:150px;&quot;&gt;&lt;a data-modalid=&quot;#media_icon&quot; data-imgtype=&quot;custom&quot; href=&quot;javascript:void(0);&quot; class=&quot;icon_media&quot;&gt;从媒体库选择图片&lt;/a&gt;&lt;/div&gt; 绑定各入口的点击事件123456789101112131415161718192021222324252627282930313233343536$(document).on(&quot;click&quot;, &quot;[data-modalid]&quot;, function (e) &#123; openMediaResObj = e.target; pauseAudioMusic(); var mediaType = $(openMediaResObj).attr(&quot;data-mediatype&quot;); var imgType = $(openMediaResObj).attr(&quot;data-imgtype&quot;); $(&quot;#pic&quot;).html(&quot;&quot;); $(&quot;#music&quot;).html(&quot;&quot;); //查询图片媒体资源 var sb = _U.getSubmit(&quot;/member/mediares&quot;, null, &quot;ajax&quot;, false); sb.pushData(&quot;act&quot;, &apos;list&apos;); sb.pushData(&quot;type&quot;, imgType); if(imgType == &apos;system&apos;)&#123; sb.pushData(&quot;media_type&quot;, $(openMediaResObj).data(&apos;subtype&apos;)); &#125;else&#123; sb.pushData(&quot;media_type&quot;, mediaType ? mediaType : &apos;0&apos;); &#125; sb.submit(function () &#123; &#125;, function (data) &#123; if (mediaType == &apos;1&apos;) &#123; toggleMediaTab(&apos;music&apos;); addMusicMediaRes(data); &#125; else &#123; toggleMediaTab(&apos;image&apos;); if (imgType == &apos;system&apos;) &#123; addDefMediaRes(data); $(&quot;#upload_tab&quot;).hide(); &#125; else if (imgType == &apos;custom&apos;) &#123; addImageMediaRes(data); $(&quot;#upload_tab&quot;).show(); &#125; &#125; &#125;); $(&quot;#searchMediaInput&quot;).val(&quot;&quot;); $($(this).attr(&apos;data-modalid&apos;)).modal(&apos;show&apos;);&#125;); (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://austinxishou.github.io/tags/JavaScript/"}]},{"title":"krpano编辑器模块核心设计","date":"2017-11-13T01:10:12.687Z","path":"2017/11/13/krpano/krpano-editor-design/","text":"## /static/js/kr/uhweb.js /static/js/kr/main_edit.js /tour/tour.js ## 全景设置 预览previewPano 123function previewPano() &#123; window.open(&quot;/tour/&quot;+works_view_uuid);&#125; 场景编辑-main_edit初始化场景数据通过ajax获取数据1234567891011121314function init() &#123; // var id = $(&quot;#modelatlasid&quot;).val(); var sb = _U.getSubmit(&quot;/edit/pic&quot;, null, &quot;ajax&quot;, false); // var name = $(&quot;#modelatlasname&quot;).val(); sb.pushData(&quot;pid&quot;, pk_works_main); sb.pushData(&quot;act&quot;,&quot;update_init&quot;); sb.submit(function () &#123; &#125;, function (data) &#123; initSceneGroupContainerHeight();//设置场景前端容器高度 initPage(data);// &#125;);&#125; 页面数据初始化-initPage主要实现在 initPage(data) 函数中 读取工程设置,并对应显示在页面中 123456789101112131415161718worksmain = data.worksmain;panoConfig = data.panoConfig;works_view_uuid = worksmain.view_uuid;$(&quot;#worksnameshow&quot;).text($.trim(worksmain.name));$(&quot;#worksname&quot;).val($.trim(worksmain.name));$(&quot;#workcomment&quot;).val(worksmain.profile);$(&quot;#user_viewNum&quot;).text(worksmain.browsing_num);$(&quot;#thumbpath&quot;).attr(&quot;src&quot;, worksmain.thumb_path+&quot;?imageView2/1/w/250/h/250&quot;);$(&quot;#thumbpath&quot;).error(function()&#123; $(this).attr(&quot;src&quot;,&quot;/static/images/kr/default2-120x120.png&quot;);&#125;);$(&quot;#flag_publish&quot;).bootstrapSwitch(&apos;state&apos;, worksmain.flag_publish == &apos;1&apos; ? true : false);var atlasmain = data.atlasmain;$(&quot;#atlasname&quot;).text(atlasmain.name);//是否允许显示到首页$(&quot;#flag_allowed_recomm&quot;).bootstrapSwitch(&apos;state&apos;, worksmain.flag_allowed_recomm==&apos;1&apos;?true:false); 初始化标签框 123456789101112131415var tag_list = data.tag_list;var tags = data.tags;var pic_chosen_html = &quot;&quot;;for(var i =0 ; i&lt;tag_list.length;i++)&#123; var flag = false; for(var j=0 ;j&lt;tags.length;j++)&#123; if (tags[j].tag_id==tag_list[i].id) &#123; flag = true; break; &#125; &#125; pic_chosen_html +=&apos;&lt;option value=&quot;&apos;+tag_list[i].id+&apos;&quot; &apos;+(flag?&quot;selected=\\&quot;selected\\&quot;&quot;:&quot;&quot;)+&apos;&gt;&apos;+tag_list[i].name+&apos;&lt;/option&gt;&apos;;&#125;$(&quot;#pic_chosen&quot;).html(pic_chosen_html);$(&quot;#pic_chosen&quot;).trigger(&apos;chosen:updated&apos;); 加载工程场景列表 1234567891011121314151617181920212223var imgsmain = data.imgsmain;imgsmain.forEach(function (row, num) &#123; var location = row.location; var picname = row.filename; var html = &apos;&lt;div class=&quot;col-md-3&quot; flag=&quot;nostatus&quot; id=&quot;&apos; + row.pk_img_main + &apos;&quot; data-viewuuid=&quot;&apos; + row.view_uuid + &apos;&quot;&gt;&apos; + &apos;&lt;div class=&quot;card&quot;&gt;&apos; + &apos;&lt;div class=&quot;media-wrapper&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;&apos; + row.thumb_path + &apos;&quot;&gt;&lt;/div&gt;&apos; + &apos;&lt;div class=&quot;card-heading&quot;&gt;&apos; + &apos;&lt;span class=&quot;pull-right&quot;&gt;&lt;a href=&quot;javascript:void(0);&quot; onclick=&quot;deletepic(this);&quot;&gt;&lt;i class=&quot;icon-remove-circle&quot;&gt;&lt;/i&gt;&apos; + &apos;删除&apos; + &apos;&lt;/a&gt;&lt;/span&gt;&apos; + &apos;&lt;span class=&quot;card-scene-name&quot;&gt;&apos; + picname + &apos;&lt;/span&gt;&apos; + &apos;&lt;/div&gt;&apos; + &apos;&lt;/div&gt;&apos; + &apos;&lt;/div&gt;&apos;; $(&quot;#pics&quot;).append(html); // if(row.lng &amp;&amp; row.lat)&#123; // $(&quot;#pics &gt; div:last&quot;).data(&apos;locationdata&apos;,&#123;lng:row.lng,lat:row.lat&#125;); // &#125;&#125;); 初始化工程配置initPanoConfig(data.panoConfig); 123456789101112function initPanoConfig(panoConfig) &#123; $(&quot;#gyro&quot;).bootstrapSwitch(&apos;state&apos;, panoConfig.gyro==&apos;1&apos;?true:false); $(&quot;#littleplanet&quot;).bootstrapSwitch(&apos;state&apos;, panoConfig.littleplanet==&apos;1&apos;?true:false); $(&quot;#scenechoose&quot;).bootstrapSwitch(&apos;state&apos;, panoConfig.scenechoose==&apos;1&apos;?true:false); $(&quot;#autorotate&quot;).bootstrapSwitch(&apos;state&apos;, panoConfig.autorotate==&apos;1&apos;?true:false); initAngleOfView(panoConfig.angle_of_view); initSpecialEffect(panoConfig.special_effects); initHotSpot(panoConfig.hotspot); initSandTable(panoConfig.sand_table); initTourGuide(panoConfig.tour_guide); initSceneGroup(panoConfig.scene_group);&#125; initWorkUseAndShare(); initSelect(data); 可视化编辑主要实现在openPanoSetting函数中 12345678910111213141516171819function openPanoSetting() &#123; var settings = &#123;&#125;; settings[&quot;onstart&quot;] = &apos;js(initPanoSetting());&apos;; embedpano(&#123; id: &quot;panoSettingObject&quot;, swf: &quot;/tour/tour.swf&quot;, xml: &quot;/tour/tour.xml.php?view=&quot;+works_view_uuid , target: &quot;settingPano&quot;, html5:&apos;auto&apos;, // flash:&apos;only&apos;, wmode:&apos;opaque-flash&apos;, mobilescale:0.7, vars:settings, webglsettings:&#123;preserveDrawingBuffer:true&#125; &#125;); initPanoSettingSceneChoose(); $(&quot;#panoSettingModal&quot;).modal(&apos;show&apos;);&#125; initHotSpotDataToPage krpano-js模块功能vrshow.jsinitPano /static/js/kr/(function(){ var bp = document.createElement(‘script’); var curProtocol = window.location.protocol.split(‘:’)[0]; if (curProtocol === ‘https’) { bp.src = ‘https://zz.bdstatic.com/linksubmit/push.js‘; } else { bp.src = ‘http://push.zhanzhang.baidu.com/push.js‘; } var s = document.getElementsByTagName(“script”)[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == &quot;http:&quot;) ? &quot;http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;:&quot;https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;; document.write(&apos;&lt;script src=&quot;&apos; + sozzsrc + &apos;&quot; id=&quot;sozz&quot;&gt;&lt;\\/script&gt;&apos;); })();","tags":[{"name":"krpano","slug":"krpano","permalink":"https://austinxishou.github.io/tags/krpano/"}]},{"title":"createjs详解-preloadJS的使用","date":"2017-11-07T08:05:26.130Z","path":"2017/11/07/webdesign/JavaScript-module-createjs/","text":"About-简介createJs框架ajexoop博客Creatine-基于create.js的游戏引擎Creatine-地图编辑器 createJs分成easelJs（图形动画）、preloadJs（文件加载）、soundJs（音频控制）以及tweenJs（补间动画）四部分 preloadJS的使用定义依赖模块123456require.config(&#123; paths: &#123; jquery: &apos;lib/jquery-3.1.0.min&apos;, PreloadJS: &apos;lib/preloadjs-0.6.2.min&apos;, &#125;&#125;); 定义manifest 1234567Global.manifest = [ &#123;src:&quot;image/man.png&quot; , id:&quot;man&quot;&#125;, &#123;src:&quot;image/ground.png&quot; , id:&quot;ground&quot;&#125;, &#123;src:&quot;image/bg.png&quot; , id:&quot;bg&quot;&#125;, &#123;src:&quot;image/high.jpg&quot; , id:&quot;high&quot;&#125;, &#123;src:&quot;image/coins.png&quot; , id:&quot;coin&quot;&#125;]; src表示资源的路径，id在后面用来取加载好的资源。 加载资源 123456789// 加载资源var loader = new createjs.LoadQueue(false); loader.setMaxConnections(100); loader.maintainScriptOrder = true;loader.addEventListener(&apos;progress&apos;, function (e) &#123; console.log(Math.floor(e.progress * 100) + &apos;%&apos;);&#125;); loader.addEventListener(&apos;complete&apos;, function () &#123;&#125;);//当图片素材load完后执行该方法 loader.loadManifest(Global.manifest); 实例参照网络上的酷跑demo 初始化舞台12345678910111213141516function init()&#123; stage = new createjs.Stage(&quot;cas&quot;); C_W = stage.canvas.width; C_H = stage.canvas.height; var manifest = [ &#123;src:&quot;image/man.png&quot; , id:&quot;man&quot;&#125;, &#123;src:&quot;image/ground.png&quot; , id:&quot;ground&quot;&#125;, &#123;src:&quot;image/bg.png&quot; , id:&quot;bg&quot;&#125;, &#123;src:&quot;image/high.jpg&quot; , id:&quot;high&quot;&#125;, &#123;src:&quot;image/coins.png&quot; , id:&quot;coin&quot;&#125; ] loader = new createjs.LoadQueue(false); loader.addEventListener(&quot;complete&quot; , handleComplete); loader.loadManifest(manifest); drawLoading();&#125; (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://austinxishou.github.io/tags/JavaScript/"}]},{"title":"AMD模块详解——Javascript模块化编程(三)","date":"2017-11-07T03:47:12.535Z","path":"2017/11/07/webdesign/JavaScript-module-3-amd/","text":"js模块开发的任务首先需要了解 Node Package Manager (NPM): 阅读 Getting Started guide Modern JavaScript with ES2015/16: 阅读 Babel 的 Learn ES2015 guide webpack-simple 这个在 Egghead.io上的 高级 Webpack 课程 vue-loader About-简介 前端开发在近一两年发展的非常快，JavaScript作为主流的开发语言得到了前所未有的热捧。大量的前端框架出现了，这些框架都在尝试着解决一些前端开发中的共性问题，但是实现又不尽相同。在这个背景下，CommonJS社区诞生了，为了让前端框架发展的更加成熟，CommonJS鼓励开发人员 一起在社区里为一些完成特定功能的框架制定规范。 AMD（Asynchronous Module Definition） 就是其中的一个规范。 传统JavaScript代码的问题 让我们来看看一般情况下JavaScript代码是如何开发的：通过&lt;script&gt;标签来载入JavaScript文件，用全局变量 来区分不同的功能代码，全局变量之间的依赖关系需要显式的通过指定其加载顺序来解决，发布应用时要通过工具来压缩所有的JavaScript代码到一个文 件。当Web项目变得非常庞大，前端模块非常多的时候，手动管理这些全局变量间的依赖关系就变得很困难，这种做法显得非常的低效。 AMD （Asynchronous Module Definition） 的引入 从名称上看便知它是适合script tag的。也可以说AMD是专门为浏览器中JavaScript环境设计的规范。它吸取了CommonJS的一些优点，但又不照搬它的格式。 开始AMD作为CommonJS的 transport format 存在，因无法与CommonJS开发者达成一致而独立出来。它有自己的 wiki 和 讨论组 。 AMD提出了一种基于模块的异步加载JavaScript代码的机制，它推荐开发人员将JavaScript代码封装进一个个模块，对全局对象的依 赖变成了对其他模块的依赖，无须再声明一大堆的全局变量。通过延迟和按需加载来解决各个模块的依赖关系。模块化的JavaScript代码好处很明显，各 个功能组件的松耦合性可以极大的提升代码的复用性、可维护性。这种非阻塞式的并发式快速加载JavaScript代码，使Web页面上其他不依赖 JavaScript代码的UI元素，如图片、CSS以及其他DOM节点得以先加载完毕，Web页面加载速度更快，用户也得到更好的体验。 CommonJS的AMD规范中只定义了一个全局的方法: 1define(id?, dependencies?, factory); 该方法用来定义一个JavaScript模块，开发人员可以用这个方法来将部分功能模块封装在这个define方法体内。 id表示该模块的标识，为可选参数。 dependencies是一个字符串Array，表示该模块依赖的其他所有模块标识，模块依赖必须在真正执行具体的factory方法前解决，这些依赖对象加载执行以后的返回值，可以以默认的顺序作为factory方法的参数。dependencies也是可选参数，当用户不提供该参数时，实现 AMD的框架应提供默认值为[“require”，”exports”，“module”]。 factory是一个用于执行改模块的方法，它可以使用前面dependencies里声明的其他依赖模块的返回值作为参数，若该方法有返回值，当该模块被其他模块依赖时，返回值就是该模块的输出。 CommonJS在规范中并没有详细规定其他的方法，一些主要的AMD框架如RequireJS、curl、bdload等都实现了define方法，同时各个框架都有自己的补充使得其API更实用。 AMD模块的写法1define(id?, dependencies?, factory); 其中: id: 模块标识，可以省略。 dependencies: 所依赖的模块，可以省略。 factory: 模块的实现，或者一个JavaScript对象。 id遵循CommonJS Module Identifiers 。dependencies元素的顺序和factory参数一一对应。 以下是使用AMD模式开发的简单三层结构（基础库/UI层/应用层）： 定义无依赖的模块 （base.js） 123456define(function() &#123; return &#123; mix: function(source, target) &#123; &#125; &#125;;&#125;); 定义有依赖的模块 （ui.js，page.js） ui.js1234567define([&apos;base&apos;], function(base) &#123; return &#123; show: function() &#123; // todo with module base &#125; &#125;&#125;); page.js123define([&apos;data&apos;, &apos;ui&apos;], function(data, ui) &#123; // init here&#125;); 定义数据对象模块 （data.js） 1234define(&#123; users: [], members: []&#125;); 具名模块 123define(&apos;index&apos;, [&apos;data&apos;,&apos;base&apos;], function(data, base) &#123; // todo&#125;); 具名模块多数时候是不推荐的，一般由打包工具合并多个模块到一个js文件中时使用。 包装模块 123456define(function(require, exports, module) &#123; var base = require(&apos;base&apos;); exports.show = function() &#123; // todo with module base &#125;&#125;); 不考虑多了一层函数外，格式和Node.js是一样的。使用require获取依赖模块，使用exports导出API。除了define外，AMD还保留一个关键字require。 require 作为规范保留的全局标识符，可以实现为 module loader。也可以不实现。 目前，实现AMD的库有 RequireJS 、 curl 、 Dojo 、 bdLoad 、 JSLocalnet 、 Nodules 等。 也有很多库支持AMD规范，即将自己作为一个模块存在，如 MooTools 、jQuery 、 qwery 、 bonzo 甚至还有 firebug 。 (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://austinxishou.github.io/tags/JavaScript/"}]},{"title":"require.js详解——Javascript模块化编程(四)","date":"2017-11-07T03:29:43.323Z","path":"2017/11/07/webdesign/JavaScript-module-4-programe/","text":"About-简介 require.js是用于解决js文件的异步加载，避免网页失去响应，另外管理模块之间的依赖性，便于代码的编写和维护。 GetStarted-第一步 使用require.js的第一步，是先去官方网站下载最新版本。 下载后，假定把它放在js子目录下面，就可以加载了。1&lt;script src=&quot;js/require.js&quot;&gt;&lt;/script&gt; 显而易见，加载这个文件，也可能造成网页失去响应。解决办法有两个，一个是把它放在网页底部加载，另一个是写成下面这样： 123&lt;script src=&quot;js/require.js&quot; defer async=&quot;true&quot; &gt;&lt;/script&gt;//async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。 加载require.js以后，下一步就要加载我们自己的代码了。假定我们自己的代码文件是main.js，也放在js目录下面。那么，只需要写成下面这样就行了： 1&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt; data-main属性的作用是，指定网页程序的主模块。在上例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。 main.js-主模块实现上述加载的main.js，称为用户主模块，它有点像C语言的main()函数，所有代码都从这儿开始运行。下面就来看，怎么写main.js。 主模块依赖于其他模块，这时就要使用AMD规范定义的的require()函数。 1234// main.js require([&apos;moduleA&apos;, &apos;moduleB&apos;, &apos;moduleC&apos;], function (moduleA, moduleB, moduleC)&#123; // some code here &#125;); require()函数接受两个参数。 第一个参数是一个数组，表示所依赖的模块，上例就是[‘moduleA’, ‘moduleB’, ‘moduleC’]，即主模块依赖这三个模块； 第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。 require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。 下面，我们看一个实际的例子。假定主模块依赖jquery、underscore和backbone这三个模块，main.js就可以这样写： 123 require([&apos;jquery&apos;, &apos;underscore&apos;, &apos;backbone&apos;], function ($, _, Backbone)&#123; // some code here &#125;); require.js会先加载jQuery、underscore和backbone，然后再运行回调函数。主模块的代码就写在回调函数中。 require.config-模块加载上一节最后的示例中，主模块的依赖模块是[‘jquery’, ‘underscore’, ‘backbone’]。默认情况下，require.js假定这三个模块与main.js在同一个目录，文件名分别为jquery.js，underscore.js和backbone.js，然后自动加载。使用require.config()方法，我们可以对模块的加载行为进行自定义。require.config()就写在主模块（main.js）的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。 123456789require.config(&#123; paths: &#123; jquery: &apos;lib/jquery-3.1.0.min&apos;, PreloadJS: &apos;lib/preloadjs-0.6.2.min&apos;, jweixin: &apos;http://res.wx.qq.com/open/js/jweixin-1.0.0&apos;, jstween: &apos;lib/jstween.min&apos;, jstimeline: &apos;lib/jstimeline.min&apos; &#125;&#125;); 上面的代码给出了三个模块的文件名，路径默认与main.js在同一个目录（js子目录）。如果这些模块在其他目录，比如js/lib目录，则有两种写法。一种是逐一指定路径。 也可以通过直接改变基目录(baseUrl) 12345678 require.config(&#123; baseUrl: &quot;js/lib&quot;, paths: &#123; &quot;jquery&quot;: &quot;jquery.min&quot;, &quot;underscore&quot;: &quot;underscore.min&quot;, &quot;backbone&quot;: &quot;backbone.min&quot; &#125; &#125;); require.js要求，每个模块是一个单独的js文件。这样的话，如果加载多个模块，就会发出多次HTTP请求，会影响网页的加载速度。因此，require.js提供了一个优化工具，当模块部署完毕以后，可以用这个工具将多个模块合并在一个文件中，减少HTTP请求数。 (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://austinxishou.github.io/tags/JavaScript/"}]},{"title":"Krpano-skin 皮肤详解及配置说明","date":"2017-11-06T06:16:00.934Z","path":"2017/11/06/krpano/krpano-skin-develop/","text":"简单例子 自动旋转播放 12345&lt;plugin name\"autorotatebutton\" url=\"autorotatebuttonimage.png\" align=\"bottom\" x=\"0\" y=\"10\" onclick=\"switch(autorotate.enabled);\" /&gt; 全屏切换12345&lt;plugin name\"fullscreenbutton\" url=\"fullscreenbuttonimage.png\" align=\"bottomright\" x=\"10\" y=\"10\" onclick=\"switch(fullscreen);\" /&gt; 帮助图文菜单123456789101112&lt;plugin name\"helpimage\" url=\"help.png\" align=\"center\" visible=\"false\" onclick=\"set(visible,false);\" /&gt;&lt;plugin name\"helpbutton\" url=\"helpbuttonimage.png\" align=\"leftbottom\" x=\"10\" y=\"10\" onclick=\"switch(plugin[helpimage].visible);\" /&gt; XML配置详解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253&lt;krpano&gt; &lt;!-- krpano 1.19.pr13 - Virtual Tour Skin --&gt; &lt;!-- 皮肤具体参数含义注释 --&gt; &lt;!-- maps=\"false\" 是否使用必应地图或谷歌地图 maps_type=\"bing\" 选择使用谷歌地图或必应地图 maps_bing_api_key=\"\" 必应地图所需的API密钥，需申请 maps_google_api_key=\"\" 谷歌地图所需的API密钥，需申请 maps_zoombuttons=\"false\" 是否在地图上显示缩放按钮 gyro=\"true\" 是否使用陀螺仪 webvr=\"true\" 是否启用VR webvr_gyro_keeplookingdirection=\"false\" 进入陀螺仪或VR时是否保持观看方向 webvr_prev_next_hotspots=\"true\" 在VR下是否启用导航到前后场景的链接热点 littleplanetintro=\"false\" 是否使用小行星开场 title=\"true\" 是否左下角显示title thumbs=\"true\" 是否使用缩略图，如不使用，则没有缩略图一栏 thumbs_width=\"120\" thumbs_height=\"80\" thumbs_padding=\"10\" thumbs_crop=\"0|40|240|160\" 缩略图宽度、高度、间距以及缩略图裁切范围 thumbs_opened=\"false\" 是否在启动时弹出缩略图一栏 thumbs_text=\"false\" 是否在缩略图上显示名字 thumbs_dragging=\"true\" 是否允许鼠标拖拽缩略图区域 thumbs_onhoverscrolling=\"false\" 是否允许鼠标悬停缩略图自动滚动 thumbs_scrollbuttons=\"false\" 是否显示缩略图滚动按钮 thumbs_scrollindicator=\"false\" 是否显示缩略图滚动条 thumbs_loop=\"false\" 滚动按钮是否使用缩略图循环 tooltips_buttons=\"false\" 鼠标在按钮悬停时是否弹出文字提示 tooltips_thumbs=\"false\" 鼠标在缩略图悬停时是否弹出文字提示 tooltips_hotspots=\"false\" 鼠标在热点上悬停时是否弹出文字提示 tooltips_mapspots=\"false\" 鼠标在地图热点悬停时是否弹出文字提示 deeplinking=\"false\" 是否使用深度链接获取功能，可使得当前页面路径获取场景及视角信息 loadscene_flags=\"MERGE\" 缩略图切换场景时的变量 loadscene_blend=\"OPENBLEND(0.5, 0.0, 0.75, 0.05, linear)\" 缩略图切换场景时的融合 loadscene_blend_prev=\"SLIDEBLEND(0.5, 180, 0.75, linear)\" 缩略图切换到上一个场景时的融合 loadscene_blend_next=\"SLIDEBLEND(0.5, 0, 0.75, linear)\" 缩略图切换到下一个场景时的融合 loadingtext=\"载入中...\" 在全景图载入中时显示的文字 layout_width=\"100%\" 导航条容器相对屏幕宽度的百分比 layout_maxwidth=\"814\" 导航条容器的最大宽度像素 controlbar_width=\"-24\" 导航条背景的宽度像素 controlbar_height=\"40\" 导航条背景的高度像素 controlbar_offset.normal=\"20\" 导航条背景与屏幕底部的距离 controlbar_offset_closed=\"-40\" 导航条隐藏状态时与屏幕底部的距离 controlbar_overlap.no-fractionalscaling=\"10\" 在不支持分级缩放页面和设置像素比的设备的导航条重叠的像素 controlbar_overlap.fractionalscaling=\"0\" 支持分级缩放页面和设置像素比的设备的导航条重叠的像素 design_skin_images=\"vtourskin.png\" 皮肤所用的源图片 design_bgcolor=\"0x000000\" 皮肤的背景颜色 design_bgalpha=\"0.5\" 皮肤的透明度 design_bgborder=\"0 0xFFFFFF 1.0\" 皮肤的边框 design_bgroundedge=\"1\" 皮肤边框圆角设置 design_bgshadow=\"0 0 9 0xFFFFFF 0.5\" 皮肤的背景阴影 design_thumbborder_bgborder=\"4 0xFFFFFF 1.0\" 皮肤的缩略图边框 design_thumbborder_padding=\"2\" 皮肤缩略图边框间距 design_thumbborder_bgroundedge=\"5\" 皮肤缩略图边框的圆角 design_text_css=\"color:#FFFFFF; font-family:Arial; font-weight:bold;\"皮肤文字样式 design_text_shadow=\"1\" 皮肤的文字阴影 --&gt; &lt;!-- save the url path of this xml file (the url value will be adjusted during xml parsing) --&gt; &lt;vtourskinxmlpath url=\"./\" /&gt; &lt;!-- mouse / touch / keyboard(button) control settings - http://krpano.com/docu/xml/#control --&gt; &lt;!-- 鼠标触屏键盘控制的设定 --&gt; &lt;control mouse=\"drag\" touch=\"drag\" zoomtocursor=\"false\" zoomoutcursor=\"false\" draginertia=\"0.1\" dragfriction=\"0.9\" movetoaccelerate=\"1.0\" movetospeed=\"10.0\" movetofriction=\"0.8\" keybaccelerate=\"0.09\" keybfriction=\"0.94\" keybfovchange=\"0.25\" mousefovchange=\"1.0\" fovspeed=\"3.0\" fovfriction=\"0.9\" bouncinglimits=\"true\" /&gt; &lt;!-- mouse cursors - http://krpano.com/docu/xml/#cursors --&gt; &lt;!-- 鼠标光标设定可自定义光标的样式 --&gt; &lt;cursors standard=\"default\" dragging=\"move\" moving=\"move\" /&gt; &lt;!-- ensure stagescale 2x for mobile devices (regardless if mobilescale is 0.5 or 1.0) --&gt; &lt;krpano stagescale=\"calc:stagescale * 2\" if=\"stagescale LT 1.0\" devices=\"mobile\" /&gt; &lt;!-- include VR support - http://krpano.com/plugins/webvr/ --&gt; &lt;!-- WebVR插件 --&gt; &lt;include url=\"%SWFPATH%/plugins/webvr.xml\" devices=\"html5\" /&gt; &lt;!-- overwrite some settings from the webvr.xml for the skin integration --&gt; &lt;!-- 覆盖WebVR默认设定 --&gt; &lt;!-- onavailable去除插件自定义的进入VR按钮（因为皮肤中已包含）webvr_enterbutton skin_arrange_buttons初始化皮肤按钮 webvr_onavailable()初始化设定，显示Enter VR 按钮--&gt; &lt;!-- onentervr skin_showloading去除加载文字 webvr_setup 设置场景切换热点并跟随 webvr_onentervr 将所有没有添加vr=\"true\"的layer隐藏，并显示VR的Layer skin_reloadscene_webvr 显示屏幕旋转提示图片--&gt; &lt;plugin name=\"WebVR\" keep=\"true\" devices=\"html5\" pluginurl=\"%SWFPATH%/plugins/webvr.js\" url=\"\" multireslock.desktop=\"true\" multireslock.mobile.or.tablet=\"false\" mobilevr_support=\"true\" mobilevr_fake_support=\"true\" onavailable=\"removelayer(webvr_enterbutton); skin_arrange_buttons(); webvr_onavailable();\" onentervr=\"skin_showloading(false); webvr_onentervr(); webvr_setup(); skin_reloadscene_webvr();\" onexitvr=\"webvr_onexitvr(); webvr_setup(); skin_reloadscene_webvr();\" /&gt; &lt;!-- webvr button style (adjust to match skin style) --&gt; &lt;!-- 修改WebVR界面的style使其符合当前场景的样式 主要设置背景颜色和文字 --&gt; &lt;style name=\"webvr_button_style\" border=\"false\" roundedge=\"calc:1.0\" backgroundcolor=\"get:skin_settings.design_bgcolor\" backgroundalpha=\"get:skin_settings.design_bgalpha\" shadow=\"0.01\" shadowrange=\"10.0\" shadowangle=\"90.0\" shadowcolor=\"0x30261B\" shadowalpha=\"0.50\" css=\"calc:skin_settings.design_text_css + ' color:#FFFFFF;font-size:' + 20*webvr_setup_scale*webvr_button_scale + 'px;'\"/&gt; &lt;!-- show a 'rotate the device' info when the mobile device is in portrait orientation in VR mode --&gt; &lt;!-- 显示屏幕旋转提示图片 devices=\"mobile\" 只在手机模式下--&gt; &lt;layer name=\"webvr_rotate_to_landscape_request\" keep=\"true\" vr=\"true\" devices=\"mobile\" url=\"rotate_device.png\" scale=\"0.5\" align=\"top\" edge=\"center\" y=\"28%\" autoalpha=\"true\" alpha=\"0.0\" enabled=\"false\" /&gt; &lt;!-- WebVR相关事件触发 webvr_set_startup_view 设置镜头位置 onloadcomplete根据场景数目觉得是否显示VR场景切换热点--&gt; &lt;events name=\"webvr_events\" keep=\"true\" devices=\"html5\" onxmlcomplete=\"webvr_set_startup_view()\" onresize.mobile=\"webvr_act_as_gyro_in_portrait_mode();\" onloadcomplete=\"delayedcall(0.5, if(webvr.isenabled AND scene.count GT 1 AND skin_settings.webvr_prev_next_hotspots, set(hotspot[webvr_prev_scene].visible,true); set(hotspot[webvr_next_scene].visible,true); ); );\" onviewchange=\"\" /&gt; &lt;!-- 根据VR是否打开设置镜头位置 --&gt; &lt;action name=\"webvr_set_startup_view\"&gt; if((webvr.isenabled OR plugin[skin_gyro].enabled) AND skin_settings.webvr_gyro_keeplookingdirection == false, skin_lookat( get(xml.view.hlookat) ); ); &lt;/action&gt; &lt;!-- 进入VR时设定 --&gt; &lt;action name=\"webvr_setup\"&gt; if(webvr.isenabled, &lt;!-- 读取自定义设定 --&gt; copy(loadscene_flags_backup, skin_settings.loadscene_flags); &lt;!-- 设置为 MERGE|KEEPVIEW|KEEPMOVING|NOPREVIEW--&gt; set(skin_settings.loadscene_flags, MERGE|KEEPVIEW|KEEPMOVING|NOPREVIEW); &lt;!-- 打开WebVR时是否竖屏启动陀螺仪 --&gt; webvr_act_as_gyro_in_portrait_mode(true); &lt;!-- 读取设置是否显示VR模式下的上下按钮 并且设置跟随--&gt; if(scene.count GT 1 AND skin_settings.webvr_prev_next_hotspots, set(hotspot[webvr_prev_scene].visible, true); set(hotspot[webvr_next_scene].visible, true); set(events[webvr_events].onviewchange, webvr_menu_following()); ); , if(loadscene_flags_backup !== null, copy(skin_settings.loadscene_flags, loadscene_flags_backup)); tween(layer[webvr_rotate_to_landscape_request].alpha, 0.0, 0.0); set(hotspot[webvr_prev_scene].visible, false); set(hotspot[webvr_next_scene].visible, false); set(events[webvr_events].onviewchange, null); ); &lt;/action&gt; &lt;!-- 打开WebVR时是否竖屏启动陀螺仪 --&gt; &lt;action name=\"webvr_act_as_gyro_in_portrait_mode\"&gt; if(device.mobile AND webvr.isenabled, div(aspect, stagewidth, stageheight); if(aspect != lastaspect OR '%1' == 'true', copy(lastaspect, aspect); if(stagewidth GT stageheight, &lt;!-- landscape orientation - use stereo rendering and a direct/fast gyro sensor mode --&gt; set(display.stereo, true); set(webvr.mobilevr_sensor_mode, 3); webvr.update(); tween(layer[webvr_rotate_to_landscape_request].alpha, 0.0, 0.0); , &lt;!-- portrait orientation - use normal rendering and a smoother/slower gyro sensor mode --&gt; set(display.stereo, false); set(webvr.mobilevr_sensor_mode, 1); webvr.update(); tween(layer[webvr_rotate_to_landscape_request].alpha, 1.0); delayedcall(3.0, tween(layer[webvr_rotate_to_landscape_request].alpha, 0.0, 1.0); ); ); ); , set(lastaspect, 0); ); &lt;/action&gt; &lt;!-- VR scene switching hotspots --&gt; &lt;!-- VR场景切换热点 distorted=\"true\" 热点跟随场景扭曲--&gt; &lt;style name=\"webvr_menu_style\" depth=\"800\" scale=\"0.5\" distorted=\"true\" ath=\"0\" atv=\"45\" alpha=\"0.5\" /&gt; &lt;hotspot name=\"webvr_prev_scene\" keep=\"true\" style=\"skin_base|webvr_menu_style\" crop=\"0|64|64|64\" ox=\"-64\" onover=\"tween(scale,0.6);\" onout=\"tween(scale,0.5);\" vr_timeout=\"750\" onclick=\"skin_nextscene_loop(-1);\" visible=\"false\" devices=\"html5.and.webgl\" /&gt; &lt;hotspot name=\"webvr_next_scene\" keep=\"true\" style=\"skin_base|webvr_menu_style\" crop=\"64|64|64|64\" ox=\"+64\" onover=\"tween(scale,0.6);\" onout=\"tween(scale,0.5);\" vr_timeout=\"750\" onclick=\"skin_nextscene_loop(+1);\" visible=\"false\" devices=\"html5.and.webgl\" /&gt; &lt;!-- floating/following VR hotspots --&gt; &lt;!-- 设置VR模式下跟随镜头的场景切换热点 --&gt; &lt;action name=\"webvr_menu_following\" type=\"Javascript\" devices=\"html5\"&gt;&lt;![CDATA[ var hs1 = krpano.get(\"hotspot[webvr_prev_scene]\"); var hs2 = krpano.get(\"hotspot[webvr_next_scene]\"); //头追没有移动到热点处的时候 if(!hs1.hovering &amp;&amp; !hs2.hovering) &#123; var f = 0.01; // following speed factor var h = krpano.view.hlookat;//获取当前场景的垂直度数（垂直180°） var v = krpano.view.vlookat;//获取当前场景的水平度数（水平360°） var hsh = hs1.ath; var hsv = hs1.atv; //将度数转化为距离设置到热点上 h = (h -(h|0)) + (((h|0) +360180)%360) - 180.0; v = (v -(v|0)) + (((v|0) +360180)%360) - 180.0; hsh = (hsh-(hsh|0)) + (((hsh|0)+360180)%360) - 180.0; var dh = h - hsh; dh += (dh &gt; 180) ? -360 : (dh &lt; -180) ? 360 : 0 hsh += dh*f; var a = Math.abs(v - hsv) / 90.0; a = 1.0 * Math.max(1.0 - 2.0*Math.sqrt(a), 0); v = v + 55.0 - v*1.5; hsv = hsv*(1.0 - f) + v*f; hs1.ath = hs2.ath = hsh; hs1.atv = hs2.atv = hsv; hs1.alpha = hs2.alpha = a; &#125; ]]&gt;&lt;/action&gt; &lt;!-- VR support --&gt; &lt;!-- skin styles --&gt; &lt;!-- skin_base - the base skin image --&gt; &lt;!-- 基础样式，设置皮肤的图标文件路径 --&gt; &lt;style name=\"skin_base\" url=\"calc:vtourskinxmlpath.url + skin_settings.design_skin_images\" /&gt; &lt;!-- skin_glow - button glowing (if additional ondown,onup,onout,over events are needed, this style provides ondown2,onup2,onover2,onout2 events) --&gt; &lt;!-- 样式属性，如果有额外的事件监听使用 ondown2,onup2,onover2,onout2 skin_buttonglow 设置按钮的点击hover效果--&gt; &lt;style name=\"skin_glow\" ondown=\"copy(skin_lockglow,name); skin_buttonglow(get(name)); if(ondown2, ondown2() );\" onover=\"if(skin_lockglow === null, copy(skin_lockglow,name); skin_buttonglow(get(name),0.3) ); if(onover2, onover2() );\" onout=\"if(skin_lockglow === name AND !pressed, skin_buttonglow(null);delete(skin_lockglow); ); if(onout2, onout2() );\" onup=\"if(onup2, onup2()); delayedcall(0, if(hovering AND enabled, skin_buttonglow(get(name),0.3); , skin_buttonglow(null);delete(skin_lockglow); ); );\" /&gt; &lt;!-- skin_thumbtext_style - style/textfield for the (optional, skin_settings.thumbs_text) thumbnails texts --&gt; &lt;!-- 场景缩略图的文字样式 通过skin_settings.thumbs_text设定是否显示缩略图的文字--&gt; &lt;style name=\"skin_thumbtext_style\" url=\"%SWFPATH%/plugins/textfield.swf\" align=\"bottom\" width=\"100%\" autoheight=\"true\" y=\"5\" enabled=\"false\" background=\"false\" border=\"false\" css=\"calc:skin_settings.design_text_css + ' text-align:center; font-size:10px;'\" textshadow=\"get:skin_settings.design_text_shadow\" /&gt; &lt;!-- skin_hotspotstyle - style for the hotspots --&gt; &lt;!-- 当前皮肤热点的按钮样式 如果skin_settings.tooltips_hotspots为true 则将scene的title属性值设置为热点的tips--&gt; &lt;style name=\"skin_hotspotstyle\" url=\"vtourskin_hotspot.png\" scale=\"0.5\" edge=\"top\" distorted=\"true\" tooltip=\"\" linkedscene=\"\" linkedscene_lookat=\"\" onclick=\"skin_hotspotstyle_click();\" onover=\"tween(scale,0.55);\" onout=\"tween(scale,0.5);\" onloaded=\"if(linkedscene AND skin_settings.tooltips_hotspots, copy(tooltip,scene[get(linkedscene)].title); loadstyle(skin_tooltips); );\" /&gt; &lt;!-- 热点点击 读取热点的linkedscene属性设置为跳转的scene如果存在linkedscene_lookat属性则按照\",\"切分字符分别赋值给h,v,fov 点击时隐藏tips 调用skin_loadscene打开场景skin_lookat旋转到指定位置--&gt; &lt;action name=\"skin_hotspotstyle_click\"&gt; if(linkedscene, if(linkedscene_lookat, txtsplit(linkedscene_lookat, ',', hs_lookat_h, hs_lookat_v, hs_lookat_fov); ); set(enabled, false); skin_hidetooltips(); tween(depth|alpha|oy|rx, 4000|0.0|-50|-60, 0.5, default, skin_loadscene(get(linkedscene), get(skin_settings.loadscene_blend)); if(hs_lookat_h !== null, skin_lookat(get(hs_lookat_h), get(hs_lookat_v), get(hs_lookat_fov)); delete(hs_lookat_h, hs_lookat_v, hs_lookat_fov); ); skin_updatescroll(); ); ); &lt;/action&gt; &lt;!-- skin_tooltip - style for the thumb, hotspot and mapspot tooltips --&gt; &lt;!-- tips样式，当前为鼠标移动到layer读取tooltip值设置到mouse.stagex mouse.stagey（为鼠标的topleft位置） 这个位置--&gt; &lt;style name=\"skin_tooltips\" onover.mouse=\"copy(layer[skin_tooltip].html, tooltip); set(layer[skin_tooltip].visible, true); tween(layer[skin_tooltip].alpha, 1.0, 0.1); asyncloop(hovering, copy(layer[skin_tooltip].x,mouse.stagex); copy(layer[skin_tooltip].y,mouse.stagey); );\" onout.mouse=\"tween(layer[skin_tooltip].alpha, 0.0, 0.1, default, set(layer[skin_tooltip].visible,false), copy(layer[skin_tooltip].x,mouse.stagex); copy(layer[skin_tooltip].y,mouse.stagey); );\" /&gt; &lt;!-- the tooltip textfield --&gt; &lt;!-- 文字提示tips layer使用文字插件展示，这里可以修改tips的式样 --&gt; &lt;layer name=\"skin_tooltip\" keep=\"true\" url=\"%SWFPATH%/plugins/textfield.swf\" parent=\"STAGE\" visible=\"false\" alpha=\"0\" enabled=\"false\" zorder=\"2\" align=\"lefttop\" edge=\"bottom\" oy=\"-2\" width=\"200\" autoheight=\"true\" background=\"false\" backgroundcolor=\"0xFFFFFF\" backgroundalpha=\"1.0\" border=\"false\" bordercolor=\"0x000000\" borderalpha=\"1.0\" borderwidth=\"1.0\" roundedge=\"0\" shadow=\"0.0\" shadowrange=\"4.0\" shadowangle=\"45\" shadowcolor=\"0x000000\" shadowalpha=\"1.0\" textshadow=\"get:skin_settings.design_text_shadow\" textshadowrange=\"6.0\" textshadowangle=\"90\" textshadowcolor=\"0x000000\" textshadowalpha=\"1.0\" css=\"calc:skin_settings.design_text_css + ' text-align:center; font-size:16px;'\" html=\"\" /&gt; &lt;!-- skin layout --&gt; &lt;!-- 下方控制条 --&gt; &lt;layer name=\"skin_layer\" keep=\"true\" type=\"container\" align=\"top\" width=\"get:skin_settings.layout_width\" maxwidth=\"get:skin_settings.layout_maxwidth\" height=\"100%\" maskchildren=\"true\" visible=\"false\" bgcapture=\"false\" zorder=\"1\"&gt; &lt;!-- 控制条上部分包括视频控制条，缩略图展示，场景名称等 --&gt; &lt;layer name=\"skin_scroll_window\" type=\"container\" align=\"bottom\" width=\"100%\" height=\"100%\" x=\"0\" y=\"calc:skin_settings.controlbar_offset + skin_settings.controlbar_height - skin_settings.controlbar_overlap\" maskchildren=\"true\" onloaded=\"skin_calc_opened_closed();\" zorder=\"1\"&gt; &lt;layer name=\"skin_scroll_layer\" type=\"container\" align=\"bottom\" width=\"get:skin_settings.controlbar_width\" height=\"100%\" x=\"200\" y=\"200\" y_offset=\"get:skin_settings.controlbar_overlap\" accuracy=\"1\" bgalpha=\"get:skin_settings.design_bgalpha\" bgcolor=\"get:skin_settings.design_bgcolor\" bgborder=\"get:skin_settings.design_bgborder\" bgroundedge=\"get:skin_settings.design_bgroundedge\" bgshadow=\"get:skin_settings.design_bgshadow\"&gt; &lt;!-- 场景名称 --&gt; &lt;layer name=\"skin_title\" url=\"%SWFPATH%/plugins/textfield.swf\" align=\"lefttop\" edge=\"leftbottom\" x=\"4\" y=\"0\" zorder=\"4\" enabled=\"false\" background=\"false\" border=\"false\" css=\"calc:skin_settings.design_text_css + ' text-align:left; font-style:italic; font-size:12px;'\" textshadow=\"get:skin_settings.design_text_shadow\" visible=\"false\" onautosized=\"skin_video_updateseekbarwidth();\" /&gt; &lt;!-- 视频控制条 --&gt; &lt;layer name=\"skin_video_controls\" type=\"container\" align=\"lefttop\" edge=\"leftbottom\" width=\"100%\" height=\"18\" visible=\"false\"&gt; &lt;layer name=\"skin_video_seekbar_container\" type=\"container\" align=\"lefttop\" width=\"100%\" height=\"100%\" bgcapture=\"true\" ondown=\"skin_video_ondownseeking();\" &gt; &lt;layer name=\"skin_video_seekbar\" type=\"container\" bgcolor=\"0xFFFFFF\" bgalpha=\"0.25\" align=\"center\" width=\"100%\" height=\"2\"&gt; &lt;layer name=\"skin_video_loadbar\" type=\"container\" bgcolor=\"0xFFFFFF\" bgalpha=\"0.5\" align=\"left\" width=\"0\" height=\"2\" /&gt; &lt;layer name=\"skin_video_seekpos\" type=\"container\" bgcolor=\"0xFFFFFF\" bgalpha=\"1.0\" align=\"left\" edge=\"center\" x=\"0\" bgroundedge=\"8\" width=\"10\" height=\"10\" /&gt; &lt;/layer&gt; &lt;/layer&gt; &lt;layer name=\"skin_video_time\" url=\"%SWFPATH%/plugins/textfield.swf\" align=\"rightbottom\" x=\"4\" enabled=\"false\" background=\"false\" border=\"false\" css=\"calc:skin_settings.design_text_css + ' text-align:left; font-style:italic; font-size:12px;'\" textshadow=\"get:skin_settings.design_text_shadow\" html=\"0:00 / 0:00\" /&gt; &lt;/layer&gt; &lt;layer name=\"skin_scroll_container\" type=\"container\" align=\"lefttop\" width=\"100%\" height=\"100%\" x=\"0\" y=\"0\" bgroundedge=\"get:skin_settings.design_bgroundedge\" maskchildren=\"true\"&gt; &lt;!-- 缩略图展示 --&gt; &lt;layer name=\"skin_thumbs_container\" type=\"container\" align=\"lefttop\" width=\"100%\" height=\"100%\" visible=\"false\"&gt; &lt;layer name=\"skin_thumbs_scrollleft\" style=\"skin_base|skin_glow\" crop=\"0|64|64|64\" align=\"lefttop\" edge=\"left\" x=\"5\" y=\"50\" scale=\"0.5\" zorder=\"2\" alpha=\"1.0\" ondown2=\"asyncloop(pressed, layer[skin_thumbs].scrollby(+2,0));\" visible=\"false\" /&gt; &lt;layer name=\"skin_thumbs_scrollright\" style=\"skin_base|skin_glow\" crop=\"64|64|64|64\" align=\"righttop\" edge=\"right\" x=\"5\" y=\"50\" scale=\"0.5\" zorder=\"2\" alpha=\"1.0\" ondown2=\"asyncloop(pressed, layer[skin_thumbs].scrollby(-2,0));\" visible=\"false\" /&gt; &lt;layer name=\"skin_thumbs_scrollindicator\" type=\"container\" bgcolor=\"0xFFFFFF\" bgalpha=\"0.25\" align=\"lefttop\" width=\"0\" y=\"100\" height=\"2\" visible=\"false\" enabled=\"false\" /&gt; &lt;!-- 滑动插件 --&gt; &lt;layer name=\"skin_thumbs\" state=\"closed\" url.flash=\"%SWFPATH%/plugins/scrollarea.swf\" url.html5=\"%SWFPATH%/plugins/scrollarea.js\" direction=\"h\" align=\"top\" width=\"100%\" height=\"100\" zorder=\"1\" onloaded=\"skin_updatescroll();\" onscroll=\"skin_updatethumbscroll();\" /&gt; &lt;/layer&gt; &lt;!-- 地图展示 --&gt; &lt;layer name=\"skin_map_container\" type=\"container\" align=\"leftop\" width=\"100%\" height=\"100%\" bgroundedge=\"get:skin_settings.design_bgroundedge\" maskchildren=\"true\"&gt; &lt;layer name=\"skin_map\" state=\"closed\" url=\"\" visible=\"false\" align=\"lefttop\" width=\"100%\" height=\"50%\" x=\"0\" y=\"0\" zorder=\"1\" lat=\"0\" lng=\"0\" zoom=\"10\" bgalpha=\"0\" maptype=\"satellite\" onmapready=\"skin_addmapspots();\"&gt; &lt;maptypecontrol visible=\"true\" align=\"righttop\" x=\"5\" y=\"5\" buttonalign=\"v\" scale.mobile=\"1.5\" /&gt; &lt;radar visible=\"false\" headingoffset=\"0\" /&gt; &lt;spotstyle name=\"DEFAULT\" url=\"vtourskin_mapspot.png\" activeurl=\"vtourskin_mapspotactive.png\" edge=\"bottom\" x=\"-5\" y=\"-8\" scale=\"0.5\" /&gt; &lt;layer name=\"skin_map_zoom_in\" style=\"skin_base\" visible=\"get:skin_settings.maps_zoombuttons\" crop=\"9|512|46|64\" align=\"right\" x=\"0\" y=\"-40\" zorder=\"2\" ondown=\"layer[skin_map].zoomin(); skin_buttonglow(get(name));\" onup=\"skin_buttonglow(null);\" /&gt; &lt;layer name=\"skin_map_zoom_out\" style=\"skin_base\" visible=\"get:skin_settings.maps_zoombuttons\" crop=\"73|512|46|64\" align=\"right\" x=\"0\" y=\"+40\" zorder=\"2\" ondown=\"layer[skin_map].zoomout(); skin_buttonglow(get(name));\" onup=\"skin_buttonglow(null);\" /&gt; &lt;/layer&gt; &lt;/layer&gt; &lt;/layer&gt; &lt;/layer&gt; &lt;/layer&gt; &lt;!-- 底部控制条背景图 --&gt; &lt;layer name=\"skin_splitter_bottom\" type=\"container\" align=\"bottom\" width=\"100%\" height=\"calc:skin_settings.controlbar_offset + skin_settings.controlbar_height - skin_settings.controlbar_overlap\" y=\"0\" maskchildren=\"true\" onloaded=\"skin_calc_opened_closed();\" zorder=\"2\"&gt; &lt;layer name=\"skin_control_bar_bg\" type=\"container\" align=\"bottom\" width=\"get:skin_settings.controlbar_width\" height=\"calc:skin_settings.controlbar_height + skin_settings.controlbar_overlap\" x=\"0\" y=\"get:skin_settings.controlbar_offset\" bgcolor=\"get:skin_settings.design_bgcolor\" bgalpha=\"get:skin_settings.design_bgalpha\" bgborder=\"get:skin_settings.design_bgborder\" bgroundedge=\"get:skin_settings.design_bgroundedge\" bgshadow=\"get:skin_settings.design_bgshadow\" /&gt; &lt;/layer&gt; &lt;!-- 控制按钮区域 --&gt; &lt;layer name=\"skin_control_bar\" type=\"container\" align=\"bottom\" width=\"get:skin_settings.controlbar_width\" height=\"calc:skin_settings.controlbar_height\" x=\"0\" y=\"get:skin_settings.controlbar_offset\" onloaded=\"skin_calc_opened_closed();\" zorder=\"3\"&gt; &lt;!-- 控制按钮 --&gt; &lt;layer name=\"skin_control_bar_buttons\" type=\"container\" align=\"leftbottom\" width=\"100%\" height=\"get:skin_settings.controlbar_height\"&gt; &lt;!-- 前一个场景按钮 --&gt; &lt;layer name=\"skin_btn_prev\" style=\"skin_base|skin_glow\" crop=\"0|64|64|64\" align=\"left\" x=\"5\" y=\"0\" scale=\"0.5\" alpha=\"0.5\" onclick=\"if(skin_settings.thumbs_loop, skin_nextscene_loop(-1), skin_nextscene(-1) );\" /&gt; &lt;!-- 缩略图按钮，点击后调用skin_showthumbs方法动画展示缩略图--&gt; &lt;layer name=\"skin_btn_thumbs\" style=\"skin_base|skin_glow\" crop=\"0|128|64|64\" align=\"left\" x=\"50\" y=\"0\" scale=\"0.5\" ondown2=\"skin_showmap(false); skin_showthumbs();\" /&gt; &lt;!-- 地图按钮，点击后会隐藏缩略图--&gt; &lt;layer name=\"skin_btn_map\" style=\"skin_base|skin_glow\" crop=\"64|128|64|64\" align=\"left\" x=\"90\" y=\"0\" scale=\"0.5\" ondown2=\"skin_showthumbs(false); skin_showmap();\" visible=\"false\" /&gt; &lt;!-- 导航栏包括上下左右移动放大与缩小，鼠标按下距离+或-1，抬起初始化为默认的0 --&gt; &lt;layer name=\"skin_btn_navi\" type=\"container\" align=\"center\" x=\"0\" width=\"240\" height=\"32\"&gt; &lt;layer name=\"skin_btn_left\" style=\"skin_base|skin_glow\" crop=\"0|192|64|64\" align=\"center\" x=\"-100\" y=\"0\" scale=\"0.5\" ondown2=\"set(hlookat_moveforce,-1);\" onup2=\"set(hlookat_moveforce,0);\" /&gt; &lt;layer name=\"skin_btn_right\" style=\"skin_base|skin_glow\" crop=\"64|192|64|64\" align=\"center\" x=\"-60\" y=\"0\" scale=\"0.5\" ondown2=\"set(hlookat_moveforce,+1);\" onup2=\"set(hlookat_moveforce,0);\" /&gt; &lt;layer name=\"skin_btn_up\" style=\"skin_base|skin_glow\" crop=\"0|256|64|64\" align=\"center\" x=\"-20\" y=\"0\" scale=\"0.5\" ondown2=\"set(vlookat_moveforce,-1);\" onup2=\"set(vlookat_moveforce,0);\" /&gt; &lt;layer name=\"skin_btn_down\" style=\"skin_base|skin_glow\" crop=\"64|256|64|64\" align=\"center\" x=\"+20\" y=\"0\" scale=\"0.5\" ondown2=\"set(vlookat_moveforce,+1);\" onup2=\"set(vlookat_moveforce,0);\" /&gt; &lt;layer name=\"skin_btn_in\" style=\"skin_base|skin_glow\" crop=\"0|320|64|64\" align=\"center\" x=\"+60\" y=\"0\" scale=\"0.5\" ondown2=\"set(fov_moveforce,-1);\" onup2=\"set(fov_moveforce,0);\" /&gt; &lt;layer name=\"skin_btn_out\" style=\"skin_base|skin_glow\" crop=\"64|320|64|64\" align=\"center\" x=\"+100\" y=\"0\" scale=\"0.5\" ondown2=\"set(fov_moveforce,+1);\" onup2=\"set(fov_moveforce,0);\" /&gt; &lt;/layer&gt; &lt;!-- 开启或关闭陀螺仪按钮 --&gt; &lt;layer name=\"skin_btn_gyro\" style=\"skin_base|skin_glow\" crop=\"0|384|64|64\" align=\"center\" x=\"+140\" y=\"0\" scale=\"0.5\" onclick=\"switch(plugin[skin_gyro].enabled); if(plugin[skin_gyro].enabled, skin_showmap(false));\" visible=\"false\" devices=\"html5\" /&gt; &lt;!-- 进入VR模式按钮 --&gt; &lt;layer name=\"skin_btn_vr\" style=\"skin_base|skin_glow\" crop=\"0|0|80|64\" align=\"center\" x=\"+146\" y=\"0\" scale=\"0.5\" onclick=\"webvr.enterVR();\" visible=\"false\" /&gt; &lt;!-- 全屏按钮 --&gt; &lt;layer name=\"skin_btn_fs\" style=\"skin_base|skin_glow\" crop=\"0|576|64|64\" align=\"right\" x=\"90\" y=\"0\" scale=\"0.5\" onclick=\"switch(fullscreen);\" devices=\"fullscreensupport\" /&gt; &lt;!-- 隐藏控制条按钮 --&gt; &lt;layer name=\"skin_btn_hide\" style=\"skin_base|skin_glow\" crop=\"0|448|64|64\" align=\"right\" x=\"50\" y=\"0\" scale=\"0.5\" onclick=\"skin_hideskin()\" /&gt; &lt;!-- 显示控制条按钮 --&gt; &lt;layer name=\"skin_btn_show\" type=\"container\" bgcapture=\"true\" align=\"bottom\" width=\"100%\" height=\"get:skin_settings.controlbar_height\" y=\"calc:skin_settings.controlbar_height - skin_settings.controlbar_offset_closed\" onclick=\"skin_showskin()\" onhover=\"tween(alpha,1.0);\" onout=\"tween(alpha,0.25);\" ondown.touch=\"onhover();\" onup.touch=\"onout();\" visible=\"false\" capture=\"false\" alpha=\"0.0\"&gt; &lt;layer name=\"skin_btn_show_icon\" style=\"skin_base\" crop=\"64|448|64|64\" scale=\"0.5\" align=\"bottom\" y=\"2\" enabled=\"false\" /&gt; &lt;/layer&gt; &lt;!-- 下一个场景按钮 --&gt; &lt;layer name=\"skin_btn_next\" style=\"skin_base|skin_glow\" crop=\"64|64|64|64\" align=\"right\" x=\"5\" y=\"0\" scale=\"0.5\" alpha=\"0.5\" onclick=\"if(skin_settings.thumbs_loop, skin_nextscene_loop(+1), skin_nextscene(+1) );\" /&gt; &lt;/layer&gt; &lt;/layer&gt; &lt;!-- 显示加载中文字图层 --&gt; &lt;layer name=\"skin_loadingtext\" url=\"%SWFPATH%/plugins/textfield.swf\" align=\"center\" x=\"5\" y=\"-5\" html=\"get:skin_settings.loadingtext\" visible=\"false\" autoheight=\"true\" background=\"false\" border=\"false\" enabled=\"false\" css=\"calc:skin_settings.design_text_css + ' text-align:center; font-style:italic; font-size:22px;'\" textshadow=\"get:skin_settings.design_text_shadow\" /&gt; &lt;!-- 发光的背景图片，用于按钮点击效果 --&gt; &lt;layer name=\"skin_buttonglow\" style=\"skin_base\" crop=\"64|384|64|64\" align=\"center\" x=\"0\" y=\"1\" scale=\"1.0\" alpha=\"0.0\" visible=\"false\" enabled=\"false\" /&gt; &lt;!-- 缩略图选择边框效果 --&gt; &lt;layer name=\"skin_thumbborder\" type=\"container\" x=\"get:skin_settings.design_thumbborder_padding\" y=\"get:skin_settings.design_thumbborder_padding\" width=\"calc:skin_settings.thumbs_width - 2*skin_settings.design_thumbborder_padding\" height=\"calc:skin_settings.thumbs_height - 2*skin_settings.design_thumbborder_padding\" visible=\"false\" enabled=\"false\" align=\"lefttop\" bgborder=\"get:skin_settings.design_thumbborder_bgborder\" bgroundedge=\"get:skin_settings.design_thumbborder_bgroundedge\" /&gt; &lt;/layer&gt; &lt;!-- previous/next scene buttons for the hidden skin mode --&gt; &lt;!-- 隐藏控制条时显示的用于场景切换的按钮 --&gt; &lt;layer name=\"skin_btn_prev_fs\" keep=\"true\" type=\"container\" align=\"lefttop\" x=\"-50\" width=\"40\" height=\"100%\" bgcapture=\"true\" alpha=\"0.25\" capture=\"false\" zorder=\"2\" onclick=\"skin_nextscene_loop(-1);\" onhover=\"tween(alpha,1.0);\" onout=\"tween(alpha,0.25);\" ondown.touch=\"onhover();\" onup.touch=\"onout();\"&gt; &lt;layer name=\"skin_btn_prev_fs_icon\" style=\"skin_base\" crop=\"0|64|64|64\" align=\"center\" scale=\"0.5\" enabled=\"false\" /&gt; &lt;/layer&gt; &lt;layer name=\"skin_btn_next_fs\" keep=\"true\" type=\"container\" align=\"righttop\" x=\"-50\" width=\"40\" height=\"100%\" bgcapture=\"true\" alpha=\"0.25\" capture=\"false\" zorder=\"2\" onclick=\"skin_nextscene_loop(+1);\" onhover=\"tween(alpha,1.0);\" onout=\"tween(alpha,0.25);\" ondown.touch=\"onhover();\" onup.touch=\"onout();\"&gt; &lt;layer name=\"skin_btn_next_fs_icon\" style=\"skin_base\" crop=\"64|64|64|64\" align=\"center\" scale=\"0.5\" enabled=\"false\" /&gt; &lt;/layer&gt; &lt;!-- gyro plugin --&gt; &lt;!-- 陀螺仪插件 --&gt; &lt;plugin name=\"skin_gyro\" keep=\"true\" url=\"\" html5_url=\"%SWFPATH%/plugins/gyro2.js\" softstart=\"1.0\" enabled=\"false\" onavailable=\"skin_arrange_buttons();\" devices=\"html5\" /&gt; &lt;!-- skin events --&gt; &lt;!-- 皮肤的事件 onxmlcomplete XML加载完成后清除当前事件，调用第一个函数skin_startup onnewpano 加载新场景时skin_showloading显示加载中文字 skin_update_scene_infos 根据URL重新设定初始位置等信息 onloadcomplete 加载完成后隐藏加载中文字 onidle 空闲时执行URL的信息更新 onresize 屏幕尺寸变化时执行一次skin_onresize，当每次加载新的pano时onresize也会被触发一次 onenterfullscreen onexitfullscreen 进入退出全屏时更新全屏按钮的图标 onkeydown 监听键盘事件--&gt; &lt;events name=\"skin_events\" keep=\"true\" onxmlcomplete=\"set(events[skin_events].onxmlcomplete,null); skin_startup();\" onnewpano=\"skin_showloading(true); skin_update_scene_infos(); skin_deeplinking_update_url();\" onremovepano=\"skin_showloading(true);\" onloadcomplete=\"skin_showloading(false);\" onidle=\"skin_deeplinking_update_url();\" onresize=\"skin_onresize();\" onenterfullscreen.fullscreensupport=\"set(layer[skin_btn_fs].crop, '64|576|64|64');\" onexitfullscreen.fullscreensupport=\"set(layer[skin_btn_fs].crop, '0|576|64|64');\" onkeydown=\"skin_keydown_event();\" /&gt; &lt;!-- skin actions --&gt; &lt;!-- 当前皮肤的启动函数 --&gt; &lt;action name=\"skin_startup\"&gt; &lt;!-- apply skin settings on startup --&gt; &lt;!-- 根据设置确定缩略图是否在打开时就显示，并且设定是否可拖拽，鼠标的情况下设置为滚动 --&gt; if(skin_settings.thumbs, if(skin_settings.thumbs_opened, set(layer[skin_thumbs].state,'opened'); set(layer[skin_thumbs_container].visible,true); ); copy(layer[skin_thumbs].draggable, skin_settings.thumbs_dragging); if(skin_settings.thumbs_onhoverscrolling AND device.mouse, set(layer[skin_thumbs].draggable, false); set(layer[skin_thumbs].onhover_autoscrolling, true); ); ); &lt;!-- html5的情况下加载陀螺仪插件 --&gt; if(skin_settings.gyro AND !device.desktop AND device.html5, copy(plugin[skin_gyro].url, plugin[skin_gyro].html5_url); ); &lt;!-- html5并且支持WebVR的情况下加载WebVR插件 --&gt; if(skin_settings.webvr AND device.html5 AND device.webgl, copy(plugin[WebVR].url, plugin[WebVR].pluginurl); ); &lt;!-- 是否显示地图插件 --&gt; if(skin_settings.maps == true, set(layer[skin_btn_map].visible, true); if(device.flash, copy(layer[skin_map].key, skin_settings.maps_bing_api_key); set(layer[skin_map].url, '%SWFPATH%/plugins/bingmaps.swf'); , if(skin_settings.maps_type == 'bing', copy(layer[skin_map].key, skin_settings.maps_bing_api_key); set(layer[skin_map].url, '%SWFPATH%/plugins/bingmaps.js'); , copy(layer[skin_map].key, skin_settings.maps_google_api_key); set(layer[skin_map].url, '%SWFPATH%/plugins/googlemaps.js'); ); ); ); &lt;!-- 小行星入场方式，只有支持WebGL和flash的情况下才可以 --&gt; if(skin_settings.littleplanetintro AND (device.webgl OR device.flash), skin_setup_littleplanetintro(); ); &lt;!-- 增加缩略图 --&gt; skin_addthumbs(); &lt;!-- 调用onresize --&gt; skin_onresize(); &lt;!-- skin_updatescroll --&gt; skin_updatescroll(); &lt;!-- 显示下方控制条 --&gt; set(layer[skin_layer].visible, true); &lt;/action&gt; &lt;!-- 增加缩略图 --&gt; &lt;action name=\"skin_addthumbs\"&gt; if(skin_settings.thumbs == false, set(layer[skin_btn_thumbs].visible,false); , copy(thumbwidth, skin_settings.thumbs_width); copy(thumbheight, skin_settings.thumbs_height); copy(thumbpadding, skin_settings.thumbs_padding); copy(thumbcrop, skin_settings.thumbs_crop); add(thumbxoffset, thumbwidth, thumbpadding); mul(thumbxcenter, thumbxoffset, 0.5); mul(thumbbarwidth, thumbxoffset, scene.count); add(thumbbarwidth, thumbpadding); add(thumbbarheight, thumbpadding, thumbheight); add(thumbbarheight, thumbpadding); if(skin_settings.thumbs_scrollindicator, copy(layer[skin_thumbs_scrollindicator].y, thumbbarheight); add(thumbbarheight, layer[skin_thumbs_scrollindicator].height); ); copy(layer[skin_thumbs].height, thumbbarheight); copy(layer[skin_thumbs].width, thumbbarwidth); mul(halfheight, thumbbarheight, 0.5); copy(layer[skin_thumbs_scrollleft].y, halfheight); copy(layer[skin_thumbs_scrollright].y, halfheight); &lt;!-- 遍历所有scene并且根据序号设置缩略图名称，并且根据设置添加缩略图文字 --&gt; set(thumb_cnt,0); for(set(i,0), i LT scene.count, inc(i), inc(thumb_cnt); txtadd(thumbname,'skin_thumb_',get(i)); addlayer(get(thumbname)); copy(layer[get(thumbname)].url, scene[get(i)].thumburl); set(layer[get(thumbname)].keep, true); set(layer[get(thumbname)].parent, 'skin_thumbs'); set(layer[get(thumbname)].align, lefttop); copy(layer[get(thumbname)].crop, thumbcrop); copy(layer[get(thumbname)].width, thumbwidth); copy(layer[get(thumbname)].height, thumbheight); mul(thumbx, i, thumbxoffset); add(thumbx, thumbpadding); copy(layer[get(thumbname)].x, thumbx); copy(layer[get(thumbname)].y, thumbpadding); add(scene[get(i)].thumbx, thumbx, thumbxcenter); copy(scene[get(i)].thumby, thumbpadding); set(layer[get(thumbname)].linkedscene, get(scene[get(i)].name) ); set(layer[get(thumbname)].onclick, copy(layer[skin_thumbborder].parent, name); skin_loadscene(get(linkedscene),get(skin_settings.loadscene_blend)); ); if(skin_settings.tooltips_thumbs, set(layer[get(thumbname)].tooltip, get(scene[get(i)].title) ); layer[get(thumbname)].loadstyle(skin_tooltips); ); if(skin_settings.thumbs_text, txtadd(thumbtext, 'skin_thumbtext_', get(i)); addlayer(get(thumbtext)); layer[get(thumbtext)].loadstyle(skin_thumbtext_style); set(layer[get(thumbtext)].keep, true); set(layer[get(thumbtext)].parent, get(thumbname)); set(layer[get(thumbtext)].html, get(scene[get(i)].title)); ); ); if(thumb_cnt == 1, set(layer[skin_thumbs].align, 'lefttop'); ); ); &lt;/action&gt; &lt;!-- 设置地图热点 --&gt; &lt;action name=\"skin_addmapspots\"&gt; for(set(i,0), i LT scene.count, inc(i), if(scene[get(i)].lat, txtadd(spotname, 'spot', get(i)); txtadd(spotclickevent, 'skin_hidetooltips(); activatespot(',get(spotname),'); skin_loadscene(', get(scene[get(i)].name), ',get(skin_settings.loadscene_blend)); skin_updatescroll(); delayedcall(0.5,skin_showmap(false));'); copy(scene[get(i)].mapspotname, spotname); addspot(get(spotname), get(scene[get(i)].lat), get(scene[get(i)].lng), get(scene[get(i)].heading), false, get(spotclickevent), null); if(skin_settings.tooltips_mapspots, set(layer[skin_map].spot[get(spotname)].tooltip, get(scene[get(i)].title) ); txtadd(layer[skin_map].spot[get(spotname)].onover, 'set(hovering,true);', get(style[skin_tooltips].onover) ); txtadd(layer[skin_map].spot[get(spotname)].onout, 'set(hovering,false);', get(style[skin_tooltips].onout) ); ); ); ); if(xml.scene != null, activatespot( get(scene[get(xml.scene)].mapspotname) ); , activatespot(spot0); ); &lt;!-- zoom and pan the map to see all spots at the same time --&gt; zoomToSpotsExtent(); &lt;/action&gt; &lt;!-- 小行星入场方式 --&gt; &lt;action name=\"skin_setup_littleplanetintro\"&gt; copy(lp_scene, xml.scene); copy(lp_hlookat, view.hlookat); copy(lp_vlookat, view.vlookat); copy(lp_fov, view.fov); copy(lp_fovmax, view.fovmax); copy(lp_limitview, view.limitview); set(view.fovmax, 170); set(view.limitview, lookto); set(view.vlookatmin, 90); set(view.vlookatmax, 90); lookat(calc(lp_hlookat - 180), 90, 150, 1, 0, 0); set(events[lp_events].onloadcomplete, delayedcall(0.5, if(lp_scene === xml.scene, set(control.usercontrol, off); copy(view.limitview, lp_limitview); set(view.vlookatmin, null); set(view.vlookatmax, null); tween(view.hlookat|view.vlookat|view.fov|view.distortion, calc('' + lp_hlookat + '|' + lp_vlookat + '|' + lp_fov + '|' + 0.0), 3.0, easeOutQuad, set(control.usercontrol, all); tween(view.fovmax, get(lp_fovmax)); ); ); ); ); &lt;/action&gt; &lt;!-- 跳转到指定的视角，VR模式下要同时更新切换热点的位置 --&gt; &lt;action name=\"skin_lookat\"&gt; if(webvr.isenabled, &lt;!-- adjust the VR prev/next hotspots for the view change --&gt; calc(hlookat_offset, %1 - view.hlookat); add(hotspot[webvr_prev_scene].ath, hlookat_offset); add(hotspot[webvr_next_scene].ath, hlookat_offset); ); if(plugin[skin_gyro].enabled, &lt;!-- reset the gyro tracking --&gt; plugin[skin_gyro].resetsensor(%1); ); &lt;!-- change the view --&gt; lookat(%1, %2, %3); &lt;/action&gt; &lt;!-- 皮肤重置位置 --&gt; &lt;action name=\"skin_onresize\"&gt; mul(mh, area.pixelheight, -1); if(layer[skin_thumbs].state == 'opened', add(mh,layer[skin_thumbs].height); ); if(layer[skin_map].state == 'opened', sub(hh,area.pixelheight,skin_settings.controlbar_offset); sub(hh,layer[skin_control_bar].height); sub(hh,32); add(mh,hh); add(mh,skin_settings.controlbar_overlap); sub(mh, layer[skin_scroll_layer].y_offset); copy(layer[skin_map].height, hh); ); add(mh, layer[skin_scroll_layer].y_offset); set(layer[skin_scroll_layer].y, get(mh)); skin_video_updateseekbarwidth(); skin_arrange_buttons(); &lt;/action&gt; &lt;!-- determine the visibility of the buttons and calculate their positions --&gt; &lt;!-- 判断是否显示按钮并且计算他们的位置 --&gt; &lt;action name=\"skin_arrange_buttons\"&gt; &lt;!-- 通过场景树是否大于1确定是否显示场景切换按钮 --&gt; calc(show_selbuttons, scene.count GT 1); calc(show_thumbutton, skin_settings.thumbs == true); calc(show_mapbutton, skin_settings.maps == true); calc(show_gyrobutton, plugin[skin_gyro].available == true AND (view.vlookatrange == 180 OR lp_scene === xml.scene)); calc(show_vrbutton, webvr.isavailable == true); calc(show_fsbutton, device.fullscreensupport == true); set(lpos,6); set(cpos,0); if(show_gyrobutton, dec(cpos,20)); if(show_vrbutton, dec(cpos,24)); set(rpos,6); &lt;!-- 非手机且展示宽度去除VR和陀螺仪按钮宽度后大于520时显示方向控制按钮 --&gt; calc(show_dirbuttons, !device.mobile AND ((area.pixelwidth + 2*cpos) GT 520)); copy(layer[skin_btn_navi].visible, show_dirbuttons); copy(layer[skin_btn_prev].visible, show_selbuttons); copy(layer[skin_btn_next].visible, show_selbuttons); if(show_selbuttons, inc(lpos,44); inc(rpos,44); ); copy(layer[skin_btn_thumbs].visible, show_thumbutton); copy(layer[skin_btn_thumbs].x, lpos); if(show_thumbutton, inc(lpos,40)); copy(layer[skin_btn_map].visible, show_mapbutton); copy(layer[skin_btn_map].x, lpos); if(show_mapbutton, inc(lpos,40)); &lt;!-- 如果贤惠方向控制按钮需要重新设置按钮的列方式 --&gt; if(show_dirbuttons, copy(layer[skin_btn_navi].x, cpos); inc(cpos,140); set(layer[skin_btn_gyro].align, center); copy(layer[skin_btn_gyro].visible, show_gyrobutton); copy(layer[skin_btn_gyro].x, cpos); if(show_gyrobutton, inc(cpos,48)); set(layer[skin_btn_vr].align, center); copy(layer[skin_btn_vr].visible, show_vrbutton); copy(layer[skin_btn_vr].x, cpos); if(show_vrbutton, inc(cpos,80)); , set(layer[skin_btn_gyro].align, left); copy(layer[skin_btn_gyro].visible, show_gyrobutton); copy(layer[skin_btn_gyro].x, lpos); if(show_gyrobutton, inc(lpos,40)); set(layer[skin_btn_vr].align, left); copy(layer[skin_btn_vr].visible, show_vrbutton); copy(layer[skin_btn_vr].x, lpos); if(show_vrbutton, inc(lpos,80)); ); copy(layer[skin_btn_hide].x, rpos); inc(rpos,40); copy(layer[skin_btn_fs].visible, show_fsbutton); copy(layer[skin_btn_fs].x, rpos); if(show_fsbutton, inc(rpos,40)); &lt;/action&gt; &lt;!-- 将当前的scene缩略图设置到正中央 --&gt; &lt;action name=\"skin_updatescroll\"&gt; if(layer[skin_thumbs].loaded, set(cursceneindex, 0); if(xml.scene, copy(cursceneindex, scene[get(xml.scene)].index)); layer[skin_thumbs].setcenter(get(scene[get(cursceneindex)].thumbx), get(scene[get(cursceneindex)].thumby)); ); &lt;/action&gt; &lt;!-- 更新滑动组件 --&gt; &lt;action name=\"skin_updatethumbscroll\"&gt; copy(padding,skin_settings.thumbs_padding); if(skin_settings.thumbs_scrollbuttons, if(loverflow GT 0, set(layer[skin_thumbs_scrollleft].visible,true), set(layer[skin_thumbs_scrollleft].visible,false) ); if(roverflow GT 0, set(layer[skin_thumbs_scrollright].visible,true), set(layer[skin_thumbs_scrollright].visible,false) ); ); if(skin_settings.thumbs_scrollindicator, if(woverflow GT 0, set(layer[skin_thumbs_scrollindicator].visible,true); sub(iw,pixelwidth,woverflow); div(pw,iw,pixelwidth); div(px,loverflow,woverflow); mul(pw,iw); copy(layer[skin_thumbs_scrollindicator].width,pw); sub(iw,pw); sub(iw,padding); sub(iw,padding); mul(px,iw); add(px,padding); copy(layer[skin_thumbs_scrollindicator].x,px); , set(layer[skin_thumbs_scrollindicator].visible,false); ); ); &lt;/action&gt; &lt;!-- 更新场景信息 --&gt; &lt;action name=\"skin_update_scene_infos\"&gt; if(xml.scene !== null AND scene[get(xml.scene)].index GE 0, &lt;!-- 设置场景名称 --&gt; if(skin_settings.title, if(title, txtadd(layer[skin_title].html, get(title), ' - ', get(scene[get(xml.scene)].title) ); , copy(layer[skin_title].html, scene[get(xml.scene)].title ); ); delayedcall(0.1, set(layer[skin_title].visible,true) ); ); &lt;!-- 如果不循环根据当前场景的序号设置切换按钮显示 --&gt; if(skin_settings.thumbs_loop == false, if(scene[get(xml.scene)].index GT 0, set(layer[skin_btn_prev].enabled, true); set(layer[skin_btn_prev].alpha, 1.0); , set(layer[skin_btn_prev].enabled, false); set(layer[skin_btn_prev].alpha, 0.3); ); sub(lastsceneindex, scene.count, 1); if(scene[get(xml.scene)].index LT lastsceneindex, set(layer[skin_btn_next].enabled, true); set(layer[skin_btn_next].alpha, 1.0); , set(layer[skin_btn_next].enabled, false); set(layer[skin_btn_next].alpha, 0.3); ); , if(scene.count GT 1, set(layer[skin_btn_prev].enabled, true); set(layer[skin_btn_prev].alpha, 1.0); set(layer[skin_btn_next].enabled, true); set(layer[skin_btn_next].alpha, 1.0); , set(layer[skin_btn_prev].enabled, false); set(layer[skin_btn_prev].alpha, 0.3); set(layer[skin_btn_next].enabled, false); set(layer[skin_btn_next].alpha, 0.3); ); ); if(scene.count GT 1, set(layer[skin_btn_prev_fs].visible, true); set(layer[skin_btn_next_fs].visible, true); , set(layer[skin_btn_prev_fs].visible, false); set(layer[skin_btn_next_fs].visible, false); ); &lt;!-- 设置当前场景的缩略图为选中式样 --&gt; txtadd(parentname, 'skin_thumb_', get(scene[get(xml.scene)].index)); if(layer[get(parentname)], set(layer[skin_thumbborder].parent, get(parentname)); set(layer[skin_thumbborder].visible, true); , set(layer[skin_thumbborder].visible, false); ); if(scene[get(xml.scene)].mapspotname, layer[skin_map].activatespot(get(scene[get(xml.scene)].mapspotname)); layer[skin_map].pantospot(get(scene[get(xml.scene)].mapspotname)); ); &lt;!-- 设置陀螺仪按钮是否显示 --&gt; if(plugin[skin_gyro].isavailable == true AND view.vlookatrange == 180, set(layer[skin_btn_gyro].visible, true); , set(layer[skin_btn_gyro].visible, false) ); &lt;!-- 设置反弹效果 --&gt; if(view.vlookatrange LT 180, if(backup_control_bouncinglimits === null, copy(backup_control_bouncinglimits, control.bouncinglimits); ); set(control.bouncinglimits, false); , if(backup_control_bouncinglimits !== null, copy(control.bouncinglimits, backup_control_bouncinglimits); ); ); &lt;!-- 如果当前场景为视频则加载视频控制条 --&gt; if(scene[get(xml.scene)].isvideopano AND plugin[video] !== null, skin_video_addcontrols(); , skin_video_removecontrols(); ); ); &lt;/action&gt; &lt;!-- 跳转到某一指定scene 参数为scene的序号--&gt; &lt;action name=\"skin_gotoscene\"&gt; if(scene[%1], copy(cursceneindex, scene[get(xml.scene)].index); copy(newsceneindex, scene[%1].index); skin_loadscene(get(newsceneindex), calc(newsceneindex LT cursceneindex ? skin_settings.loadscene_blend_prev : (newsceneindex GT cursceneindex ? skin_settings.loadscene_blend_next : skin_settings.loadscene_blend)) ); ); &lt;/action&gt; &lt;!-- 显示下一个场景（不循环） --&gt; &lt;action name=\"skin_nextscene\"&gt; add(newsceneindex, scene[get(xml.scene)].index, %1); if(newsceneindex GE 0 AND newsceneindex LT scene.count, skin_loadscene(get(newsceneindex), calc(%1 LT 0 ? skin_settings.loadscene_blend_prev : skin_settings.loadscene_blend_next)); ); &lt;/action&gt; &lt;!-- 显示下一个场景（循环） --&gt; &lt;action name=\"skin_nextscene_loop\"&gt; add(newsceneindex, scene[get(xml.scene)].index, %1); sub(lastsceneindex, scene.count, 1); if(newsceneindex LT 0, copy(newsceneindex,lastsceneindex)); if(newsceneindex GT lastsceneindex, set(newsceneindex,0)); skin_loadscene(get(newsceneindex), calc(%1 LT 0 ? skin_settings.loadscene_blend_prev : skin_settings.loadscene_blend_next)); &lt;/action&gt; &lt;!-- skin_loadscene(scenenameorindex, blendmode) --&gt; &lt;!-- 加载场景如果只有一个场景就WebVR的按钮隐藏，并且在场景缩略图上加上边框效果，blendmode为场景切换动画 --&gt; &lt;action name=\"skin_loadscene\"&gt; if(webvr.isenabled AND scene.count GT 1, set(hotspot[webvr_prev_scene].visible, false); set(hotspot[webvr_next_scene].visible, false); ); txtadd(layer[skin_thumbborder].parent, 'skin_thumb_', get(scene[%1].index)); layer[skin_thumbs].scrolltocenter(get(scene[%1].thumbx), get(scene[%1].thumby)); loadscene(get(scene[%1].name), null, get(skin_settings.loadscene_flags), %2); &lt;/action&gt; &lt;!-- 加载文字是否显示 --&gt; &lt;action name=\"skin_showloading\"&gt; if(display.stereo == true, set(layer[skin_loadingtext].visible, false); , set(layer[skin_loadingtext].visible, %1); ); &lt;/action&gt; &lt;!-- 隐藏tips --&gt; &lt;action name=\"skin_hidetooltips\"&gt; set(layer[skin_tooltip].alpha,0.0); set(layer[skin_tooltip].visible,false); &lt;/action&gt; &lt;!-- 按钮的点击效果，在点击的按钮下添加一个Child --&gt; &lt;action name=\"skin_buttonglow\"&gt; if('%1' !== 'null', set(strength,0.7); if(%2 != null, set(strength,%2)); set(layer[skin_buttonglow].parent, %1); set(layer[skin_buttonglow].visible, true); tween(layer[skin_buttonglow].alpha, get(strength), 0.07); , tween(layer[skin_buttonglow].alpha, 0.0, 0.1, default, set(layer[skin_buttonglow].parent, null); set(layer[skin_buttonglow].visible, false); ); ); &lt;/action&gt; &lt;!-- 设置关闭打开的距离 --&gt; &lt;action name=\"skin_calc_opened_closed\"&gt; if(layer[get(name)].y_closed === null, set(layer[get(name)].y_opened, get(layer[get(name)].y)); set(layer[get(name)].y_closed, calc(layer[get(name)].y - skin_settings.controlbar_offset - skin_settings.controlbar_height + skin_settings.controlbar_offset_closed)); ); &lt;/action&gt; &lt;!-- 隐藏控制条，首先隐藏上方布局，其次底部最后控制条 --&gt; &lt;action name=\"skin_hideskin\"&gt; callwith(layer[skin_scroll_window], skin_calc_opened_closed() ); callwith(layer[skin_splitter_bottom], skin_calc_opened_closed() ); callwith(layer[skin_control_bar], skin_calc_opened_closed() ); if(layer[skin_map].state != 'closed', skin_showmap(false); wait(0.40); ); if(layer[skin_thumbs].state != 'closed', skin_showthumbs(false); wait(0.25); ); set(hidetime, calc('%1' == 'instant' ? 0.0 : 0.5)); tween(layer[skin_scroll_window].y, get(layer[skin_scroll_window ].y_closed), get(hidetime)); tween(layer[skin_splitter_bottom].y, get(layer[skin_splitter_bottom].y_closed), get(hidetime)); tween(layer[skin_control_bar].y, get(layer[skin_control_bar ].y_closed), get(hidetime)); tween(layer[skin_btn_prev_fs].x, 0, get(hidetime)); tween(layer[skin_btn_next_fs].x, 0, get(hidetime)); if(layer[skin_logo], tween(layer[skin_logo].alpha, 0.0, 0.5, default, set(layer[skin_logo].visible,false)); ); stopdelayedcall(skin_btn_show_alpha); set(layer[skin_btn_show].visible, true); delayedcall(skin_btn_show_alpha, get(hidetime), tween(layer[skin_btn_show].alpha, 0.25, 0.25); ); &lt;/action&gt; &lt;!-- 显示隐藏的控制条 --&gt; &lt;action name=\"skin_showskin\"&gt; tween(layer[skin_scroll_window ].y, get(layer[skin_scroll_window ].y_opened)); tween(layer[skin_splitter_bottom].y, get(layer[skin_splitter_bottom].y_opened)); tween(layer[skin_control_bar ].y, get(layer[skin_control_bar ].y_opened)); tween(layer[skin_btn_prev_fs].x, -50); tween(layer[skin_btn_next_fs].x, -50); if(layer[skin_logo], set(layer[skin_logo].visible,true); tween(layer[skin_logo].alpha, 1.0); ); stopdelayedcall(skin_btn_show_alpha); set(layer[skin_btn_show].visible, false); delayedcall(skin_btn_show_alpha, 0.25, tween(layer[skin_btn_show].alpha, 0.0, 0.0); ); &lt;/action&gt; &lt;!-- 显示缩略图， 首先判断是否已经关闭，layer[skin_scroll_layer].pixelheight=area.pixelheight的值为当前窗口的高度 假设当前窗口高度为640 1.640*-1=-640 2.减去（layer[skin_thumbs].height）缩略图的高度100 -640+100=-540 3.减去（y_offset）背景重叠区域大小 10 -540+10=-530 4. layer[skin_scroll_layer].y大小为负的area.pixelheight+y_offset一开始onresize时设定 则变化范围为 -630 到-530 详细参照http://krpano.com/docu/xml/pluginalignment.png这张图，备注下对于xy属性，默认向下为Y的正向向右为X 的正向，edge未设定时默认和align一个值--&gt; &lt;action name=\"skin_showthumbs\"&gt; if(%1 == null, if(layer[skin_thumbs].state == 'closed', set(show,true), set(show,false)); , set(show,%1); ); mul(mh, layer[skin_scroll_layer].pixelheight, -1); if(show, set(layer[skin_thumbs].state, 'opened'); tween(layer[skin_thumbs].alpha, 1.0, 0.25); add(mh, layer[skin_thumbs].height); add(mh, layer[skin_scroll_layer].y_offset); tween(layer[skin_scroll_layer].y, get(mh), 0.5, easeOutQuint); set(layer[skin_thumbs_container].visible, true); tween(layer[skin_thumbs_container].alpha, 1.0, 0.25); tween(layer[skin_map].alpha, 0.0, 0.25, default, set(layer[skin_map].visible,false)); , set(layer[skin_thumbs].state, 'closed'); tween(layer[skin_thumbs].alpha, 0.0, 0.25, easeOutQuint); add(mh, layer[skin_scroll_layer].y_offset); tween(layer[skin_scroll_layer].y, get(mh), 0.5, easeOutQuint, set(layer[skin_thumbs_container].visible, false);); ); &lt;/action&gt; &lt;!-- 显示地图 --&gt; &lt;action name=\"skin_showmap\"&gt; if(%1 == null, if(layer[skin_map].state == 'closed', set(show,true), set(show,false)); , set(show,%1); ); mul(mh, layer[skin_scroll_layer].pixelheight, -1); if(show, tween(layer[skin_thumbs_container].alpha, 0.0, 0.25, default, set(layer[skin_thumbs_container].visible,false)); set(layer[skin_map].visible, true); tween(layer[skin_map].alpha, 1.0, 0.25); set(layer[skin_map].state, 'opened'); sub(hh,area.pixelheight,skin_settings.controlbar_offset); sub(hh,layer[skin_control_bar].height); sub(hh,32); add(mh,hh); sub(hh,skin_settings.controlbar_overlap); copy(layer[skin_map].height, hh); tween(layer[skin_scroll_layer].y, get(mh), 0.5, easeOutQuint); , if(layer[skin_map].state != 'closed', set(layer[skin_map].state, 'closed'); add(mh, layer[skin_scroll_layer].y_offset); tween(layer[skin_map].alpha, 0.0, 0.5, easeOutQuint); tween(layer[skin_scroll_layer].y, get(mh), 0.5, easeOutQuint, set(layer[skin_map].visible,false) ); ); ); &lt;/action&gt; &lt;!-- 绑定键盘事件 --&gt; &lt;action name=\"skin_keydown_event\"&gt; if(keycode == 33, skin_nextscene_loop(-1) ); &lt;!-- Page Up - previous scene --&gt; if(keycode == 34, skin_nextscene_loop(+1) ); &lt;!-- Page Dowm - next scene --&gt; if(keycode == 35, skin_gotoscene(calc(scene.count-1)) ); &lt;!-- End - last scene --&gt; if(keycode == 36, skin_gotoscene(0) ); &lt;!-- Home/Pos1 - first scene --&gt; &lt;/action&gt; &lt;!-- 如果使用深度链接功能调用skin_deeplinking_update_url_process获取链接参数并设置 --&gt; &lt;action name=\"skin_deeplinking_update_url\"&gt; if(skin_settings.deeplinking AND (!webvr OR webvr.isenabled === false), delayedcall(skin_deeplinking_update, calc(%1 == null ? 0.1 : %1), skin_deeplinking_update_url_process() ); ); &lt;/action&gt; &lt;!-- 深度链接功能，通过URL传递场景的初始位置等信息，重新设定到新的场景上 --&gt; &lt;action name=\"skin_deeplinking_update_url_process\"&gt; &lt;!-- 获取当前的URL --&gt; copy(adr, browser.location); &lt;!-- 获取？后的参数信息 --&gt; indexoftxt(qi, get(adr), '?'); if(qi GT 0, subtxt(adr, adr, 0, get(qi))); copy(si, scene[get(xml.scene)].index); copy(h, view.hlookat); copy(v, view.vlookat); copy(f, view.fov); copy(d, view.distortion); copy(a, view.architectural); clamp(d, 0.0, 1.0); clamp(a, 0.0, 1.0); set(pp, calc(f LT 10 ? 6 : 2)); roundval(h, get(pp)); roundval(v, get(pp)); roundval(f, get(pp)); roundval(d, 2); roundval(a, 1); set(adr, calc(adr + '?startscene=' + si + '&amp;amp;startactions=lookat('+h+','+v+','+f+','+d+','+a+');')); js( history.replaceState(null, document.title, get(adr)); ); &lt;/action&gt; &lt;!-- reload the scene when there is a special image for VR --&gt; &lt;!-- 如果scene标签有havevrimage属性，进入VR重载界面 --&gt; &lt;action name=\"skin_reloadscene_webvr\"&gt; delayedcall(0.1, if(scene[get(xml.scene)].havevrimage, copy(keeplookingdirection_backup, skin_settings.webvr_gyro_keeplookingdirection); set(skin_settings.webvr_gyro_keeplookingdirection, true); loadscene(get(xml.scene), null, MERGE|KEEPVIEW|KEEPMOVING|KEEPHOTSPOTS|NOPREVIEW, BLEND(0.5)); copy(skin_settings.webvr_gyro_keeplookingdirection, keeplookingdirection_backup); delete(keeplookingdirection_backup); ); ); &lt;/action&gt; &lt;!-- videopano support - http://krpano.com/plugins/videoplayer/ --&gt; &lt;!-- 加载视频控制条 --&gt; &lt;action name=\"skin_video_addcontrols\"&gt; set(events[skin_events].onclick, skin_video_clickevent() ); set(plugin[video].onvideoready, skin_video_updatestate() ); set(plugin[video].onvideoplay, skin_video_updatestate() ); set(plugin[video].onvideopaused, skin_video_updatestate() ); set(plugin[video].onvideocomplete, skin_video_updatestate() ); if(plugin[video].ispaused AND plugin[video].pausedonstart, set(layer[skin_video_playpause].state, 'visible'); set(layer[skin_video_playpause].enabled, true); tween(layer[skin_video_playpause].alpha, 1.0); ); delayedcall(skin_video_delayedvisible, 0.25, set(layer[skin_video_controls].visible, true) ); skin_video_updateseekbarwidth(); set(layer[skin_video_seekpos].x,0); set(layer[skin_video_loadbar].width,0); setinterval(skin_video_seek_updates, 0.5, skin_video_updatetime() ); &lt;/action&gt; &lt;!-- 去除视频控制条 --&gt; &lt;action name=\"skin_video_removecontrols\"&gt; stopdelayedcall(skin_video_delayedvisible); set(events[skin_events].onclick, null); set(layer[skin_video_playpause].alpha, 0.0); set(layer[skin_video_controls].visible, false); clearinterval(skin_video_seek_updates); &lt;/action&gt; &lt;!-- 实时更新seek的进度和时间显示 --&gt; &lt;action name=\"skin_video_updatetime\"&gt; copy(t1, plugin[video].time); copy(t2, plugin[video].totaltime); if(%1 !== null, calc(t1, %1 * t2); ); div(t1_min, t1, 60); mod(t1_sec, t1, 60); Math.floor(t1_min); Math.floor(t1_sec); div(t2_min, t2, 60); mod(t2_sec, t2, 60); Math.floor(t2_min); Math.floor(t2_sec); calc(layer[skin_video_time].html, t1_min + ':' + (t1_sec LT 10 ? '0' : '') + t1_sec + ' / ' + t2_min + ':' + (t2_sec LT 10 ? '0' : '') + t2_sec); calc(layer[skin_video_seekpos].x, (t1 / t2 * 100) + '%'); calc(layer[skin_video_loadbar].width, (plugin[video].loadedbytes / plugin[video].totalbytes * 100) + '%'); &lt;/action&gt; &lt;!-- 更新视频进度空间的宽度 --&gt; &lt;action name=\"skin_video_updateseekbarwidth\"&gt; if(skin_settings.title, calc(layer[skin_video_seekbar_container].width, 0 - (32 + layer[skin_title].pixelwidth + layer[skin_video_time].pixelwidth)); calc(layer[skin_video_seekbar_container].x, layer[skin_title].pixelwidth + 16); , calc(layer[skin_video_seekbar_container].width, 0 - (24 + layer[skin_video_time].pixelwidth)); set(layer[skin_video_seekbar_container].x, 8); ); &lt;/action&gt; &lt;!-- 跳转到指定的视频进度 --&gt; &lt;action name=\"skin_video_ondownseeking\"&gt; asyncloop(pressed, screentolayer(skin_video_seekbar, mouse.stagex,mouse.stagey, lx,ly); calc(seekpos, lx / layer[skin_video_seekbar].pixelwidth); clamp(seekpos, 0.0, 1.0); skin_video_updatetime(seekpos); , plugin[video].seek(calc((seekpos * 100) + '%')); ); &lt;/action&gt; &lt;!-- 暂停或者显示时的图层 --&gt; &lt;layer name=\"skin_video_playpause\" keep=\"true\" style=\"skin_base|skin_glow\" crop=\"0|640|64|64\" scale=\"0.75\" align=\"center\" alpha=\"0.0\" autoalpha=\"true\" state=\"hidden\" onclick=\"skin_video_playpause_click();\" /&gt; &lt;!-- 状态变更时更新 --&gt; &lt;action name=\"skin_video_updatestate\"&gt; calc(layer[skin_video_playpause].crop, plugin[video].ispaused ? '0|640|64|64' : '64|640|64|64'); if(plugin[video].iscomplete, set(layer[skin_video_playpause].state, 'visible'); tween(layer[skin_video_playpause].alpha, 1.0); ); &lt;/action&gt; &lt;!-- 点击暂停按钮 --&gt; &lt;action name=\"skin_video_playpause_click\"&gt; if(plugin[video].ispaused, plugin[video].play(); set(layer[skin_video_playpause].state, 'hidden'); tween(layer[skin_video_playpause].alpha, 0.0); , plugin[video].pause(); set(layer[skin_video_playpause].state, 'visible'); tween(layer[skin_video_playpause].alpha, 1.0); delayedcall(autohide_pp, 2.0, set(layer[skin_video_playpause].state,'hidden'); tween(layer[skin_video_playpause].alpha, 0.0); ); ); &lt;/action&gt; &lt;!-- 点击屏幕的事件触发视频播放和暂停 --&gt; &lt;action name=\"skin_video_clickevent\"&gt; stopdelayedcall(autohide_pp); switch(layer[skin_video_playpause].state, 'visible', 'hidden'); if(layer[skin_video_playpause].state == 'hidden', tween(layer[skin_video_playpause].alpha, 0.0); , tween(layer[skin_video_playpause].alpha, 1.0); delayedcall(autohide_pp, 2.0, set(layer[skin_video_playpause].state,'hidden'); tween(layer[skin_video_playpause].alpha, 0.0); ); ); &lt;/action&gt; &lt;!-- context menu - http://krpano.com/docu/xml/#contextmenu --&gt; &lt;!-- 右键按钮菜单 --&gt; &lt;contextmenu&gt; &lt;item name=\"kr\" caption=\"Krpano\" onclick=\"openurl('http://www.krpano.com',_blank);\"/&gt; &lt;item name=\"fs\" caption=\"FULLSCREEN\" /&gt; &lt;item name=\"cc\" caption=\"Change Controlmode\" onclick=\"skin_changecontrolmode();\" separator=\"true\" /&gt; &lt;item name=\"nv\" caption=\"Normal View\" onclick=\"skin_view_normal();\" showif=\"view.vlookatrange == 180\" separator=\"true\" /&gt; &lt;item name=\"fv\" caption=\"Fisheye View\" onclick=\"skin_view_fisheye();\" showif=\"view.vlookatrange == 180\" devices=\"flash|webgl\" /&gt; &lt;item name=\"sv\" caption=\"Stereographic View\" onclick=\"skin_view_stereographic();\" showif=\"view.vlookatrange == 180\" devices=\"flash|webgl\" /&gt; &lt;item name=\"av\" caption=\"Architectural View\" onclick=\"skin_view_architectural();\" showif=\"view.vlookatrange == 180\" /&gt; &lt;item name=\"pv\" caption=\"Pannini View\" onclick=\"skin_view_pannini();\" showif=\"view.vlookatrange == 180\" devices=\"flash|webgl\" /&gt; &lt;item name=\"lp\" caption=\"Little Planet View\" onclick=\"skin_view_littleplanet();\" showif=\"view.vlookatrange == 180\" devices=\"flash|webgl\" /&gt; &lt;/contextmenu&gt; &lt;!-- 点击改变控制方式函数 --&gt; &lt;action name=\"skin_changecontrolmode\"&gt; switch(control.mouse, moveto, drag); switch(control.touch, moveto, drag); &lt;/action&gt; &lt;!-- 以下为不同的全景显示模式 --&gt; &lt;action name=\"skin_view_look_straight\"&gt; if(view.vlookat LT -80 OR view.vlookat GT +80, tween(view.vlookat, 0.0, 1.0, easeInOutSine); tween(view.fov, 100, distance(150,0.8)); ); skin_deeplinking_update_url(1.0); &lt;/action&gt; &lt;action name=\"skin_view_normal\"&gt; skin_view_look_straight(); tween(view.architectural, 0.0, distance(1.0,0.5)); tween(view.pannini, 0.0, distance(1.0,0.5)); tween(view.distortion, 0.0, distance(1.0,0.5)); &lt;/action&gt; &lt;action name=\"skin_view_fisheye\"&gt; skin_view_look_straight(); tween(view.architectural, 0.0, distance(1.0,0.5)); tween(view.pannini, 0.0, distance(1.0,0.5)); tween(view.distortion, 0.35, distance(1.0,0.5)); &lt;/action&gt; &lt;action name=\"skin_view_architectural\"&gt; skin_view_look_straight(); tween(view.architectural, 1.0, distance(1.0,0.5)); tween(view.pannini, 0.0, distance(1.0,0.5)); tween(view.distortion, 0.0, distance(1.0,0.5)); &lt;/action&gt; &lt;action name=\"skin_view_stereographic\"&gt; skin_view_look_straight(); tween(view.architectural, 0.0, distance(1.0,0.5)); tween(view.pannini, 0.0, distance(1.0,0.5)); tween(view.distortion, 1.0, distance(1.0,0.8)); &lt;/action&gt; &lt;action name=\"skin_view_pannini\"&gt; skin_view_look_straight(); tween(view.architectural, 0.0, distance(1.0,0.5)); tween(view.pannini, 1.0, distance(1.0,0.8)); if(view.distortion LT 0.1, tween(view.distortion, 1.0, distance(1.0,0.8)); ); &lt;/action&gt; &lt;action name=\"skin_view_littleplanet\"&gt; tween(view.architectural, 0.0, distance(1.0,0.5)); tween(view.pannini, 0.0, distance(1.0,0.5)); tween(view.distortion, 1.0, distance(1.0,0.8)); tween(view.fov, 150, distance(150,0.8)); tween(view.vlookat, 90, distance(100,0.8)); add(new_hlookat, view.hlookat, 123.0); tween(view.hlookat, get(new_hlookat), distance(100,0.8)); skin_deeplinking_update_url(1.0); &lt;/action&gt;&lt;/krpano&gt; (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"krpano","slug":"krpano","permalink":"https://austinxishou.github.io/tags/krpano/"}]},{"title":"Android中SELINUX规则分析和语法简介","date":"2017-11-01T08:03:06.333Z","path":"2017/11/01/android/android-selinux-sepolice-modify/","text":"Selinux-About简介SELINUX是可以理解为一种android上面的安全机制，是有美国国家安全局和一些公司设计的一个针对linux的安全加强系统我们可以通过配置SELINUX的相关policy，来定制自己的手机的一些权限，比如，我们可以完全让root用户没有任何的权限和user一样 Android-Selinux裁剪 在android中，只定义了一个user即为u. 另外，如果是进程的话，都会统一定义为r，如果是文件的话，会被定义为object_r.第三个是这个进程type，在andorid里面，定义了100多个type.按照目前我的理解，这个是进程所属的&gt;类型。第四个是s0，这个是一个安全的等级。 Android-Selinux-文件结构首先要了解sepolicy的结构： 1234a. App进程 -&gt; mac_permissions.xmlb. App数据文件 -&gt; seapp_contextsc. 系统文件 -&gt; file_contextsd. 系统属性 -&gt; property_contexts 然后是一些特殊的配置文件： external/sepolicy/attributes -&gt; 所有定义的attributes都在这个文件 external/sepolicy/access_vectors -&gt; 对应了每一个class可以被允许执行的命令 external/sepolicy/roles -&gt; Android中只定义了一个role，名字就是r，将r和attribute domain关联起来 external/sepolicy/users -&gt; 其实是将user与roles进行了关联，设置了user的安全级别，s0为最低级是默认的级别，mls_systemHigh是最高的级别 external/sepolicy/security_classes -&gt; 指的是上文命令中的class，个人认为这个class的内容是指在android运行过程中，程序或者系统可能用到的操作的模块 external/sepolicy/te_macros -&gt; 系统定义的宏全在te_macros文件 external/sepolicy/*.te -&gt; 一些配置的文件，包含了各种运行的规则 在te文件中，我们一般遇到的语法是这样的： rule_name source_type target_type:class perm_set解读为： 为source_type设置一个rule_name的规则，规则是对target_type的class 进行 perm_set的操作。 type的命令如下：123type type_id [alias alias_id,] [attribute_id]//将type_id（别名为alias）关联到attribute. //这样的话，方便用attribute来管理不同的type中包含相同的属性的部分。 class命令的格式为：12class class_name [ inherits common_name ] &#123; permission_name ... &#125;//inherits表示继承了common定义的权限，然后自己额外实现了permission_name的权限 在te文件中常见的四种命名的规则： allow：赋予某项权限。 allowaudit：audit含义就是记录某项操作。默认情况下是SELinux只记录那些权限检查失败的操作。 allowaudit则使得权限检查成功的操作也被记录。注意，allowaudit只是允许记录，它和赋予权限没关系。赋予权限必须且只能使 dontaudit：对那些权限检查失败的操作不做记录。 neverallow：前面讲过，用来检查安全策略文件中是否有违反该项规则的allow语句。语法举例1type init, domain; 将init关联到domain，即将domain设置为init类型的属性 1allow init unlabeled:filesystem mount; 允许init类型对unlabeled类型的filesystem进行mount的操作 1allow init fotad:unix_stream_socket &#123; bind create &#125;; 允许init类型对fotad类型的unix_stream_socket 进行bind和create的操作 12allow appdomain anr_data_file:dir search;allow appdomain anr_data_file:file &#123; open append &#125;; 首先appdomain是定义在te_macros里面的一个宏，很多的app规则会使用类似app_domain(shell)的命令将其添加进去这两句话的意思是： 允许app去对anr_data_file类型的目录进行查找的操作 允许app对anr_data_file类型的file进行打开和添加操作 其实就是规定了出现anr时候，app往/data/anr/里面写入的权限限制 1neverallow &#123; appdomain -unconfineddomain &#125; kmem_device:chr_file &#123; read write &#125;; 绝对不允许app(除了有unconfineddomain属性的app)对kmem_device类型的字符设备进行读写的操作 1neverallow &#123; appdomain -unconfineddomain &#125; self:capability2 *; 绝对不允许除了unconfineddomain以外的app对self类型的capability2进行任何的操作 1type httpd_user_content_t, file_type, httpdcontent; 声明一个httpd_user_content_t的类型，具有file_type和httpdcontent的属性 12type httpd_user_content_t;typeattribute httpd_user_content_t file_type, httpdcontent; 声明一个httpd_user_content_t的类型定义httpd_user_content_t具有file_type, httpdcontent的属性 1allow appdomain self:rawip_socket create_socket_perms; 所有可以设置类型的地方其实都可以设置为属性。比如这个例子，我们允许所有具有app属性的内容可以去对self属性的rawip_socket进行create的操作 1allow &#123;user_t domain&#125; &#123;bin_t file_type sbin_t&#125;:file execute ; 允许user_t和domain属性的类对bin_t, file_type, sbin_t类型的file进行可执行的操作 12allow user_t user_t:process signal;allow user_t self:process signal; 这两条语句的表述其实是一致的，其实self指的是目标的类型和发起人的类型是一致的所以不能声明一个类型或者属性叫做self 1allow user_t bin_t:file ~&#123; write setattr ioctl &#125;; 允许user_t对bin_t类型的file进行除了write setattr ioctl相关的操作 1type_transition system wifi_data_file:sock_file system_wpa_socket; 当一个类型为system的类别去进行wifi_data_file类型的sock_file访问时，类型默认切换到system_wpa_socket 如果下面这条语句想要执行成功type_transition init_t apache_exec_t:process apache_t;至少首先声明下面的三条规则：123allow init_t apache_exec_t:file execute;allow init_t apache_t:process transition;allow apache_t apache_exec_t:file entrypoint; type_transition和type_change的语法规则是一样的， type_change规则的影响不会在内核中生效，而是依赖于用户空间应用程序，如login或sshd 方法1: adb在线修改seLinux Enforcing(表示已打开)，Permissive（表示已关闭） getenforce; //获取当前seLinux状态 setenforce 1; //打开seLinux setenforce 0; //关闭seLinux 方法2: 从kernel中彻底关闭修改LINUX/android/kernel/arch/arm64/configs/xxx_defconfig文件（xxx一般为手机产品名）， 去掉CONFIG_SECURITY_SELINUX=y的配置项 方法3: sepolicy中添加权限 修改依据，通过指令cat /proc/kmsg | grep denied，或者kernel的Log中定位到标志性log。 修改步骤 找相应的源类型.te文件，此文件可能的存放路径 (其中源类型见下方的标志性log格式) ： LINUX/android/external/sepolicy LINUX/android/device/qcom/sepolicy/common 标志性log 格式 avc: denied { 操作权限 } for pid=7201 comm=“进程名” scontext=u:r:源类型:s0 tcontext=u:r:目标类型:s0 tclass=访问类型 permissive=0 在相应源类型.te文件，添加如下格式的一行语句：(结尾别忘了分号) 格式：allow 源类型 目标类型:访问类型 {操作权限}; 实例 Kernel Log avc: denied {getattr read} for pid=7201 comm=&quot;xxx.xxx&quot; scontext=u:r:system_app:s0 tcontext=u:r:shell_data_file:s0 tclass=dir permissive=0 修改方案 在system_app.te文件中，添加下面语句： allow system_app shell_data_file:dir{getattr read}; (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"}]},{"title":"微信公众号开发-微擎系统相关学习","date":"2017-11-01T08:03:05.089Z","path":"2017/11/01/wechat/we7-wechat-framework-started/","text":"官方文档 微擎官网 微擎文档 微擎开发文档 (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"wechat","slug":"wechat","permalink":"https://austinxishou.github.io/tags/wechat/"},{"name":"we7","slug":"we7","permalink":"https://austinxishou.github.io/tags/we7/"}]},{"title":"GithubPages+Hexo3.0搭建静态博客网页","date":"2017-11-01T08:03:05.042Z","path":"2017/11/01/webdesign/GithubPagesHexo3.0-for-personal-blog/","text":"AboutHexo 是一个轻量的静态博客框架。通过Hexo可以快速生成一个静态博客框架,仅需要几条命令就可以完成,相当方便。而架设Hexo的环境更简单了 不需要lnmp/lamp这些繁琐复杂的环境 仅仅需要一个简单的http服务器即可使用 或者使用互联网上免费的页面托管服务 比如Hexo的官方网站就是托管于github的pages服务上 Hexo配置方法进去之后加入hexo主程序和安装npm12hexo initnpm install 目录结构新建完成后，指定文件夹的目录如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 source资源文件夹是存放用户资源的地方。除 posts 文件夹之外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 Hexo全局配置用文本编辑器修改_config.yml这个文件 大致如下 只需要自行修改几个 其他保持默认即可 通常需要修改站点名称 /URL格式 /归档设置 /disqus评论用户名 /部署配置 这几项就可以了 注意冒号后面都要添加一个半角空格 之后才是设置参数 自定义域名设置 在 source 我文件夹下面新建 CNAME 文件 里面写入你的自定义域名 并设置您的dns配置cname方式到服务提供商的给的地址即可 目录source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public tag_dir 标签文件夹 tags archive_dir 归档文件夹 archives category_dir 分类文件夹 categories code_dir Include code 文件夹 downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染，您可使用 glob 来配置路径。 文章本地启动server1$ hexo server 可以观察命令行的输出，然后通过浏览器打开http://localhost:4000/，成功的情况下则会看到默认的欢迎页面。 部署到github pagesHexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。1$ hexo deploy 在开始之前，您必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数，例如： 12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] 1234参数 描述repo 库（Repository）地址branch 分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。message 自定义提交信息 (默认为 Site updated: &#123;&#123; now(&apos;YYYY-MM-DD HH:mm:ss&apos;) &#125;&#125;) 我的博客对应的参数设置为123456deploy: type: git repo: https://github.com/austinxishou/austinxishou.github.io.git branch: master name: austinxishou email: austinxishou@yahoo.com 安装 hexo-deployer-git 1$ npm install hexo-deployer-git --save 之后依次执行:123$ hexo clean$ hexo generate$ hexo deploy 上述命令只要Github的权限校验通过,基本都能成功; hexo主题收集主题 Next Nidigo 写文章使用草稿在 source/_drafts 文件夹中 创建的文章为草稿，默认情况下不生成；可以显示草稿1$ hexo --draft 生成sitemap站点地图安装插件12npm install -g hexo-generator-sitemap --savenpm install -g hexo-generator-baidu-sitemap --save 修改_config.yml文件12345# auto sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml(function(){ var bp = document.createElement(‘script’); var curProtocol = window.location.protocol.split(‘:’)[0]; if (curProtocol === ‘https’) { bp.src = ‘https://zz.bdstatic.com/linksubmit/push.js‘; } else { bp.src = ‘http://push.zhanzhang.baidu.com/push.js‘; } var s = document.getElementsByTagName(“script”)[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == &quot;http:&quot;) ? &quot;http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;:&quot;https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;; document.write(&apos;&lt;script src=&quot;&apos; + sozzsrc + &apos;&quot; id=&quot;sozz&quot;&gt;&lt;\\/script&gt;&apos;); })();","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://austinxishou.github.io/tags/Hexo/"},{"name":"webdesign","slug":"webdesign","permalink":"https://austinxishou.github.io/tags/webdesign/"},{"name":"github","slug":"github","permalink":"https://austinxishou.github.io/tags/github/"}]},{"title":"Android组件生命周期解析","date":"2017-11-01T08:03:04.375Z","path":"2017/11/01/android/android-compent-lifetime/","text":"Activity在平时的应用开发中,接触最多的就是activity的生命周期。在生命周期回调方法中，您可以声明当用户离开并重新进入活动时，执行相应的代码行为。每一个回调工作，都应该执行特定动作，在正确的时间进行正确的工作并正确处理转换，才能够使应用程序更加健壮，更有效率。 如果没有处理好activity的生命周期，则有可能导致各种异常: 应用程序运行时被电话或者其他程序中断，导致崩溃； 没有正确释放资源时,消耗宝贵的系统资源，甚至OOM。 如果用户离开您的应用程序并在以后返回，则丢失用户的进度。 屏幕在横向和纵向方向之间旋转时，可能会崩溃或丢失用户的进度。 所以有必要深入一些，了解和掌握Activity的生命，下面先放一张activity的生命周期图： activity lifecycle 1.1 Activity状态根据具体的应用的复杂性，可能不需要实现所有的生命周期方法。 创建 onCreate()： 必须实现此回调，当系统首次创建活动时触发。 在该方法中，执行基本的应用程序启动逻辑，该逻辑在整个活动的整个生命周期中应该只发生一次。 例如，将数据绑定到列表，初始化后台线程，并实例化一些类范围变量。 此方法接收参数savedInstanceState，该参数是包含Bundle 活动之前保存的状态的对象。如果活动从未存在，则该Bundle对象的值为null。 开始 onStart()： 当活动进入“开始”状态时，系统将调用此回调。 该方法是应用程序初始化维护UI的代码的位置。 它也可以注册一个BroadcastReceiver 监视UI中响应的更改。 该状态只是过渡状态，非常快速完成，与“创建”状态一样，活动不会保持在“已启动”状态。一旦这个回调结束，活动进入 Resumed状态，系统调用该 onResume()方法。 恢复 onResume()： 这是应用程序与用户进行交互的状态。该应用程序停留在此状态，直到发生某些事情，将焦点从应用程序中移开。 当发生中断事件时，活动进入暂停 状态，系统调用 onPause()回调。 onResume状态说明activity在最上方，用户可以与它进行交互。所以那些仅在用户关注时才使用的组件应该在这个回调中初始化。 暂停 onPause()： 当前activity仍然是可见的。但被另一个activity处在最上方，最上方的activity是半透明的，或者是部分覆盖整个屏幕。被暂停的activity不会再接受用户的输入。 动画和音乐播放Activity在暂停状态下不应该继续。 进入暂停的时机有以下几种： 电话或者短信等系统中断； 在多窗口模式中，切换到其他窗口； 打开一个新的半透明活动（如对话框）; 当处于极度低内存的状态时，系统会杀掉该activity，释放相应资源。 onPause()执行非常简短，并不一定有足够的时间执行保存操作。保存应用程序或用户数据不应该在这步骤实现； 停止 onStop（）： 当前activity完全被隐藏，不被用户可见。可以认为是处于在后台。 由于对用户不再可见，只要有内存的需要，系统就会杀掉该activity来释放资源。 该状态由onStop()进入，或onRestart()或者onCreate()重新唤醒软件，或者被onDestroy()彻底死亡.. 销毁 onDestroy()： 在活动被销毁之前调用。这是活动收到的最后一个回调。 在该回调中，释放上述所有回调中未被销毁的资源； 当acitivty处于暂停或者停止状态，系统可以通过finish()或 android.os.Process.killProcess(android.os.Process.myPid())来杀死其进程。当该activity再次被打开时(结束或杀死后)，需要重新创建，走一遍完整的流程。 1.2 Activities调用流程当Activity A 启动 Activity B时，两个activity都有自个的生命周期。Activity A暂停或者停止，Activity B被创建。记住，在Activity B创建之前，Activity A并不会完全停止，流程如下： Activity A 进入onPause(); Activity B 依次 onCreate(), onStart(), onResume()。（此时Activity B得到了用户焦点） 如果Activity A不再可见，则进入onStop(). 1.3 代码实践利用下面的DemoActivity代码，可亲自感受每一个阶段的状态。比如点返回键，home键，menu键等操作，可以借助通过logcat查看该activity到底处于哪种状态，这里就不说结果了，自己动手，丰衣足食。 import android.app.Activity; import android.os.Bundle; import android.util.Log; public class DemoActivity extends Activity { private static final String TAG = &quot;demo&quot;; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Log.i(TAG,&quot;onCreate::The activity is being created.&quot;); } @Override protected void onStart() { super.onStart(); Log.i(TAG, &quot;onStart::The activity is about to become visible.&quot;); } @Override protected void onResume() { super.onResume(); Log.i(TAG, &quot;onResume::The activity has become visible.&quot;); } @Override protected void onPause() { super.onPause(); Log.i(TAG, &quot;onPause:: Another activity is taking focus.&quot;); } @Override protected void onStop() { super.onStop(); Log.i(TAG, &quot;onStop::The activity is no longer visible&quot;); } @Override protected void onDestroy() { super.onDestroy(); Log.i(TAG, &quot;onDestroy::The activity is about to be destroyed&quot;); } } Service理解activity的生命周期后，Service的生命周期也是大同小异，先看下Service的生命周期图： service lifecycle 2.1 启动方式：service有两种启动方式： startService() 启动本地服务Local Service bindService() 启动远程服务Remote Service 2.2 生命周期两种不同的启动方式决定了Service具有两种生命周期的可能（并非互斥的两种）。 start方式：onCreate()，onStartCommand()。onDestroy释放资源。 bind方式： onCreate()，onBind()方法。需要所有client全部调用unbindService()才能将Service释放资源，等待系统回收。 2.3 代码实践利用下面的DemoService代码，通过logcat自行感受每一个阶段的状态与场景的关系。 import android.app.Service; import android.content.Intent; import android.os.IBinder; import android.util.Log; public class DemoService extends Service { private static final String TAG = &quot;demo&quot;; int mStartMode; // service被杀掉的方式 IBinder mBinder; // clients绑定接口 boolean mAllowRebind; // 是否允许onRebind @Override public void onCreate() { Log.i(TAG,&quot;onCreate::The service is being created&quot;); } @Override public int onStartCommand(Intent intent, int flags, int startId) { Log.i(TAG,&quot;onStartCommand::The service is starting&quot;); return mStartMode; } @Override public IBinder onBind(Intent intent) { Log.i(TAG,&quot;onBind::A client is binding to the service&quot;); return mBinder; } @Override public boolean onUnbind(Intent intent) { Log.i(TAG,&quot;onUnbind::All clients have unbound&quot;); return mAllowRebind; } @Override public void onRebind(Intent intent) { Log.i(TAG,&quot;onRebind::A client rebind to the service &quot; + &quot;after onUnbind() has already been called&quot;); } @Override public void onDestroy() { Log.i(TAG,&quot;onDestroy::The service is no longer used&quot;); } } (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"activity","slug":"activity","permalink":"https://austinxishou.github.io/tags/activity/"}]},{"title":"html layout","date":"2017-11-01T07:56:16.715Z","path":"2017/11/01/webdesign/html-css-layout/","text":"Online web学习CSS布局Web前端实验室 http://www.jianshu.com/p/56d8672ccb0f 详解CSS position属性详解CSS position属性position四种类型 1. static static是position属性的默认值，默认情况下，块级元素和行内元素按照各自的特性进行显示 2. relative relative翻译成中文称相对定位，设置了这个属性后，元素会根据top，left，bottom，right进行偏移，关键点是它原本的空间仍然保留。 3. absolute 元素设置成absolute后会脱离文档流，并且不占有原本的空间，后面的元素会顶替上去，而且不论元素是行内元素还是块级元素，都会生成一个块级框，也就是例如行内元素span设置了absolute后就可以设置height和width属性了。 4. fixed fixed的表现方式类似于absolute，但是相比于absolute相对于不确定的父元素进行偏移，fixed就是相对于浏览器窗口进行偏移 详解CSS float属性详解CSS float属性 float特性: 浮动元素会从普通文档流中脱离，但浮动元素影响的不仅是自己，它会影响周围的元素对齐进行环绕 浮动元素在浮动的时候，其margin不会超过包含块的padding 有多个浮动元素，后面的浮动元素的margin不会超过前面浮动元素的margin 两个元素一个向左浮动，一个向右浮动，左浮动元素的marginRight不会和右浮动元素的marginLeft相邻 如果包含块宽度不够，后面的浮动元素将会向下浮动，其顶端是前面浮动元素的底端 浮动元素顶端不会超过包含块的内边界底端，如果有多个浮动元素，下一个浮动元素的顶端不会超过上一个浮动元素的底端 浮动元素会尽可能地向顶端对齐、向左或向右对齐 float特殊情况: 浮动元素的延伸性 清除浮动: 为什么要清除浮动: 我们知道，一个块级元素如果没有设置height，其height是由子元素撑开的。对子元素使用了浮动之后，子元素会脱离标准文档流，也就是说，父级元素中没有内容可以撑开其高度，这样父级元素的height就会被忽略，这就是所谓的高度塌陷。 如何清除浮动: 增加额外的div这是最简单直接的方法，哪里有浮动元素，就在其父级元素的内容中增加一个（作为最后一个子元素） 优点：简单直接，初学者常常使用的方法，也易于理解 缺点：增加额外的无意义标签，不利于语义化，每次清除都要添加额外的空标签，造成浪费 父级元素添加overflow:hidden 优点：代码量少，没有额外的标签 缺点：如果子元素超出父元素的范围，会造成超出的部分被隐藏 after伪元素(推荐使用这种方法) 优点：没有额外标签，综合起来算是比较好的方法 缺点：稍显复杂，但是理解其原理后也挺简单的 after表示子元素的后面，通过它可以设置一个具有clear的元素，然后将其隐藏 float的应用 1. 文字环绕效果 float最初的应用就是文字环绕效果，这对图文并茂的文章很有用。 2. 横向菜单排列 3. 布局 详解CSS dispaly属性去除inline-block元素间间距的N种方法 屏幕尺寸戴尔台式：1536*482；从网易与淘宝的font-size思考前端设计稿与工作流pageResponse移动端响应式框架 百分比布局rem布局不足： rem只能在某个局部范围内适应，在某些分辨率下效果不好 transfer：scale布局Flex布局Flex布局部分属性困惑解析 图片float后怎样在DIV中垂直居中图片float后怎样在DIV中垂直居中?大小不固定的图片和多行文字的垂直水平居中 border-bottom: 3px solid #FD904B !important; 收起/展开 12345678910111213141516171819var zk = document.getElementById(&quot;zk&quot;);var iszk = false;zk.onclick = function () &#123; if (iszk) &#123; document.getElementById(&quot;banner2&quot;).style.padding = &quot;20px 0&quot;; zk.innerHTML = &apos;&lt;p style=&quot;text-indent: 2em;margin-top: 10px&quot;&gt;中国文化馆年会是全国性，最大规模文化馆行业盛会，迄今已成功举办四届，具有较高的行业知名度与社会影响力．文化艺术博览会（以下．．．&lt;span style=&quot;color: dodgerblue;&quot;&gt;展开全文&lt;/span&gt;&lt;/p&gt;&apos;; iszk = false; &#125; else &#123; document.getElementById(&quot;banner2&quot;).style.padding = &quot;0 0 20px 0&quot;; zk.innerHTML = &apos;&lt;p style=&quot;text-indent: 2em;margin-top: 10px&quot;&gt;中国文化馆年会是全国性、最大规模文化馆行业盛会，迄今，已成功举办四届，具有较高的行业知名度与社会影响力。文化艺术博览会（以下简称“博览会”）是年会的重要版块，汇聚了数百家文化馆行业相关企、事业单位，集合展示行业内顶尖文化、科技与旅游供应商以及优秀文化团体的优质产品与服务，为年会举办地广大市民和行业参会代表奉献一场文化交流盛宴。&lt;/p&gt;&lt;div class=&quot;_underline&quot;&gt;&lt;/div&gt;&lt;p&gt;展会名称：2017年中国文化馆年会?文化艺术博览会&lt;/p&gt;&lt;p&gt;时&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;间：2017年11月29日-12月1日（展期3天）&lt;/p&gt;&lt;p&gt;地&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;点：马鞍山市会展中心&lt;/p&gt;&lt;p&gt;规&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;模：室内外展览面积约30000平方米，拥有3个展厅，面积11000平方米，分四大展区。&lt;/p&gt;&lt;div class=&quot;_underline&quot;&gt;&lt;/div&gt;&lt;p&gt;第一展区：互联网+：助力文化馆行业供给侧改革&lt;/p&gt;&lt;p&gt;第二展区：流光溢彩：优秀传统文化的创新与创造&lt;/p&gt;&lt;p&gt;第三展区：文化旅游产品交易&lt;/p&gt;&lt;p&gt;第四展区：李白国际户外旅游文化节暨户外运动商品展&lt;/p&gt;&lt;div&gt;&lt;p style=&quot;color: dodgerblue;text-align: right&quot;&gt;收起&lt;/p&gt;&lt;/div&gt;&lt;br&gt;&apos;; iszk = true; &#125;&#125;//寻宝function findGold() &#123; window.location.href = &quot;?r=wbh/findgold&quot;;&#125; 自定义按钮123456.custombtn &#123; padding: 10px; border-radius: 5px; background-color: #6A9FFD; color: white !important;&#125; 图文框下划线12345.underline &#123; padding: 10px 0; margin: 0 5px; border-bottom: 1px solid #eeeeee;&#125; 12345678910111213&lt;div class=&quot;underline&quot;&gt; &lt;a href=&quot;?r=site/cominfo&amp;amp;id=5&quot; class=&quot;cusBtn&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-3&quot; align=&quot;center&quot;&gt; &lt;img src=&quot;company/5.png&quot; width=&quot;100%&quot; style=&quot;max-height: 50px&quot;&gt; &lt;/div&gt; &lt;div class=&quot;col-xs-9&quot;&gt; &lt;h4 style=&quot;color: #AE923F;&quot;&gt;华夏数图（北京）科技发展有限公司&lt;/h4&gt; &lt;p style=&quot;margin:15px 0;&quot;&gt;华夏数图是一家以弘扬中华文化、传播华夏文明为宗旨的文化创新企...&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/a&gt;&lt;/div&gt; 下拉三角形 123456789&lt;div class=&quot;triangle&quot;&gt;&lt;/div&gt;.triangle &#123; margin: 1em auto; width: 0; height: 0; border-left: 0.5em solid transparent; border-right: 0.5em solid transparent; border-top: 0.6em solid #222;&#125; 12345678.researchFormTop .triangle &#123; margin: 1em auto; width: 0; height: 0; border-left: 0.5em solid transparent; border-right: 0.5em solid transparent; border-bottom: 0.6em solid #222;&#125; 微信分享12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061wx.config(&#123; debug: false, appId: &apos;wxe0e045abe94b1536&apos;, // 必填，公众号的唯一标识 timestamp: &apos;1512444969&apos;, // 必填，生成签名的时间戳 nonceStr: &apos;53ee6134-5e1e-495d-b2d4-edac4fbed2e2&apos;, // 必填，生成签名的随机串 signature: &quot;ca62c5cdcc0b88b62c9b52783d4dcf4aad141ad7&quot;, jsApiList: [&apos;onMenuShareTimeline&apos;, &apos;onMenuShareAppMessage&apos;,&apos;hideMenuItems&apos;] // 必填，需要使用的JS接口列表，所有JS接口列表见附录2&#125;);wx.ready(function()&#123; console.log(&quot;微信验证成功&quot;); wx.hideMenuItems(&#123; menuList: [&apos;menuItem:copyUrl&apos;,&apos;menuItem:originPage&apos;,&apos;menuItem:openWithQQBrowser&apos;,&apos;menuItem:openWithSafari&apos;,&apos;menuItem:share:qq&apos;,&apos;menuItem:share:weiboApp&apos;,&apos;menuItem:share:QZone&apos;] // 要隐藏的菜单项，只能隐藏“传播类”和“保护类”按钮，所有menu项见附录3 &#125;); //朋友圈 var title=&quot;中国文化网络电视直播集锦&quot;; var link=location.href; if(location.href.indexOf(&quot;sub&quot;)==-1)&#123; link+=&quot;&amp;sub=0&quot;; &#125; var imgUrl=location.protocol+location.host+&quot;/liveimage/zgwhwlds.jpg&quot; var desc=&quot;点击此处，开启精彩，第一时间观看全国群众文化活动高清直播。&quot;;wx.onMenuShareTimeline(&#123; title: title, // 分享标题 link: link, // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致 imgUrl: imgUrl, // 分享图标 success: function () &#123; layer_show(&quot;分享成功&quot;); &#125;, cancel: function () &#123; &#125;,fail:function()&#123; layer_show(&quot;分享失败&quot;); &#125;&#125;);//分享给朋友 wx.onMenuShareAppMessage(&#123; title: title, // 分享标题 desc: desc, // 分享描述 link: link, // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致 imgUrl: imgUrl, // 分享图标 type: &apos;&apos;, // 分享类型,music、video或link，不填默认为link dataUrl: &apos;&apos;, // 如果type是music或video，则要提供数据链接，默认为空 success: function () &#123; layer_show(&quot;分享成功&quot;); &#125;, cancel: function () &#123; &#125;,fail:function()&#123; layer_show(&quot;分享失败&quot;); &#125;&#125;);&#125;);wx.error(function(res)&#123;// config信息验证失败会执行error函数，如签名过期导致验证失败，具体错误信息可以打开config的debug模式查看，也可以在返回的res参数中查看，对于SPA可以在这里更新签名。console.log(&quot;微信验证失败&quot;);&#125;); (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"html","slug":"html","permalink":"https://austinxishou.github.io/tags/html/"}]},{"title":"Android源码环境集成预编译APK","date":"2017-11-01T07:55:41.223Z","path":"2017/11/01/android/android-source-code-prebuild-apk/","text":"系统集成任务 作为系统开发人员，经常需要集成第三方APK JAR包 so包等;面对不同的情况,就要熟悉Android-mk语法的各种LOCAL_XXX变量,这篇文章就是对不同情况的一个梳理总结。 首先需要了解 Node Package Manager (NPM): 阅读 Getting Started guide Modern JavaScript with ES2015/16: 阅读 Babel 的 Learn ES2015 guide webpack-simple 这个在 Egghead.io上的 高级 Webpack 课程 vue-loader //参考markdown格式 集成可执行bin文件例如:集成预编译好的busybox命令 123456789LOCAL_PATH:= $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := busybox LOCAL_MODULE_TAGS := optional LOCAL_MODULE_CLASS := EXECUTABLES LOCAL_SRC_FILES := busybox LOCAL_MODULE_PATH := $(PRODUCT_OUT)/system/xbin include $(BUILD_PREBUILT) 集成第三方jar包1234567891011121314LOCAL_PATH :=$(call my-dir) include $(CLEAR_VARS)LOCAL_MODULE_TAGS := optionalLOCAL_STATIC_JAVA_LIBRARIES :=zxing android-support-v4 android-support-v13 LOCAL_SRC_FILES :=$(call all-java-files-under, src) LOCAL_PACKAGE_NAME := SetInput2 LOCAL_CERTIFICATE := platform include $(BUILD_PACKAGE) include $(CLEAR_VARS) LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES :=zxing:libs/zxing-1.6-core.jar include $(BUILD_MULTI_PREBUILT) 集成不带so包的apk123456789101112LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE_TAGS := optional LOCAL_MODULE := rsota LOCAL_SRC_FILES := $(LOCAL_MODULE).apk LOCAL_MODULE_CLASS := APPS LOCAL_MODULE_PATH := $(PRODUCT_OUT)/system/app LOCAL_CERTIFICATE := platform LOCAL_MODULE_SUFFIX := .apk include $(BUILD_PREBUILT) 集成带so的apk12 在国内的Android生态中,所有的APP开发者都是一种流氓的心态,后台服务一大堆,还监听各种广播,导致用户根本不可能完全删除后台服务;有人说既然他们流氓,你不用他们就是,卸载掉啊!!哎,一些主流公司的APP,即使知道他流氓,还真的继续用它,比如支付宝\\微信等; 所以采用冻结的方法是最有效,最干净的,只是可惜 pm disable 这个权限Android并没有对普通应用开放,也是一个蛋疼的事情.Android生态也是,申请各种权限不需要root,反而关闭权限需要; 使用冻结APP的场景: 某些应用开启大量后台服务,导致系统响应缓慢,再不能卸载的情况下,冻结它; 某些不常用的APP,但是需要的时候重新下载又麻烦,冻结它; 某些应用后台大量更新数据,消耗流量,冻结它; 冻结app解冻后,保留所有应用数据,不用担心数据丢失,账号重新登录等; 主要代码实现冻结APP1234567891011121314public void disableApp(String appPackageName)&#123; try &#123; Process localProcess=Runtime.getRuntime().exec(\"su\"); String cmd=\"pm disable \"+appPackageName+\"\\n\"; DataOutputStream dataOutputStream=new DataOutputStream(localProcess.getOutputStream()); dataOutputStream.writeBytes(cmd); dataOutputStream.flush(); dataOutputStream.writeBytes(\"exit\\n\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 解冻APP123456789101112131415public void enableApp(String appPackageName)&#123; try &#123; Process localProcess=Runtime.getRuntime().exec(\"su\"); String cmd=\"pm enable \"+appPackageName+\"\\n\"; DataOutputStream dataOutputStream=new DataOutputStream(localProcess.getOutputStream()); dataOutputStream.writeBytes(cmd); dataOutputStream.flush(); dataOutputStream.writeBytes(\"exit\\n\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;(function(){ var bp = document.createElement(‘script’); var curProtocol = window.location.protocol.split(‘:’)[0]; if (curProtocol === ‘https’) { bp.src = ‘https://zz.bdstatic.com/linksubmit/push.js‘; } else { bp.src = ‘http://push.zhanzhang.baidu.com/push.js‘; } var s = document.getElementsByTagName(“script”)[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == &quot;http:&quot;) ? &quot;http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;:&quot;https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;; document.write(&apos;&lt;script src=&quot;&apos; + sozzsrc + &apos;&quot; id=&quot;sozz&quot;&gt;&lt;\\/script&gt;&apos;); })();","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"}]},{"title":"krpano入门资料","date":"2017-11-01T07:55:31.191Z","path":"2017/11/01/krpano/krpano-dev-doc/","text":"About 简介 Krpano 可以方便快速的构建全景场景或全景视频 Krpano官方网站Krpano 非官方中文文档720ku720yunNew720New720-Blog KRPano技术解密 Krpano 全景笔记 成熟商业网站tourvista hunyan 印象城 wowkb.com 全景展示系统 awesome krpanokrpano_tool_stereo Krpano 学习Embedding into HTML嵌入到HTML文档 XML文档 常用设置 小行星开场 加载动画 修改右键菜单 自定义热点 隐藏皮肤 添加动态热点 动态热点添加始终显示的文字 热点和或图层在鼠标点击或鼠标悬停时进入动态模式 拖拽热点 添加简单的全景视频 添加雨雪特效 自动旋转 无按钮控制的自动旋转 按钮控制的自动旋转 添加陀螺仪 场景过渡效果 隐藏显示热点 获取全景视频进度 Actions / Scripting 动态执行动作及脚本HTML5Javascript接口调用全景场景插入平面视频Krpano-videokrpano内嵌视频编辑插件 Krpano 精灵图（雪碧图 || sprites）完美解决方案 做全景播放器的时候，我们们通常会用到各种各样的图标，播放暂停啊，全屏VR啊什么的，如果每个图标都用单张图片来引入的话，势必会产生非常多的HTTP请求，而我们知道，过多的HTTP请求是页面性能的大杀器，还好 Krpano-xml 的 layer 提供了 crop 属性给我们，这个属性可以让我们对图片进行切割，只显示切割出来的区域，和 CSS 精灵图使用 background-image 和 background-position 来进行图片显示的方式非常类似。 下面是 krpano crop 属性示例：123456&lt;layer name=\"some-image-layer\" url=\"/foo/bar/image.png\" crop=\"0|0|64|64\" /&gt;//上述代码的意思就是，从 x=0 y=0 坐标开始，截取图片的64x64宽高的区域来显示。 现在我们有了 krpano 精灵图的使用方法，但是当你有很多张图片的时候，手动管理这些坐标点的位置是一件非常非常非常麻烦的事情。 CSS 精灵图已经有各种成熟的解决方案，比如博主喜欢的 gulp 插件 sprity ，它可以一键拼合零碎图片，并且生成 CSS/LESS/SASS 代码，可惜 krpano-xml 相对来说太小众了，我找遍 google 并没有找到一个好的解决方案，所以是时候造个轮子了:grin:。 Krpano-PluginsVideoplayerVideoplayer插件可用于在krpano内播放视频。作为屏幕上的平面layer元素使用：作为3D变形热点使用：作为全景视频使用： krpano工程问题 autorotate 自动旋转,自动播放 全景图在开启了自动旋转后,会自动在间隔时间内,加载其他scene,但是自动旋转却会停止; KEEPMOVING Autorotate 浏览器接受蓝牙控制 蓝牙作为信息输入 Web Bluetooth caniuse Web Bluetooth API 热点热点资源将多张图片合并成一个png序列图的小小工具-PngMergeHelper 密码: wf65将多张jpg图片合并成一个jpg序列图的小小工具-JPGCombine 密码: ecpr将gif分离成多个png的小工具-GIF分离器 密码: kti6 动态热点代码分析123456789101112131415161718192021222324&lt;action name=&quot;do_animation_hotspot&quot;&gt; &lt;!-- add attributes to the hotspot --&gt; registerattribute(xframes, calc((imagewidth / %1) BOR 0)); registerattribute(yframes, calc((imageheight / %2) BOR 0)); registerattribute(frames, calc(xframes * yframes)); registerattribute(frame, 0); set(crop, &apos;0|0|%1|%2&apos;); setinterval(calc(&apos;crop_anim_&apos; + name), calc(1.0 / %3), if(loaded, inc(frame); if(frame GE frames, if(onlastframe !== null, onlastframe() ); set(frame,0); ); mod(xpos, frame, xframes); div(ypos, frame, xframes); Math.floor(ypos); mul(xpos, %1); mul(ypos, %2); calc(crop, xpos + &apos;|&apos; + ypos + &apos;|%1|%2&apos;); , clearinterval(calc(&apos;crop_anim_&apos; + name)); ); );&lt;/action&gt; 动态热点上添加始终显示的文字插件ABS-获取绝对位置折叠菜单Accordion Menu Plugin 太阳光插件KRPANO太阳光插件 密码插件KRPANO密码插件 自动缩略图分组Auto Thumbs Plugin KRPANO二维码自动生成插件KRPANO二维码自动生成插件 高德地图导航插件高德地图导航插件 说一说插件说一说插件 多屏互动KRPANO多屏互动原理firstlook360 编辑器krtonducthang 参考Arliki 关注 易航智慧城市管理系统 zedcloud krpano-cms vrm-php krpano-editor-vuejs krpano-editor krpano-editor-js 测试工程搭建tour_testingserver.exe 导航图功能实现浏览器后退加载场景123456789//load pano on browser backbutton window.onpopstate = function (event) &#123; var scene = event.state.scene; var vars = &quot;view.hlookat=&quot; + event.state.view.hlookat; vars += &quot;&amp;view.vlookat=&quot;+ event.state.view.vlookat; vars += &quot;&amp;view.fov=&quot;+ event.state.view.fov; krpano().call(&quot;loadscene(&quot; + scene + &quot;,&quot; + vars + &quot;, MERGE, BLEND(1));&quot;); &#125;; 123456789101112function krpano() &#123; return document.getElementById(&quot;krpanoSWFObject&quot;);&#125;//called by scene loadingfunction krp_pushState(scene, spot) &#123; history.pushState(&#123; scene: scene, refspot:spot &#125;, scene, location.origin + &quot;/?ambiente=&quot; + scene);&#125;function krp_replaceState(scene, view) &#123; history.replaceState(&#123; scene: scene, view:view &#125;, scene, location.origin + &quot;/?ambiente=&quot; + scene);&#125; (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"krpano","slug":"krpano","permalink":"https://austinxishou.github.io/tags/krpano/"}]},{"title":"swiper fs","date":"2017-11-01T07:55:05.915Z","path":"2017/11/01/webdesign/Swipe-js-doc/","text":"ABoutswiper 中文swiper 英文(function(){ var bp = document.createElement(‘script’); var curProtocol = window.location.protocol.split(‘:’)[0]; if (curProtocol === ‘https’) { bp.src = ‘https://zz.bdstatic.com/linksubmit/push.js‘; } else { bp.src = ‘http://push.zhanzhang.baidu.com/push.js‘; } var s = document.getElementsByTagName(“script”)[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == &quot;http:&quot;) ? &quot;http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;:&quot;https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;; document.write(&apos;&lt;script src=&quot;&apos; + sozzsrc + &apos;&quot; id=&quot;sozz&quot;&gt;&lt;\\/script&gt;&apos;); })();","tags":[{"name":"swiper","slug":"swiper","permalink":"https://austinxishou.github.io/tags/swiper/"}]},{"title":"fileinput.js 实现文件上传功能","date":"2017-11-01T07:55:05.484Z","path":"2017/11/01/webdesign/FileinputJs/","text":"About-简介官方文档 file input插件功能如此强大，样式非常美观，并且支持上传文件预览，ajax同步或异步上传，拖曳文件上传等炫酷的功能; wuhuacong博客 Features-特性 fileinput 可以显示相关文件属性 可以进行上传文件按钮控制 提供预览功能 多文件选择 文件夹选择 H5文件内容预览 ajax上传 H5拖拽选择 Usage-应用 fileinput 可以支持两种方式上传: Form Submission表单提交,Ajax SubmissionAjax传输 表单提交表单提交,不需要 `uploadUrl` 属性,通过本地文件输入,然后表单格式封装数据; 优势: 配置简单明了,服务端通过读取 POSTED 数据获取文件; 缺点: 本地文件为只读,不可以通过代码进行修改和更新;比如:用户需要在已选择文件列表中,追加一个文件,就只能覆盖之前,重新选择; Ajax提交Ajax提交,必须提供 `uploadUrl` 属性,另外,如果设置了`uploadUrl` 属性,就认为是通过ajax方式上传; 优势: 提供更丰富的功能,比如拖拽上传,追加\\删除文件 Usage-使用Step 1加载相关资源 1234567891011121314151617181920212223242526272829&lt;!-- bootstrap 4.x is supported. You can also use the bootstrap css 3.3.x versions --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/css/bootstrap.min.css&quot;&gt;&lt;link href=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-fileinput/4.4.5/css/fileinput.min.css&quot; media=&quot;all&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;&lt;!-- if using RTL (Right-To-Left) orientation, load the RTL CSS file after fileinput.css by uncommenting below --&gt;&lt;!-- link href=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-fileinput/4.4.5/css/fileinput-rtl.min.css&quot; media=&quot;all&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /--&gt;&lt;!-- optionally uncomment line below if using a theme or icon set like font awesome (note that default icons used are glyphicons and `fa` theme can override it) --&gt;&lt;!-- link https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css media=&quot;all&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /--&gt;&lt;script src=&quot;https://code.jquery.com/jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;&lt;!-- piexif.min.js is only needed for restoring exif data in resized images and when you wish to resize images before upload. This must be loaded before fileinput.min.js --&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-fileinput/4.4.5/js/plugins/piexif.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;!-- sortable.min.js is only needed if you wish to sort / rearrange files in initial preview. This must be loaded before fileinput.min.js --&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-fileinput/4.4.5/js/plugins/sortable.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;!-- purify.min.js is only needed if you wish to purify HTML content in your preview for HTML files. This must be loaded before fileinput.min.js --&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-fileinput/4.4.5/js/plugins/purify.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;!-- popper.min.js below is needed if you use bootstrap 4.x. You can also use the bootstrap js 3.3.x versions without popper.min.js. --&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.11.0/umd/popper.min.js&quot;&gt;&lt;/script&gt;&lt;!-- bootstrap.min.js below is needed if you wish to zoom and preview file content in a detail modal dialog. bootstrap 4.x is supported. You can also use the bootstrap js 3.3.x versions. --&gt;&lt;script src=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/js/bootstrap.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;!-- the main fileinput plugin file --&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-fileinput/4.4.5/js/fileinput.min.js&quot;&gt;&lt;/script&gt;&lt;!-- optionally uncomment line below for loading your theme assets for a theme like Font Awesome (`fa`) --&gt;&lt;!-- script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-fileinput/4.4.5/themes/fa/theme.min.js&quot;&gt;&lt;/script --&gt;&lt;!-- optionally if you need translation for your language then include locale file as mentioned below --&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-fileinput/4.4.5/js/locales/LANG.js&quot;&gt;&lt;/script&gt; Step 2a初始化插件 12345// initialize with defaults$(&quot;#input-id&quot;).fileinput(); // with plugin options$(&quot;#input-id&quot;).fileinput(&#123;&apos;showUpload&apos;:false, &apos;previewFileType&apos;:&apos;any&apos;&#125;); Step 2b也可以通过H5的data属性,直接初始化: 设置CSS class=”file” 即可需要注意的是: 如果通过js初始化,则不能再添加file class类到CSS1&lt;input id=&quot;input-id&quot; type=&quot;file&quot; class=&quot;file&quot; data-preview-file-type=&quot;text&quot;&gt; Ajax 的同步异步上传Asynchronous-异步模式 异步模式为fileinput的默认模式,即 uploadAsync 属性为 true;在异步模式下,上传多文件时,可以并行的请求服务器处理,最大并行数可以通过 maxFileCount 属性设置; 服务端接收数据: file data: $_FILES[‘input-name’] 或者 $_FILES[‘file_data’] extra data: 通过 uploadExtraData 属性 传递额外数据,如:uploadExtraData={id:’kv-1’},则服务端可收到数据$_POST[‘id’] 服务端发送数据: 服务端必须返回json对象数据, error: string 显示错误信息,如:{error: ‘You are not allowed to upload such a file.’} initialPreview: array 标记上传文件,在异步模式下,只能返回一行,因为一次只收到一个文件,如: 123initialPreview: [ &apos;&lt;img src=&apos;/images/desert.jpg&apos; class=&apos;file-preview-image&apos; alt=&apos;Desert&apos; title=&apos;Desert&apos;&gt;&apos;, ], initialPreviewConfig: array 对 initialPreview 文件中特定属性,如: 123456789 initialPreviewConfig: [ &#123; caption: &apos;desert.jpg&apos;, width: &apos;120px&apos;, url: &apos;http://localhost/avatar/delete&apos;, // server delete action key: 100, extra: &#123;id: 100&#125; &#125;] initialPreviewThumbTags: array, 对预览标签内容进行修改,如: 12345678 // change thumbnail footer template// set initial preview template tagsinitialPreviewThumbTags:[ &#123; &apos;&#123;CUSTOM_TAG_NEW&#125;&apos;: &apos; &apos;, &apos;&#123;CUSTOM_TAG_INIT&#125;&apos;: &apos;&lt;span class=\\&apos;custom-css\\&apos;&gt;CUSTOM MARKUP&lt;/span&gt;&apos; &#125;]; append: boolean 表明是否追加内容到 initialPreview ,如果设置为false,则覆盖前面的initialPreview Synchronous-同步模式 同步模式下 uploadAsync 属性为 false;在这个模式下,所有文件会作为一个对象数组发送给服务端同样,也可以通过设置 maxFileCount 控制,一次最多发送文件数量 服务端接收数据: file data: $_FILES[‘input-name’] 或者 $_FILES[‘file_data’] extra data: 通过 uploadExtraData 属性 传递额外数据,如:uploadExtraData={id:’kv-1’},则服务端可收到数据$_POST[‘id’] 服务端发送数据: 服务端必须返回json对象数据, error: string 显示错误信息,如:{error: ‘You are not allowed to upload such a file.’} errorkeys: array 表明出错问题的key值 initialPreview: array 标记上传文件,如: 1234initialPreview: [ &apos;&lt;img src=&apos;/images/desert.jpg&apos; class=&apos;file-preview-image&apos; alt=&apos;Desert&apos; title=&apos;Desert&apos;&gt;&apos;, &apos;&lt;img src=&apos;/images/jellyfish.jpg&apos; class=&apos;file-preview-image&apos; alt=&apos;Jelly Fish&apos; title=&apos;Jelly Fish&apos;&gt;&apos;,], initialPreviewConfig: array 对 initialPreview 文件中特定属性,如: 123456789101112131415161718initialPreviewConfig: [ &#123; caption: &apos;desert.jpg&apos;, width: &apos;120px&apos;, url: &apos;http://localhost/avatar/delete&apos;, // server delete action key: 100, extra: &#123;id: 100&#125; &#125;, &#123; caption: &apos;jellyfish.jpg&apos;, width: &apos;120px&apos;, url: &apos;http://localhost/avatar/delete&apos;, // server delete action key: 101, extra: function() &#123; return &#123;id: $(&apos;#id&apos;).val()&#125;; &#125;, &#125;] initialPreviewThumbTags: array, 对预览标签内容进行修改,如: 123456789101112// change thumbnail footer template// set initial preview template tagsinitialPreviewThumbTags:[ &#123; &apos;&#123;CUSTOM_TAG_NEW&#125;&apos;: &apos; &apos;, &apos;&#123;CUSTOM_TAG_INIT&#125;&apos;: &apos;&lt;span class=\\&apos;custom-css\\&apos;&gt;CUSTOM MARKUP 1&lt;/span&gt;&apos; &#125;, &#123; &apos;&#123;CUSTOM_TAG_NEW&#125;&apos;: &apos; &apos;, &apos;&#123;CUSTOM_TAG_INIT&#125;&apos;: &apos;&lt;span class=\\&apos;custom-css\\&apos;&gt;CUSTOM MARKUP 2&lt;/span&gt;&apos; &#125;]; append: boolean 表明是否追加内容到 initialPreview ,如果设置为false,则覆盖前面的initialPreview 插件配置选项Events-插件事件Method-插件方法### getFileStack 1var files = $(&apos;#input-id&apos;).fileinput(&apos;getFileStack&apos;); // returns file list selected (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://austinxishou.github.io/tags/JavaScript/"}]},{"title":"人工智能学习路径","date":"2017-11-01T07:53:58.885Z","path":"2017/11/01/AI/AI-learning-road/","text":"学习路径和资料 最佳AI /机器学习资源索引 Github开源资料 TensorFlow和深度学习入门教程 Getting started with machine learning 社区和博客 CSDN人工智能专栏 Meta Guides RocAlphaGo MAST 通过人工智能分析代码质量 ## awesome-machine-learningawesome-machine-learning-cn 机器学习资源大全中文版awesome-artificial-intelligence 人工智能机器学习相关的Awesome系列 (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"AI","slug":"AI","permalink":"https://austinxishou.github.io/tags/AI/"}]},{"title":"windows文件夹右键直接打开sublime","date":"2017-11-01T07:52:13.057Z","path":"2017/11/01/python/win-director-sublime-open/","text":"说明 在web学习或开发中，会接触到各种Demo代码或者Github上的开源代码。要是每次都打开Sublime Text，然后把文件夹拖到里面，以打开一个文件夹，无疑是一件繁琐的事情。当然，你也可以使用Sublime Text里的project功能，不过个人觉得还是不够便捷。为什么不能在文件夹的右键菜单上添加一个”用Sublime Text打开“这样的菜单，直接打开呢？ok，懒人的方法来了。 一般建立 “Open With Sublime Text” 右键菜单的办法是导入注册表文件，但是你可能使用的是 Sublime Text 2 的 Portable 版本，还需要修改 .reg 文件中 sublime_text.exe 的路径，这里给出更好的办法。 方法 把以下保存成 .bat 文件 12345678910111213141516set ST_BIN=\"\"\"%~dp0sublime_text.exe\"\"\"reg add \"HKCR\\*\\shell\\Sublime Text 2\" /ve /d \"Open with Sublime Text 2\" /freg add \"HKCR\\*\\shell\\Sublime Text 2\" /v \"Icon\" /d \"%ST_BIN%,0\" /freg add \"HKCR\\*\\shell\\Sublime Text 2\\command\" /ve /d \"%ST_BIN% \"\"\"%%1\"\"\"\" /freg add \"HKCR\\Directory\\shell\\Sublime Text 2\" /ve /d \"Open Folder as Sublime Project\" /freg add \"HKCR\\Directory\\shell\\Sublime Text 2\" /v \"Icon\" /d \"%ST_BIN%,0\" /freg add \"HKCR\\Directory\\shell\\Sublime Text 2\\command\" /ve /d \"%ST_BIN% \"\"\"%%V\"\"\"\" /freg add \"HKCR\\Directory\\Background\\shell\\Sublime Text 2\" /ve /d \"Open Folder as Sublime Project\" /freg add \"HKCR\\Directory\\Background\\shell\\Sublime Text 2\" /v \"Icon\" /d \"%ST_BIN%,0\" /freg add \"HKCR\\Directory\\Background\\shell\\Sublime Text 2\\command\" /ve /d \"%ST_BIN% \"\"\"%%V\"\"\"\" /f@echo.@pause 放到 sublime_text.exe 所在目录下 以管理员身份运行该 .bat 效果 在文件上点右键会出现 “Open with Sublime Text 2” 在文件夹或资源管理器的背景空白处点右键会出现 “Open Folder as Sublime Project” 带有 /v “Icon” 的那几行是增加菜单项前的图标，如果你不需要可以删掉它 (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"python","slug":"python","permalink":"https://austinxishou.github.io/tags/python/"},{"name":"sublime","slug":"sublime","permalink":"https://austinxishou.github.io/tags/sublime/"}]},{"title":"hexo 插件推荐收藏","date":"2017-11-01T07:52:12.916Z","path":"2017/11/01/webdesign/hexo-plugin/","text":"Hexo七牛同步插件Hexo七牛同步插件 简介 这是一个hexo插件， 可以让你在文档中入嵌存储在七牛上的图片、JS、CSS类型的静态文件。 你可以不用手动上传文件到七牛，插件会自动帮你将本地目录的文件同步到七牛。 TF-IDF自动提取摘要TF-IDF自动提取摘要 简介 根据文章内容,自动提取文章摘要 百度链接自动提交hexo-baidu-url-push 简介 自动推送是百度站长平台为提高站点新增网页发现速度推出的工具，安装自动推送JS代码的网页，在页面被访问时，页面URL将立即被推送给百度。 百度链接主动推送hexo-baidu-url-submit 简介 主动推送Hexo博客新链接至百度搜索引擎，解决百度爬虫被禁止访问的问题，提升网站收录质量和速度。(function(){ var bp = document.createElement(‘script’); var curProtocol = window.location.protocol.split(‘:’)[0]; if (curProtocol === ‘https’) { bp.src = ‘https://zz.bdstatic.com/linksubmit/push.js‘; } else { bp.src = ‘http://push.zhanzhang.baidu.com/push.js‘; } var s = document.getElementsByTagName(“script”)[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == &quot;http:&quot;) ? &quot;http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;:&quot;https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;; document.write(&apos;&lt;script src=&quot;&apos; + sozzsrc + &apos;&quot; id=&quot;sozz&quot;&gt;&lt;\\/script&gt;&apos;); })();","tags":[{"name":"hexo","slug":"hexo","permalink":"https://austinxishou.github.io/tags/hexo/"}]},{"title":"youtube-dl视频下载工具使用","date":"2017-11-01T07:52:12.833Z","path":"2017/11/01/python/youtube-dl-cmd-usage/","text":"About-简介通常用于下载网站视频的工具有youtube-dl和You-Get;经过测试发现,下载国外视频用youtube-dl比较方便,下载国内视频用You-Get; 不过,由于youtube-dl支持的是Python 2.6, 2.7, or 3.2+,相对来说会方便很多; 这篇文章主要介绍youtube-dl 命令行工具的使用,以及如何在python代码中调用外部 youtube-dl 命令,执行下载操作; youtube-dl官网youtube-dlGithub Download and Install-下载安装 方式一 下载Windows exe程序使用 从官网下载youtube-dl.exe 然后放在电脑的任意目录下即可使用;可以通过下面的命令来更新youtube-dl 方式二 直接使用命令行来安装 在安装了Python之后,按Win+R键打开运行，输入cmd，再输入下面的代码即可自动下载安装youtube-dl 12pip install youtube-dl //直接安装youtube-dlpip install --upgrade youtube-dl //安装youtube-dl并更新 Usage-使用命令格式为: 1youtube-dl [OPTIONS] URL [URL...] 常用的选项有: 12345678910111213141516-h, --help 打印帮助--version 显示版本-U, --update 升级-i, --ignore-errors 忽略错误继续执行下载操作--abort-on-error 出现错误中断下载--dump-user-agent 显示当前的用户代理信息--list-extractors 显示所有的支持解析--extractor-descriptions 显示所有的支持解析的描述--force-generic-extractor 使用通用的解析器强制下载--default-search PREFIX 对未校验的链接使用默认的前缀--ignore-config 忽略配置文件--config-location PATH 使用本地的配置文件--flat-playlist 不解析播放列表,仅仅显示--mark-watched 标记视频已看过--no-mark-watched 不标记已观看--no-color 忽略颜色输出 网络 选项 12345--proxy URL 使用指定的代理--socket-timeout SECONDS 设置超时时间--source-address IP 绑定客户端IP地址-4, --force-ipv4 设置所有链接为 IPv4-6, --force-ipv6 设置所有链接为 IPv6 视频选择 12345678910111213141516171819--playlist-start NUMBER 播放列表起始位置(默认为 1)--playlist-end NUMBER 播放列表结束位置(默认为 最后)--playlist-items ITEM_SPEC 播放列表特定选项进行下载--match-title REGEX 只下载匹配相应标题的视频--reject-title REGEX 跳过已经看过的视频--max-downloads NUMBER 设置最大下载数量--min-filesize SIZE 不下载视频大小小于设定值的视频--max-filesize SIZE 不下载视频大小大于设定值的视频--date DATE 只下载更新日期为DATE的视频--datebefore DATE 只下载更新日期早于DATE的视频--dateafter DATE 只下载更新日期晚于DATE的视频--min-views COUNT 不下载视频数量小于设定值的视频--max-views COUNT 不下载视频数量大于设定值的视频--match-filter FILTER 设置通用的视频过滤器--no-playlist 如果连接指向视频和播放列表,只下载视频--yes-playlist 如果连接指向视频和播放列表,只下载播放列表--age-limit YEARS 只下载指定年份的视频--download-archive FILE 只下载archive文件中没有的视频--include-ads 广告视频也一起下载 下载选项 123456789101112131415-r, --limit-rate RATE 设置下载最大sulv-R, --retries RETRIES 最大的尝试次数--fragment-retries RETRIES fragment窗口最大的尝试次数--skip-unavailable-fragments 跳过无效的fragment窗口--abort-on-unavailable-fragment 当某些窗口失效时,停止下载--buffer-size SIZE 设置下载缓存--no-resize-buffer 不要进行下载缓存的自适应--playlist-reverse 反向下载播放列表视频--playlist-random 随机下载播放列表视频--xattr-set-filesize 设置文件xattr属性大小--hls-prefer-native 使用HLS下载器替代 ffmpeg --hls-prefer-ffmpeg 使用ffmpeg下载器替代HLS--external-downloader COMMAND 使用外部下载器,目前支持: aria2c,avconv,axel,curl,ffmpeg,httpie,wget--external-downloader-args ARGS 设置外部下载器参数 文件系统选项 123456789101112131415161718-a, --batch-file FILE 下载指定文件包含的url链接视频--id 文件名使用视频ID值-o, --output TEMPLATE 设置输出临时文件名--autonumber-start NUMBER 指定开始数值for %(autonumber)s(默认为1)--restrict-filenames 限制文件名使用ASCII编码-w, --no-overwrites 不要覆盖文件-c, --continue 强制恢复下载文件--no-continue 不要恢复下载文件--no-part 不要使用.part 文件 - 直接写入到输出文件--no-mtime 不要使用最后的修改时间--write-description 输出视频描述到指定文件--write-info-json 输出视频元数据metadata 到.info.json 文件--write-annotations 输出视频标记信息到.annotations.xml 文件--load-info-json FILE 载入视频信息文件--cookies FILE 缓存文件--cache-dir DIR 指定缓存文件目录--no-cache-dir 关闭文件系统缓存--rm-cache-dir 删除所有文件系统缓存文件 缩略图选项 123--write-thumbnail 下载缩略图--write-all-thumbnails 下载所有格式的缩略图--list-thumbnails 仅仅显示缩略图列表 (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"python","slug":"python","permalink":"https://austinxishou.github.io/tags/python/"},{"name":"youtube-dl","slug":"youtube-dl","permalink":"https://austinxishou.github.io/tags/youtube-dl/"}]},{"title":"python多线程以及执行本地命令技术要点","date":"2017-11-01T07:52:12.660Z","path":"2017/11/01/python/python-subprocess-popen-usage/","text":"subprocess-About-简介subprocess 模块用来创建新的进程，连接到其stdin、stdout、stderr管道并获取它们的返回码。 subprocess模块的出现是为了替代旧模块及函数：os.system、os.spawn*、os.popen*、popen2.*、commands.*。 强烈建议POSIX用户（Linux、BSD等）安装并使用较新的subprocess32模块，而不是Python 2.7自带的subprocess。 推荐用户使用call、check_call和check_output这三个快捷函数，在无法满足需求的时候才使用更高级的Popen接口。 subprocess.call-调用call函数可以认为是对popen和wait的分装，直接对call函数传入要执行的命令行，将命令行的退出code返回。 运行由args参数提供的命令，等待命令执行结束并返回返回码。args参数由字符串形式提供且有多个命令参数时， 需要提供shell=True参数： 1subprocess.call(args, *, stdin= None, stdout = None, stderr = None, shell = False) 注意不要为stdout和stderr参数赋值subprocess.PIPE，如果子进程输出量较多会造成死锁，这两个参数可以赋值为subprocess.STDOUT打印到屏幕或者赋值为一个文件对象将输出写入文件： 123//test.py-示例import subprocess as spsp.call('python run.py', shell = True, stdin=open('fake_input', 'r'), stdout=open('result', 'w')) subprocess.check_call-调用返回确认与call方法类似，不同在于如果命令行执行成功，check_call返回返回码0，否则抛出subprocess.CalledProcessError异常。 1subprocess.check_call(args, *, stdin = None, stdout = None, stderr = None, shell = False) subprocess.check_output-调用输出确认在子进程执行命令，以字符串形式返回执行结果的输出。如果子进程退出码不是0，抛出subprocess.CalledProcessError异常，异常的output字段包含错误输出： 1subprocess.check_output(args, *, stdin = None, stderr = None, shell = False, universal_newlines = False) subprocess.Popen 管道调用开启新进程Popen启动新的进程与父进程并行执行，默认父进程不等待新进程结束。 12345def TestPopen(): import subprocess p=subprocess.Popen(\"dir\",shell=True) for i in range(250) : print (\"other things\") 等待子进程结束p.wait函数使得父进程等待新创建的进程运行结束，然后再继续父进程的其他任务。且此时可以在p.returncode中得到新进程的返回值。 12345678def TestWait(): import subprocess import datetime print (datetime.datetime.now()) p=subprocess.Popen(\"sleep 10\",shell=True) p.wait() print (p.returncode) print (datetime.datetime.now()) poll等待p.poll函数可以用来检测新创建的进程是否结束。 12345678910111213def TestPoll(): import subprocess import datetime import time print (datetime.datetime.now()) p=subprocess.Popen(\"sleep 10\",shell=True) t = 1 while(t &lt;= 5): time.sleep(1) p.poll() print (p.returncode) t+=1 print (datetime.datetime.now()) 结束进程p.kill或p.terminate用来结束创建的新进程，在windows系统上相当于调用TerminateProcess()，在posix系统上相当于发送信号SIGTERM和SIGKILL。 12345678910def TestKillAndTerminate(): p=subprocess.Popen(\"notepad.exe\") t = 1 while(t &lt;= 5): time.sleep(1) t +=1 p.kill() #p.terminate() print (\"new process was killed\") 与子进程交互p.communicate可以与新进程交互，但是必须要在popen构造时候将管道重定向。 123456789101112131415161718192021222324def TestCommunicate(): import subprocess cmd = \"dir\" p=subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT) (stdoutdata, stderrdata) = p.communicate() if p.returncode != 0: print (cmd + \"error !\") #defaultly the return stdoutdata is bytes, need convert to str and utf8 for r in str(stdoutdata,encoding='utf8' ).split(\"\\n\"): print (r) print (p.returncode)def TestCommunicate2(): import subprocess cmd = \"dir\" #universal_newlines=True, it means by text way to open stdout and stderr p = subprocess.Popen(cmd, shell=True, universal_newlines=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT) curline = p.stdout.readline() while(curline != \"\"): print (curline) curline = p.stdout.readline() p.wait() print (p.returncode)(function(){ var bp = document.createElement(‘script’); var curProtocol = window.location.protocol.split(‘:’)[0]; if (curProtocol === ‘https’) { bp.src = ‘https://zz.bdstatic.com/linksubmit/push.js‘; } else { bp.src = ‘http://push.zhanzhang.baidu.com/push.js‘; } var s = document.getElementsByTagName(“script”)[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == &quot;http:&quot;) ? &quot;http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;:&quot;https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;; document.write(&apos;&lt;script src=&quot;&apos; + sozzsrc + &apos;&quot; id=&quot;sozz&quot;&gt;&lt;\\/script&gt;&apos;); })();","tags":[{"name":"python","slug":"python","permalink":"https://austinxishou.github.io/tags/python/"},{"name":"scrapy","slug":"scrapy","permalink":"https://austinxishou.github.io/tags/scrapy/"}]},{"title":"python结巴分词jieba技术集成应用说明","date":"2017-11-01T07:52:12.608Z","path":"2017/11/01/python/python-jieba-fenci-usage/","text":"About-简介说明jieba-Github 结巴支持三种分词模式: 精确模式，试图将句子最精确地切开，适合文本分析； 全模式，把句子中所有的可以成词的词语都扫描出来, 速度非常快，但是不能解决歧义； 搜索引擎模式，在精确模式的基础上，对长词再次切分，提高召回率，适合用于搜索引擎分词。 结巴支持繁体分词 结巴支持自定义词典 算法实现简析 基于Trie树结构实现高效的词图扫描，生成句子中汉字所有可能成词情况所构成的有向无环图（DAG)采用了动态规划查找最大概率路径, 找出基于词频的最大切分组合对于未登录词，采用了基于汉字成词能力的HMM模型，使用了Viterbi算法 Install-安装 Python 2.x 下的安装 1pip install jieba 或者进行下载后自行引入; Python 3.x 下的安装 目前master分支是只支持Python2.x 的 Python3.x 版本的分支也已经基本可用： https://github.com/fxsjy/jieba/tree/jieba3k 123git clone https://github.com/fxsjy/jieba.git git checkout jieba3k python setup.py install Usage-应用分词函数: jieba.cut jieba.cut方法接受两个输入参数: + 1) 第一个参数为需要分词的字符串 + 2）cut_all参数用来控制是否采用全模式 jieba.cut_for_search方法接受一个参数： + 需要分词的字符串,该方法适合用于搜索引擎构建倒排索引的分词，粒度比较细 注意：待分词的字符串可以是gbk字符串、utf-8字符串或者unicode jieba.cut以及jieba.cut_for_search返回的结构都是一个可迭代的generator，可以使用for循环来获得分词后得到的每一个词语(unicode)，也可以用list(jieba.cut(…))转化为list 代码示例 12345678910#encoding=utf-8 import jieba seg_list = jieba.cut(\"我来到北京清华大学\", cut_all=True) print \"Full Mode:\", \"/ \".join(seg_list) # 全模式 seg_list = jieba.cut(\"我来到北京清华大学\", cut_all=False) print \"Default Mode:\", \"/ \".join(seg_list) # 精确模式 seg_list = jieba.cut(\"他来到了网易杭研大厦\") # 默认是精确模式 print \", \".join(seg_list) seg_list = jieba.cut_for_search(\"小明硕士毕业于中国科学院计算所，后在日本京都大学深造\") # 搜索引擎模式 print \", \".join(seg_list) 输出为:12345Output: 【全模式】: 我/ 来到/ 北京/ 清华/ 清华大学/ 华大/ 大学 【精确模式】: 我/ 来到/ 北京/ 清华大学 【新词识别】：他, 来到, 了, 网易, 杭研, 大厦 (此处，“杭研”并没有在词典中，但是也被Viterbi算法识别出来了) 【搜索引擎模式】： 小明, 硕士, 毕业, 于, 中国, 科学, 学院, 科学院, 中国科学院, 计算, 计算所, 后, 在, 日本, 京都, 大学, 日本京都大学, 深造 添加自定义词典 开发者可以指定自己自定义的词典，以便包含jieba词库里没有的词。虽然jieba有新词识别能力，但是自行添加新词可以保证更高的正确率 1jieba.load_userdict(file_name) # file_name为自定义词典的路径 词典格式和dict.txt一样，一个词占一行；每一行分三部分，一部分为词语，另一部分为词频，最后为词性（可省略），用空格隔开范例：1234567自定义词典：云计算 5 李小福 2 nr 创新办 3 i easy_install 3 eng 好用 300 韩玉赏鉴 3 nz 12345678910111213141516171819202122232425262728#encoding=utf-8 import sys sys.path.append(\"../\") import jieba jieba.load_userdict(\"userdict.txt\") import jieba.posseg as pseg test_sent = \"李小福是创新办主任也是云计算方面的专家;\" test_sent += \"例如我输入一个带“韩玉赏鉴”的标题，在自定义词库中也增加了此词为N类型\" words = jieba.cut(test_sent) for w in words: print w result = pseg.cut(test_sent) for w in result: print w.word, \"/\", w.flag, \", \", print \"\\n========\" terms = jieba.cut('easy_install is great') for t in terms: print t print '-------------------------' terms = jieba.cut('python 的正则表达式是好用的') for t in terms: print t 之前： 李小福 / 是 / 创新 / 办 / 主任 / 也 / 是 / 云 / 计算 / 方面 / 的 / 专家 / 加载自定义词库后： 李小福 / 是 / 创新办 / 主任 / 也 / 是 / 云计算 / 方面 / 的 / 专家 /“通过用户自定义词典来增强歧义纠错能力” 关键词提取1jieba.analyse.extract_tags(sentence,topK) #需要先import jieba.analyse 说明 setence为待提取的文本 topK为返回几个TF/IDF权重最大的关键词，默认值为20 代码示例 （关键词提取） 12345678910111213141516171819202122232425262728293031import sys sys.path.append('../') import jieba import jieba.analyse from optparse import OptionParser USAGE = \"usage: python extract_tags.py [file name] -k [top k]\" parser = OptionParser(USAGE) parser.add_option(\"-k\", dest=\"topK\") opt, args = parser.parse_args() ‘’‘ if len(args) &lt; 1: print USAGE sys.exit(1) file_name = args[0] ’‘’ file_name=u\"D:XXX/xx/xx.txt\" if opt.topK is None: topK = 10 else: topK = int(opt.topK) content = open(file_name, 'rb').read() tags = jieba.analyse.extract_tags(content, topK=topK) print \",\".join(tags) 词性标注 标注句子分词后每个词的词性，采用和ictclas兼容的标记法 用法示例 123456789&gt;&gt;&gt; import jieba.posseg as pseg &gt;&gt;&gt; words = pseg.cut(\"我爱北京天安门\") &gt;&gt;&gt; for w in words: ... print w.word, w.flag ... 我 r 爱 v 北京 ns 天安门 ns 并行分词 原理：将目标文本按行分隔后，把各行文本分配到多个python进程并行分词，然后归并结果，从而获得分词速度的可观提升基于python自带的multiprocessing模块，目前暂不支持windows 12jieba.enable_parallel(4) # 开启并行分词模式，参数为并行进程数 jieba.disable_parallel() # 关闭并行分词模式 用法示例 1234567891011121314151617181920import urllib2 import sys,time import sys sys.path.append(\"../../\") import jieba jieba.enable_parallel(4) url = sys.argv[1] content = open(url,\"rb\").read() t1 = time.time() words = list(jieba.cut(content)) t2 = time.time() tm_cost = t2-t1 log_f = open(\"1.log\",\"wb\") for w in words: print &gt;&gt; log_f, w.encode(\"utf-8\"), \"/\" , print 'speed' , len(content)/tm_cost, \" bytes/second\" 实验结果：在4核3.4GHz Linux机器上，对金庸全集进行精确分词，获得了1MB/s的速度，是单进程版的3.3倍。其他词典 占用内存较小的词典文件 https://github.com/fxsjy/jieba/raw/master/extra_dict/dict.txt.small 支持繁体分词更好的词典文件 https://github.com/fxsjy/jieba/raw/master/extra_dict/dict.txt.big 下载你所需要的词典，然后覆盖jieba/dict.txt 即可或者用jieba.set_dictionary(‘data/dict.txt.big’) 模块初始化机制的改变:lazy load （从0.28版本开始）jieba采用延迟加载，”import jieba”不会立即触发词典的加载，一旦有必要才开始加载词典构建trie。如果你想手工初始jieba，也可以手动初始化。 Tokenize：返回词语在原文的起始位置 注意，输入参数只接受unicode ChineseAnalyzer for Whoosh搜索引擎 引用： from jieba.analyse import ChineseAnalyzer用法示例：https://github.com/fxsjy/jieba/blob/master/test/test_whoosh.py (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"python","slug":"python","permalink":"https://austinxishou.github.io/tags/python/"},{"name":"jieba","slug":"jieba","permalink":"https://austinxishou.github.io/tags/jieba/"}]},{"title":"游戏站推荐","date":"2017-11-01T07:52:12.524Z","path":"2017/11/01/killtime/game-resource-collection/","text":"拼命玩游戏 : http://wanga.me/ ArmorGames : http://armorgames.com/ u77汉化 : http://www.u77.com/ taptap : https://www.taptap.com/ (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"killtime","slug":"killtime","permalink":"https://austinxishou.github.io/tags/killtime/"},{"name":"football","slug":"football","permalink":"https://austinxishou.github.io/tags/football/"}]},{"title":"IT技术站点收集","date":"2017-11-01T07:52:12.424Z","path":"2017/11/01/killtime/ittech-site-collection/","text":"Android Android开发中文站 codeKK 稀土掘金 泡在网上的日子 代码片段 DevStore 技术周报 Trinea webdesign-worldpress perishablepress cssflow webappers smashingmagazine C/C++ (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"killtime","slug":"killtime","permalink":"https://austinxishou.github.io/tags/killtime/"},{"name":"ittech","slug":"ittech","permalink":"https://austinxishou.github.io/tags/ittech/"}]},{"title":"pyinstaller打包可执行文件命令工具使用","date":"2017-11-01T07:52:11.919Z","path":"2017/11/01/python/pyinstaller-winexe-usage-guide/","text":"简介安装与说明pyinstall官网http://www.111cn.net/phper/python/122937.htm 使用命令格式为1pyinstaller [options] script [script ...] | specfile 所以最基本的使用为:1pyinstaller myscript.py Writes myscript.spec in the same folder as the script. Creates a folder build in the same folder as the script if it does not exist. Writes some log files and working files in the build folder. Creates a folder dist in the same folder as the script if it does not exist. Writes the myscript executable folder in the dist folder. 更深入的使用得配合各种选项和myscript.spec文件 选项Spec 文件UPX压缩可执行包默认生成的python可执行文件有点大，可以通过upx程序进行压缩，upx程序的主页位于：https://upx.github.io/ ，目前windows版的最新upx为upx391w.zip ，下载后，将其中的upx.exe文件放到C:\\Python27目录下（python可执行程序的安装目录），再次执行的时候，可以跟上–upx进行压缩。默认存在时不指定也会进行压缩，生成exe文件时，在其日志中可以发现如下内容： ###加密 python 可执行文件Encrypting Python Bytecode 跨平台打包windows 安装包的版本文件pyi-grab_version 命令pyi-grab_version executable_with_version_resource 123456789--version-file='file_version_info.txt', --version-file file_version_info.txt,icon icon='news_xishou.ico',import loggingtry: 1/0except Exception as e: logging.exception(\"message\") 运行时信息当应用运行时,有可能从以下三个地方获取可访问的文件: 当前程序的文件夹内,比如我们添加的 Adding Data Files 用户在使用时放置在程序文件夹内 用户当前工作目录 使用 file and sys._MEIPASS在Python中,__file__ 表示当前脚本文件的路径.当程序包文件运行时,加载器会设置sys.frozen变量和把运行文件的绝对路径保存在 sys._MEIPASS 变量中; 在 一个文件夹安装包的模式,这个路径指向文件夹;在一个文件的模式中,这个路径指向 _MEIxxxxxx 临时文件夹 使用 sys.executable and sys.argv[0]在 python 运行时, sys.executable 表示当前程序的路径,一般为python解释的路径,如:C:\\Python27\\python.exe 但是在 安装包运行,虽然也表示运行程序的路径,但已经不是 python解释器的路径,而是程序加载器bootloader所以这个变量提供了一个可靠的路径标识当前用户使用的路径位置; 当用户是使用快捷键运行时,sys.argv[0]标识快捷键的位置,sys.executable仍然是可执行文件真实存在的位置 当需要提供不同快捷键运行不同功能时,就可以使用该参数os.path.basename(sys.argv[0]) 示例程序123456789101112131415#!/usr/bin/python3import sys, osfrozen = 'not'if getattr(sys, 'frozen', False): # we are running in a bundle frozen = 'ever so' bundle_dir = sys._MEIPASSelse: # we are running in a normal Python environment bundle_dir = os.path.dirname(os.path.abspath(__file__))print( 'we are',frozen,'frozen')print( 'bundle dir is', bundle_dir )print( 'sys.argv[0] is', sys.argv[0] )print( 'sys.executable is', sys.executable )print( 'os.getcwd is', os.getcwd() ) LD_LIBRARY_PATH / LIBPATH considerations在类Unix系统中,表示库搜索路径 使用 Spec 文件使用spec文件的场景: 打包数据文件 加载运行时库文件 增加Python运行时配置参数 打包跨程序的安装包 单独生成spec文件1pyi-makespec options name.py [other scripts ...] 当生成并修改好spec文件后,运行1pyinstaller options name.spec 当你使用spec文件时,绝大多数的选项参数已经在spec文件中给出,这些参数不会改变;也就说你在命令行中给出的选项参数会被spec文件的参数覆盖,不起作用 只有下述几个参数才是有意义的–upx-dir=–distpath=–workpath=–noconfirm–ascii spec 文件的结构1234567891011121314block_cipher = Nonea = Analysis([&apos;minimal.py&apos;], pathex=[&apos;/Developer/PItests/minimal&apos;], binaries=None, datas=None, hiddenimports=[], hookspath=None, runtime_hooks=None, excludes=None, cipher=block_cipher)pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)exe = EXE(pyz,... )coll = COLLECT(...) 由四部分组成: Analysis, PYZ, EXE and COLLECT. 向压缩包中添加文件添加文件 12345678added_files = [ ( &apos;/mygame/sfx/*.mp3&apos;, &apos;sfx&apos; ), ( &apos;src/README.txt&apos;, &apos;.&apos; ) ] a = Analysis(... datas = added_files, ... ) 可以添加整个文件夹12345added_files = [ ( &apos;/mygame/data&apos;, &apos;data&apos; ), ( &apos;/mygame/sfx/*.mp3&apos;, &apos;sfx&apos; ), ( &apos;src/README.txt&apos;, &apos;.&apos; ) ] /mygame/data整个文件夹复制到data目录 在模块中使用 data文件pkgutils.get_data() 12import pkgutilhelp_bin = pkgutil.get_data( &apos;helpmod&apos;, &apos;help_data.txt&apos; ) 添加可执行文件 增加Python运行时参数123v to write a message to stdout each time a module is initialized.u for unbuffered stdio.W and an option to change warning behavior: W ignore or W once or W error. (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"python","slug":"python","permalink":"https://austinxishou.github.io/tags/python/"},{"name":"pyinstaller","slug":"pyinstaller","permalink":"https://austinxishou.github.io/tags/pyinstaller/"}]},{"title":"Android 冻结APP","date":"2017-11-01T07:52:11.216Z","path":"2017/11/01/android/android-apk-disable/","text":"功能说 在国内的Android生态中,所有的APP开发者都是一种流氓的心态,后台服务一大堆,还监听各种广播,导致用户根本不可能完全删除后台服务;有人说既然他们流氓,你不用他们就是,卸载掉啊!!哎,一些主流公司的APP,即使知道他流氓,还真的继续用它,比如支付宝\\微信等; 所以采用冻结的方法是最有效,最干净的,只是可惜 pm disable 这个权限Android并没有对普通应用开放,也是一个蛋疼的事情.Android生态也是,申请各种权限不需要root,反而关闭权限需要; 使用冻结APP的场景: 某些应用开启大量后台服务,导致系统响应缓慢,再不能卸载的情况下,冻结它; 某些不常用的APP,但是需要的时候重新下载又麻烦,冻结它; 某些应用后台大量更新数据,消耗流量,冻结它; 冻结app解冻后,保留所有应用数据,不用担心数据丢失,账号重新登录等; 主要代码实现冻结APP1234567891011121314public void disableApp(String appPackageName)&#123; try &#123; Process localProcess=Runtime.getRuntime().exec(\"su\"); String cmd=\"pm disable \"+appPackageName+\"\\n\"; DataOutputStream dataOutputStream=new DataOutputStream(localProcess.getOutputStream()); dataOutputStream.writeBytes(cmd); dataOutputStream.flush(); dataOutputStream.writeBytes(\"exit\\n\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 解冻APP123456789101112131415public void enableApp(String appPackageName)&#123; try &#123; Process localProcess=Runtime.getRuntime().exec(\"su\"); String cmd=\"pm enable \"+appPackageName+\"\\n\"; DataOutputStream dataOutputStream=new DataOutputStream(localProcess.getOutputStream()); dataOutputStream.writeBytes(cmd); dataOutputStream.flush(); dataOutputStream.writeBytes(\"exit\\n\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;(function(){ var bp = document.createElement(‘script’); var curProtocol = window.location.protocol.split(‘:’)[0]; if (curProtocol === ‘https’) { bp.src = ‘https://zz.bdstatic.com/linksubmit/push.js‘; } else { bp.src = ‘http://push.zhanzhang.baidu.com/push.js‘; } var s = document.getElementsByTagName(“script”)[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == &quot;http:&quot;) ? &quot;http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;:&quot;https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;; document.write(&apos;&lt;script src=&quot;&apos; + sozzsrc + &apos;&quot; id=&quot;sozz&quot;&gt;&lt;\\/script&gt;&apos;); })();","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"}]},{"title":"python 多线程实践","date":"2017-11-01T07:52:10.999Z","path":"2017/11/01/python/python-threading-module-queue-usage/","text":"多线程 threading模块 Python中的多线程操作有两种方式： 函数式(thread)和继承(threading.Threading)式 python是支持多线程的，并且是native的线程。主要是通过thread和threading这两个模块来实现的。thread是比较底层的模 块，threading是对thread做了一些包装的，可以更加方便的被使用。 函数式 1234def function adbc()threading.Thread(target=fun,args=(a,b))或者thread.start_new_thread(fun,(a,b))启动线程 守护进程 如果你的主线程在退出的时候，不用等待那些子线程完成，那就设置这些线程的 daemon 属性。即，在线程开始 thread.start()之前，调用setDeamon()函数，设定线程的daemon标志。thread.setDaemon(True)就表示这个线程“不重要”。 如果你想等待子线程完成再退出，那就什么都不用做。，或者显示地调用thread.setDaemon(False)，设置daemon的值为false。新的子线程会继承父线程的daemon标志。整个Python会在所有的非守护线程退出后才会结束，即进程中没有非守护线程存在的时候才结束。 根据原装官方文档的解释，主线程在所有非守护线程都死亡后才会被kill，这样当你忘记使用threading.Thread.exit_thread()或者thread_stop()的时候，嘿嘿，你的程序中主线程收到结束信号，但是因为有一个非守护进程的存在，所以等待。 Queue模块 Queue模块实现了多生产者、多消费者队列。它特别适用于信息必须在多个线程间安全地交换的多线程程序中。这个模块中的Queue类实现了所有必须的锁语义。它依赖于Python中线程支持的可用性；参见threading模块。 特性参数模块实现了三类队列：FIFO（First In First Out，先进先出，默认为该队列）、LIFO（Last In First Out，后进先出）、基于优先级的队列。以下为其常用方法：12345678910111213先进先出 q = Queue.Queue(maxsize)后进先出 a = Queue.LifoQueue(maxsize)优先级 Queue.PriorityQueue(maxsize)Queue.qsize() 返回队列的大小Queue.empty() 如果队列为空，返回True,反之FalseQueue.full() 如果队列满了，返回True,反之FalseQueue.full 与 maxsize 大小对应Queue.put(item) 写入队列，timeout等待时间 非阻塞Queue.get([block[, timeout]]) 获取队列，timeout等待时间Queue.get_nowait() 相当Queue.get(False)Queue.put_nowait(item) 相当Queue.put(item, False)Queue.task_done() 在完成一项工作之后，函数向任务已经完成的队列发送一个信号Queue.join()： 实际上意味着等到队列为空，再执行别的操作(function(){ var bp = document.createElement(‘script’); var curProtocol = window.location.protocol.split(‘:’)[0]; if (curProtocol === ‘https’) { bp.src = ‘https://zz.bdstatic.com/linksubmit/push.js‘; } else { bp.src = ‘http://push.zhanzhang.baidu.com/push.js‘; } var s = document.getElementsByTagName(“script”)[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == &quot;http:&quot;) ? &quot;http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;:&quot;https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;; document.write(&apos;&lt;script src=&quot;&apos; + sozzsrc + &apos;&quot; id=&quot;sozz&quot;&gt;&lt;\\/script&gt;&apos;); })();","tags":[{"name":"python","slug":"python","permalink":"https://austinxishou.github.io/tags/python/"},{"name":"threading","slug":"threading","permalink":"https://austinxishou.github.io/tags/threading/"}]},{"title":"selenium自动化测试入门篇教程","date":"2017-11-01T07:52:10.471Z","path":"2017/11/01/python/selenium-start-guide/","text":"入门指南selenium 初学者指南pypi-seleniumSelenium常用APISelenium Web 自动化 - 测试框架（一） 窗口跳转selectWindow getWindowHandles,判断是否是当前; 获取文本内容12element = driver.find_element_by_id(\"element_id\")element.text 填充表单12345select = driver.find_element_by_tag_name(\"select\")allOptions = select.find_elements_by_tag_name(\"option\")for option in allOptions: print \"Value is: \" + option.get_attribute(\"value\") option.click() 结合Select模块方法,方便选项迭代操作12345# available since 2.12from selenium.webdriver.support.ui import Selectselect = Select(driver.find_element_by_tag_name(\"select\"))select.deselect_all()select.select_by_visible_text(\"Edam\") 提交1element.submit() 窗口跳转有些web 应用有好几个窗口或者frames1driver.switch_to.window(\"windowName\") python+selenium3 玩转浏览器环境搭建安装Selenium使用标准的python管理软件pip1pip install selenium 下载Selenium serverMozilla GeckoDriver 常用操作 跳转 webdriver.get(“http://www.google.com“) 元素定位123element = driver.find_element_by_id(\"passwd-id\") element = driver.find_element_by_name(\"passwd\") element = driver.find_element_by_xpath(\"//input[@id='passwd-id']\") 你还可以通过文本定位链接，但是请注意，文本必须完全匹配！在WebDriver里使用XPATH也要特别注意，如果有多个元素满足查询，将只有第一个满足条件的被返回。如果没有发现任何元素，将会抛出NoSuchElementException异常。 输入文字1element.send_keys(\"some text\") 通过Keys类模仿按箭头键： 1element.send_keys(\" and some\", Keys.ARROW_DOWN) 清空输入框1element.send_keys(\" and some\", Keys.ARROW_DOWN) 弹出对话框Selenium WebDriver内置了针对弹出窗口的处理方法。在打开一个弹出窗口后，可用以下方式访问alert：1Alert = driver.switch_to_alert() 这将返回当前打开的alert对象，通过这个对象，你可以接受，取消，读取它的内容或甚至在提示里输入内容。这个接口是适用于alert、confirm、prompt的。可参考API文档以获取更多信息。导航：历史和定位我们用get方法来跳转到页面。如你所见，WebDriver提供了很多更加细粒度、精确任务的接口，其中，导航就是一个很有用的任务。为了跳转到一个页面，你可以使用get方法：1driver.get(“http://www.example.com”) 为了在浏览器历史里向前或向后移动：12Driver.forward() Driver.back() 使用cookies1234567# Go to the correct domain Driver.get(“http://www.example.com”) # Now set the cookie. This one is valid for the entiredomain Cookie = &#123;“key”: “value”&#125; Driver.add_cookie(cookie) # And now output all the available cookies for the currentURL driver.get_cookies() (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"selenium","slug":"selenium","permalink":"https://austinxishou.github.io/tags/selenium/"}]},{"title":"Android-OTA(三) updater功能解析","date":"2017-11-01T07:52:10.299Z","path":"2017/11/01/android/android-ota-1-updater/","text":"简介 可以说，前面分析的OTA升级的各部分代码都是在搭一个舞台，而主角现在终于登场，它就是updater. Google的代码架构设计非常好，各部分尽量松耦合。前面介绍升级脚本时，可知有两种类型的脚本，amend&amp; edify. 他们各自对应一个updater. 这里，我们主要关注新的edify的updater. 源码文件tree12345678.├── Android.mk├── blockimg.c├── blockimg.h├── install.c├── install.h├── updater.c└── updater.h 入口函数 main 处理version 参数 获取命令管道 Set up the pipe for sending commands back to the parent process. 读入脚本 mzFindZipEntry(&amp;za, SCRIPT_NAME); 注册语句处理函数 Configure edify’s functions. 解析脚本命令 Parse the script. 执行脚本 核心函数是 Evaluate。它会调用其他callback函数，而这些callback函数又会调用Evaluate去解析不同的脚本片段。 主流程的代码非常简单,因为细节隐藏在那些 callback 函数里。 callback函数 RegisterBuiltins 1234567891011void RegisterBuiltins() &#123; RegisterFunction(\"ifelse\", IfElseFn); RegisterFunction(\"abort\", AbortFn); RegisterFunction(\"assert\", AssertFn); RegisterFunction(\"concat\", ConcatFn); RegisterFunction(\"is_substring\", SubstringFn); RegisterFunction(\"stdout\", StdoutFn); RegisterFunction(\"sleep\", SleepFn); RegisterFunction(\"less_than_int\", LessThanIntFn); RegisterFunction(\"greater_than_int\", GreaterThanIntFn);&#125; RegisterInstallFunctions 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void RegisterInstallFunctions() &#123; RegisterFunction(\"mount\", MountFn); RegisterFunction(\"is_mounted\", IsMountedFn); RegisterFunction(\"unmount\", UnmountFn); RegisterFunction(\"format\", FormatFn); RegisterFunction(\"show_progress\", ShowProgressFn); RegisterFunction(\"set_progress\", SetProgressFn); RegisterFunction(\"delete\", DeleteFn); RegisterFunction(\"delete_recursive\", DeleteFn); RegisterFunction(\"package_extract_dir\", PackageExtractDirFn); RegisterFunction(\"package_extract_file\", PackageExtractFileFn); RegisterFunction(\"symlink\", SymlinkFn); // Usage: // set_metadata(\"filename\", \"key1\", \"value1\", \"key2\", \"value2\", ...) // Example: // set_metadata(\"/system/bin/netcfg\", \"uid\", 0, \"gid\", 3003, \"mode\", 02750, \"selabel\", \"u:object_r:system_file:s0\", \"capabilities\", 0x0); RegisterFunction(\"set_metadata\", SetMetadataFn); // Usage: // set_metadata_recursive(\"dirname\", \"key1\", \"value1\", \"key2\", \"value2\", ...) // Example: // set_metadata_recursive(\"/system\", \"uid\", 0, \"gid\", 0, \"fmode\", 0644, \"dmode\", 0755, \"selabel\", \"u:object_r:system_file:s0\", \"capabilities\", 0x0); RegisterFunction(\"set_metadata_recursive\", SetMetadataFn); RegisterFunction(\"getprop\", GetPropFn); RegisterFunction(\"file_getprop\", FileGetPropFn); RegisterFunction(\"write_raw_image\", WriteRawImageFn); RegisterFunction(\"write_raw_parameter_image\", WriteRawParameterImageFn); RegisterFunction(\"clear_misc_command\", ClearMiscCommandFn); RegisterFunction(\"apply_patch\", ApplyPatchFn); RegisterFunction(\"apply_patch_check\", ApplyPatchCheckFn); RegisterFunction(\"apply_patch_space\", ApplyPatchSpaceFn); RegisterFunction(\"wipe_block_device\", WipeBlockDeviceFn); RegisterFunction(\"read_file\", ReadFileFn); RegisterFunction(\"sha1_check\", Sha1CheckFn); RegisterFunction(\"rename\", RenameFn); RegisterFunction(\"wipe_cache\", WipeCacheFn); RegisterFunction(\"ui_print\", UIPrintFn); RegisterFunction(\"run_program\", RunProgramFn); RegisterFunction(\"reboot_now\", RebootNowFn); RegisterFunction(\"get_stage\", GetStageFn); RegisterFunction(\"set_stage\", SetStageFn); RegisterFunction(\"enable_reboot\", EnableRebootFn); RegisterFunction(\"tune2fs\", Tune2FsFn);&#125; RegisterBlockImageFunctions 12345void RegisterBlockImageFunctions() &#123; RegisterFunction(\"block_image_verify\", BlockImageVerifyFn); RegisterFunction(\"block_image_update\", BlockImageUpdateFn); RegisterFunction(\"range_sha1\", RangeSha1Fn);&#125; FinishRegistration123void FinishRegistration() &#123; qsort(fn_table, fn_entries, sizeof(NamedFunction), fn_entry_compare);&#125;(function(){ var bp = document.createElement(‘script’); var curProtocol = window.location.protocol.split(‘:’)[0]; if (curProtocol === ‘https’) { bp.src = &apos;https://zz.bdstatic.com/linksubmit/push.js&apos;; } else { bp.src = &apos;http://push.zhanzhang.baidu.com/push.js&apos;; } var s = document.getElementsByTagName(“script”)[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == “http:”) ? “http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;:&quot;https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a“; document.write(‘&lt;\\/script&gt;’);})();","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"OTA","slug":"OTA","permalink":"https://austinxishou.github.io/tags/OTA/"},{"name":"recovery","slug":"recovery","permalink":"https://austinxishou.github.io/tags/recovery/"}]},{"title":"Android-OTA(三) recovery 功能解析","date":"2017-11-01T07:52:10.262Z","path":"2017/11/01/android/android-ota-3-recovery-boot-ota/","text":"简介recovery 作为系统的恢复工具,有以下几点功能: 首先是我们熟悉的恢复工厂设置 –&gt; wipe_data wipe_cache 刷升级包，可以通过sdcard升级，通常说的卡刷，有些还提供ADB sideload升级； 可以进行系统的系统的OTA升级，本质上同手动刷包一样； recovery 与 主系统交互是通过 /cache 目录下的文件: /cache/recovery/command 作为recovery的输入参数,以行为分割 /cache/recovery/log 收集recovery的日志文件 /cache/recovery/intent 输出后续操作指令 recovery最后是编译成一个可执行的命令，放在recovery文件系统中的/sbin/recovery；所以我们可以在终端中直接运行该命令，具体的参数如下： 1234567--send_intent=anystring - 传递给recovery的信息--adbd -adb sideload升级--update_package=path - 指定OTA升级包--wipe_data - 清楚用户数据并重启--wipe_cache - 清楚缓存并重启--set_encrypted_filesystem=on|off - 使能或者关闭文件系统加密--just_exit - 退出并重启 recovery生成先看一下 build/core/Makefile 的依赖文件:123456789101112$(INSTALLED_RECOVERYIMAGE_TARGET): $(MKBOOTFS) $(MKBOOTIMG) $(MINIGZIP) \\ $(INSTALLED_RAMDISK_TARGET) \\ $(INSTALLED_BOOTIMAGE_TARGET) \\ $(INTERNAL_RECOVERYIMAGE_FILES) \\ $(recovery_initrc) $(recovery_sepolicy) $(recovery_kernel) \\ $(INSTALLED_2NDBOOTLOADER_TARGET) \\ $(recovery_build_prop) $(recovery_resource_deps) \\ $(recovery_fstab) \\ $(recovery_fstab_mtd) \\ $(recovery_fstab_emmc) \\ $(RECOVERY_INSTALL_OTA_KEYS) $(call build-recoveryimage-target, $@) 123456789101．MKBOOTFS, MINIGZIP, MKBOOTIMG，PC端工具软件 2．INSTALLED_RAMDISK_TARGET,标准根文件系统 ramdisk.img 3．INSTALLED_BOOTIMAGE_TARGET,即boot.img,标准内核及标准根文件系统 4. recovery_binary, Recovery可执行程序，源码位于：bootable/recovery 5. recovery_initrc，recovery模式的init.rc, 位于 bootable/recovery/etc/init.rc 6. recovery_kernel, recovery 模式的kernel, 同标准内核 7. INSTALLED_2NDBOOTLOADER_TARGET，我们不用 8. recovery_build_prop， recovery 模式的build.prop, 同标准模式 9. recovery_resource_deps， recovery 模式使用的res, 位于：recovery/custom/&#123;product_name&#125;/res 10. RECOVERY_INSTALL_OTA_KEYS, ota 密钥 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455recovery├── charger -&gt; /sbin/healthd├── data├── default.prop├── dev├── drmboot.ko├── etc│ ├── recovery.emmc.fstab│ └── recovery.fstab├── file_contexts├── fstab.rk30board.bootmode.emmc├── fstab.rk30board.bootmode.unknown├── init├── init.bootmode.emmc.rc├── init.bootmode.unknown.rc├── init.rc├── oem├── proc├── property_contexts├── res│ ├── images│ │ ├── erasing_text.png│ │ ├── error_text.png│ │ ├── font.png│ │ ├── icon_error.png│ │ ├── icon_installing.png│ │ ├── installing_text.png│ │ ├── no_command_text.png│ │ ├── progress_empty.png│ │ ├── progress_fill.png│ │ ├── stage_empty.png│ │ └── stage_fill.png│ └── keys├── rk30xxnand_ko.ko├── sbin│ ├── adbd│ ├── busybox│ ├── e2fsck│ ├── healthd│ ├── mkdosfs│ ├── mkfs.f2fs│ ├── recovery│ ├── resize2fs│ ├── sh│ ├── ueventd -&gt; ../init│ └── watchdogd -&gt; ../init├── seapp_contexts├── selinux_version├── sepolicy├── service_contexts├── sys├── system├── tmp├── ueventd.rc└── ueventd.rk30board.rc recovery根文件系统从bootloader 进入Recovery 模式后，首先也是运行Linux内核，该内核跟普通模式没有区别(减轻了BSP开发者的任务)。区别从执行文件系统开始。 Recovery 模式的细节就隐藏在其根文件系统中。下面，我们就看看进入Recovery 根文件系统都干些啥。 init.rc和正常启动一样，内核进入文件系统会执行/init, init 的配置文件就是 /init.rc 主要功能为: 设置环境变量; 建立 etc 链接; 挂载文件系统并创建文件夹目录; 启动 recovery主程序; 执行流程分析在Android源码环境中，recovery的源码主要在bootable/recovery文件下，另外在device目录下，会根据各个设备定制自己的接口以及UI界面，也就是文章后半部分分析的界面定制的内容； 在bootable/recovery目录下，看Android.mk文件的源文件列表：123456789101112LOCAL_SRC_FILES := \\ adb_install.cpp \\ asn1_decoder.cpp \\ bootloader.cpp \\ device.cpp \\ fuse_sdcard_provider.c \\ install.cpp \\ recovery.cpp \\ roots.cpp \\ screen_ui.cpp \\ ui.cpp \\ verifier.cpp \\ 主要执行流程 标准错误输出重定向 将标准输出和标准错误输出重定位到”/tmp/recovery.log”,如果是eng模式，就可以通过adb pull /tmp/recovery.log, 看到当前的log信息，这为我们提供了有效的调试手段。后面还会看到，recovery模式运行完毕后，会将其拷贝到cache分区，以便后续分析。 miniui初始化 Recovery 使用了一个简单的基于framebuffer的ui系统，叫miniui,这里，进行了简单的初始化（主要是图形部分以及事件部分），并启动了一个 event 线程用于响应用户按键。 解析参数 从misc 分区以及 CACHE:recovery/command 文件中读入参数，写入到argc, argv ,并且，如果有必要，回写入misc分区。这样，如果recovery没有操作成功（比如，升级还没有结束，就拔电池），系统会一直进入recovery模式。提醒用户继续升级，直到成功。 设备定制文件初始化 device_recovery_start() 它給设备制造商提供了一个调用机会，可写入设备相关初始化代码。 根据命令参数,执行命令 根据用户提供参数，调用各项功能，比如，安装一个升级包，擦除cache分区, 擦除user data分区，install_package比较复杂。 完成指令后,等待用户后续指令 如果前面已经做了某项操作并且成功，则进入重启流程。否则，等待用户选择具体操作。而用户可选操作为： reboot, 安装update.zip，除cache分区, 擦除user data分区,如前所述，只有安装package 比较复杂，其它简单。 结束recovery finish_recovery(send_intent); 它的功能如下： 1. 将前面定义的intent字符串写入（如果有的话）：CACHE:recovery/command 2. 将 /tmp/recovery.log 复制到 &quot;CACHE:recovery/log&quot;; 3. 清空 misc 分区，这样重启就不会进入recovery模式4)删除command 文件：CACHE:recovery/command; 核心函数 really_install_package 更新UI显示 ui-&gt;Print 更新升级时UI界面显示 确保所有分区正确挂载 ensure_path_mounted ,主要是cache分区或者SD分区 读取update.zip文件 load_keys 装载公钥 verify_file 注释很清楚,就是签名的验证; 打开升级包 mzOpenZipArchive，将相关信息存到 ZipArchive 数据结构中，便于后面处理。 调用try_update_binary继续执行 如果升级包中包含脚本文件,则解压执行;主要功能都在这个函数中完成,接下去继续分析; 复制脚本文件 将升级包内文件META-INF/com/google/android/update-binary 复制为/tmp/update_binary 创建新的进程，执行：/tmp/update_binary 主进程与子进程通过管道进行进程间通信;原进程变成一个服务进程，它提供UI更新服务;包括:更新精度条,打印提示信息,清除缓存,清除显示等 执行update_binary 这样，我们又回到了升级包中的文件：META-INF/com/google/android/update-binary(function(){ var bp = document.createElement(‘script’); var curProtocol = window.location.protocol.split(‘:’)[0]; if (curProtocol === ‘https’) { bp.src = &apos;https://zz.bdstatic.com/linksubmit/push.js&apos;; } else { bp.src = &apos;http://push.zhanzhang.baidu.com/push.js&apos;; } var s = document.getElementsByTagName(“script”)[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == “http:”) ? “http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;:&quot;https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a“; document.write(‘&lt;\\/script&gt;’);})();","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"OTA","slug":"OTA","permalink":"https://austinxishou.github.io/tags/OTA/"},{"name":"recovery","slug":"recovery","permalink":"https://austinxishou.github.io/tags/recovery/"}]},{"title":"Android-OTA(二)ota_from_target_files命令解析","date":"2017-11-01T07:52:10.225Z","path":"2017/11/01/android/Android-ota-2-from-target-files-usage/","text":"简介主要是从一个输入的中间压缩包,生成OTA升级包 1234567./build/tools/releasetools/ota_from_target_filesGiven a target-files zipfile, produces an OTA package that installsthat build. An incremental OTA is produced if -i is given, otherwisea full OTA is produced.Usage: ota_from_target_files [flags] input_target_files output_ota_package 常用的参数:12345678-k 指定签名文件,默认为\"build/target/product/security/testkey\"-i 指定源文件-p 指定编译主机可执行文件路径-v 冗余信息打印-w 清除用户数据-e 定义额外运行的脚本-m 定义采用的脚本格式，目前有两种，amend &amp; edify, 其中amend为较老的格式。-s 定义额外运行的脚本的路径 源码分析入口：main按照python惯例，单独执行的代码执行从main开始： 将用户设定的 Option 存入 OPTIONS 变量中。 解开输入包 设定输出文件，如果要签名（our case）,则还需要一个临时输出文件。 根据参数，调用全量包或差分包创建 ZIP 创建函数。 WriteFullOTAPackage 全量包生成 主要函数 WriteFullOTAPackage 获得脚本生成器，他们的实现见脚本 edify_generator.py 等 获得一些环境变量，来自android 环境变量。 创建连接 MakeRecoveryPatch : 在输出 ZIP包中生成一个patch 在输出 ZIP包中生成一个脚本：recovery/etc/install-recovery.sh , 它最后会位于system/etc/install-recovery.sh 设置 system 目录下文件的权限及属主等。 script.WriteRawImage(“boot”, “boot.img”) 在脚本中增加语句，将 boot.img 写到 boot 分区。 将前面生成的脚本输出到：META-INF/com/google/android/updater-script （对于edify）(function(){ var bp = document.createElement(‘script’); var curProtocol = window.location.protocol.split(‘:’)[0]; if (curProtocol === ‘https’) { bp.src = &apos;https://zz.bdstatic.com/linksubmit/push.js&apos;; } else { bp.src = &apos;http://push.zhanzhang.baidu.com/push.js&apos;; } var s = document.getElementsByTagName(“script”)[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == “http:”) ? “http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;:&quot;https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a“; document.write(‘&lt;\\/script&gt;’);})();","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"OTA","slug":"OTA","permalink":"https://austinxishou.github.io/tags/OTA/"}]},{"title":"Android优化OTA包大小和开机启动时间","date":"2017-11-01T07:52:09.685Z","path":"2017/11/01/android/Android-ota-1-odex-improve/","text":"问题说明在Android 升级到 5.0 (Lollipop/L)之后，虚拟机实例换成了ART，这加快了应用运行时的速度，但是在系统升级中却引入了一些不便之处： 在生成升级包时，因为ART采用了预编译优化功能，会把 APK 及JAR等通过dex2ota预编译成odex文件，这样极大的增加了升级包的大小，动辄上G的大小不方便用户的下载和网络的传播； 如果不进行预编译优化，则这部分操作会转移到刷机完成后第一次开机时间，十几分钟甚至更多的时间，让用户不确认是否升级出问题； 预编译配置-兼顾大小和时间上述问题，Android系统设计者，早已考虑周全，尤其是针对存储空间有限的设备，提供了丰富的编译配置选项，方便开发者根据自己实际情况进行针对性的配置修改； 下面就针对这些配置选项进行说明和标记，方便后续开发人员参考； 打开odex编译优化首先，可以完全关闭预编译优化功能，跟dalvik虚拟机时代的升级包相同：1product BoardConfig.mk 文件中，添加编译变量： WITH_DEXPREOPT := true 当然，这样的结果就是升级包小了，第一次开机时间极其慢； 预编译的包不进行优化预编译的包是指那些在模块编译文件中指定为：include $(BUILD_PREBUILT) 的APK和JAR包等，这在升级包中占了一大部门；DONT_DEXPREOPT_PREBUILTS 变量就可以配置这部门代码是否进行预编译优化；1DONT_DEXPREOPT_PREBUILTS := true 后，编译系统将会阻止 prebuild 包的odex优化； 只进行BOOT.img 优化Android启动过程中，boot.img包含了大部分底层系统的启动和初始化，主要包含在boot.art文件中；使用 WITH_DEXPREOPT_BOOT_IMG_ONLY 编译变量，可以控制编译系统只进行boot.img的优化；使能该变量后，将会大量节省system分区的大小，但同时意味着所有的app都需要在第一次重启的时候进行odex优化； 所以最好是通过 DONT_DEXPREOPT_PREBUILTS 进行更精确的控制； LOCAL_DEX_PREOPT 编译变量使用每个app应用，可以通过该编译变量进行控制是否进行odex优化；在 app’s Android.mk，进行变量赋值 LOCAL_DEX_PREOPT := false PRODUCT_DEXPREOPT 编译变量使用在 post-L 发行版本之后，添加了这个系列的编译变量，进行更深入控制预编译的优化； PRODUCT_DEX_PREOPT_BOOT_FLAGS 传递参数给 dex2oat 命令，控制boot.img的编译 PRODUCT_DEX_PREOPT_DEFAULT_FLAGS 传递默认参数给 dex2oat 命令，控制除了 boot.img的编译，即jar包和apk文件1$(call add-product-dex-preopt-module-config,services,--compiler-filter=space) 或者 直接关闭模块的预编译优化1$(call add-product-dex-preopt-module-config,Calculator,disable) Android 7.0 之后的优化7.0后，系统可以分为A/B两个分区，OTA升级以及APK的优化不影响用户前台的正常使用，这样既减小了升级包的大小，又提升了第一次开机速度； 预加载类文件预加载类会由zygote统一初始化，这样使后续使用到这些类的app开启速度加快；但是预加载类的使用在实际项目中要非常注意，需要仔细评估后确认权衡值，太多的预加载类会导致一些不常用的类消耗宝贵的内存资源，相反则会导致常用的类在不同应用中独立加载，各自有一个备份，既减慢应用开启速度，也是浪费内存； 预加载类的定义列表，默认放置在 frameworks/base/preloaded-classes ，也可以在产品的devic.mk中添加自行定义的预加载列表：1PRODUCT_COPY_FILES += &lt;filename&gt;:system/etc/preloaded-classes 编译类列表结合 PRODUCT_DEX_PREOPT_BOOT_FLAGS 和 compiled-classes 可以控制编译系统是否在预编译优化中编译这些类；不过上述列表只能定义启动类的一个子集，适合用于那些存储空间非常有限，不能全局优化编译整个boot.img 分区的设备，所以对我们来说并不适合；(function(){ var bp = document.createElement(‘script’); var curProtocol = window.location.protocol.split(‘:’)[0]; if (curProtocol === ‘https’) { bp.src = ‘https://zz.bdstatic.com/linksubmit/push.js‘; } else { bp.src = ‘http://push.zhanzhang.baidu.com/push.js‘; } var s = document.getElementsByTagName(“script”)[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == &quot;http:&quot;) ? &quot;http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;:&quot;https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;; document.write(&apos;&lt;script src=&quot;&apos; + sozzsrc + &apos;&quot; id=&quot;sozz&quot;&gt;&lt;\\/script&gt;&apos;); })();","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"odex","slug":"odex","permalink":"https://austinxishou.github.io/tags/odex/"}]},{"title":"Android-OTA(四)Recovery二次开发","date":"2017-11-01T07:52:09.642Z","path":"2017/11/01/android/android-ota-4-recovery-custom/","text":"main 函数从main入口函数分析recovery的主要源码： 输出重定向 123456 redirect_stdio(TEMPORARY_LOG_FILE); //redirect log to serial output#ifdef LogToSerial freopen(&quot;/dev/ttyFIQ0&quot;, &quot;a&quot;, stdout); setbuf(stdout, NULL); freopen(&quot;/dev/ttyFIQ0&quot;, &quot;a&quot;, stderr); setbuf(stderr, NULL);#endif 这部分代码很容易理解，主要作用是输出log到/tem/recovery.log文件中 执行adb sideload分支 1234if (argc == 2 &amp;&amp; strcmp(argv[1], &quot;--adbd&quot;) == 0) &#123; adb_main(0, DEFAULT_ADB_PORT); return 0;&#125; 判断命令行参数是否为–adbd，并执行adb_main函数，这部分代码在后续adb_install.cpp中分析； 填充fstab结构体 在main函数中调用 load_volume_table()，读取/etc/recovery.emmc.fstab文件内容，并填充fstab结构体，但是并没有执行挂载操作：load_volume_table函数在roots.cpp文件中，也是很容易理解：1234567891011121314151617181920212223void load_volume_table()&#123; ... int emmcState = getEmmcState();//判断是否为emmc设备 if(emmcState) &#123; fstab = fs_mgr_read_fstab(&quot;/etc/recovery.emmc.fstab&quot;); &#125;else &#123; fstab = fs_mgr_read_fstab(&quot;/etc/recovery.fstab&quot;); &#125; ... //读取文件中每个条目内容，填充fstab结构体 ret = fs_mgr_add_entry(fstab, &quot;/tmp&quot;, &quot;ramdisk&quot;, &quot;ramdisk&quot;); ... //日志打印fstable信息 printf(&quot;recovery filesystem table\\n&quot;); printf(&quot;=========================\\n&quot;); for (i = 0; i &lt; fstab-&gt;num_entries; ++i) &#123; Volume* v = &amp;fstab-&gt;recs[i]; printf(&quot; %d %s %s %s %lld\\n&quot;, i, v-&gt;mount_point, v-&gt;fs_type, v-&gt;blk_device, v-&gt;length); &#125; printf(&quot;\\n&quot;);&#125; 读取控制参数recovery 和 bootloader 必须通过内存的一个特定分区，才能进行相互的通信，这个分区一般是/misc；对应的信息数据结构体为bootloader_message；参照源码中bootloader_message 的注释 1234567struct bootloader_message &#123; char command[32];//bootloader 启动时读取改数据，决定是否进入recovery模式 char status[32];//由bootloader进行更新，标识升级的结果； char recovery[768];//由Android系统进行写入，recovery从中读取信息； char stage[32]; char reserved[224];&#125;; recovery 根据命令行参数，再从/misc分区中解析出对应的参数，进行后续的操作，具体的调用函数为get_args(&amp;argc, &amp;argv); 123456789101112131415161718192021222324252627282930313233343536373839404142434445static voidget_args(int *argc, char ***argv) &#123; struct bootloader_message boot;//参数结构体 memset(&amp;boot, 0, sizeof(boot)); get_bootloader_message(&amp;boot); // 具体的读取信息的函数，可能为空的情况 stage = strndup(boot.stage, sizeof(boot.stage)); ... // 如果上述情况为空，则从/cache/recovery/command获取参数，其中COMMAND_FILE=/cache/recovery/command if (*argc &lt;= 1) &#123; FILE *fp = fopen_path(COMMAND_FILE, &quot;r&quot;); if (fp != NULL) &#123; char *token; char *argv0 = (*argv)[0]; *argv = (char **) malloc(sizeof(char *) * MAX_ARGS); (*argv)[0] = argv0; // use the same program name char buf[MAX_ARG_LENGTH]; for (*argc = 1; *argc &lt; MAX_ARGS; ++*argc) &#123; if (!fgets(buf, sizeof(buf), fp)) break; token = strtok(buf, &quot;\\r\\n&quot;); if (token != NULL) &#123; (*argv)[*argc] = strdup(token); // Strip newline. &#125; else &#123; --*argc; &#125; &#125; check_and_fclose(fp, COMMAND_FILE); LOGI(&quot;Got arguments from %s\\n&quot;, COMMAND_FILE); &#125; &#125; //把从/cache/recovery/command获取参数重新写回到/misc分区 // --&gt; write the arguments we have back into the bootloader control block // always boot into recovery after this (until finish_recovery() is called) strlcpy(boot.command, &quot;boot-recovery&quot;, sizeof(boot.command)); strlcpy(boot.recovery, &quot;recovery\\n&quot;, sizeof(boot.recovery)); int i; for (i = 1; i &lt; *argc; ++i) &#123; strlcat(boot.recovery, (*argv)[i], sizeof(boot.recovery)); strlcat(boot.recovery, &quot;\\n&quot;, sizeof(boot.recovery)); &#125; set_bootloader_message(&amp;boot);&#125; 解析命令行参数 123456789101112131415161718192021222324252627282930313233343536373839 while ((arg = getopt_long(argc, argv, &quot;&quot;, OPTIONS, NULL)) != -1) &#123; switch (arg) &#123; case &apos;f&apos;: factory_mode = optarg; bFactoryMode = true; break; case &apos;i&apos;: send_intent = optarg; break; case &apos;u&apos;: update_package = optarg; break; case &apos;w&apos;: should_wipe_data = true; break;case &apos;k&apos;: update_rkimage = optarg;break; case &apos;c&apos;: should_wipe_cache = true; break; case &apos;t&apos;: show_text = true; break; case &apos;s&apos;: sideload = true; break; case &apos;a&apos;: sideload = true; sideload_auto_reboot = true; break; case &apos;x&apos;: just_exit = true; break; case &apos;l&apos;: locale = optarg; break; case &apos;g&apos;: &#123; if (stage == NULL || *stage == &apos;\\0&apos;) &#123; char buffer[20] = &quot;1/&quot;; strncat(buffer, optarg, sizeof(buffer)-3); stage = strdup(buffer); &#125; break; &#125; case &apos;f&apos;+&apos;w&apos;: //fw_update if((optarg)&amp;&amp;(!sdboot_update_package))&#123; sdboot_update_package = strdup(optarg); &#125; break; case &apos;d&apos;: //demo_copy if((optarg)&amp;&amp;(! demo_copy_path))&#123; demo_copy_path = strdup(optarg); &#125; break; case &apos;p&apos;: shutdown_after = true; break; case &apos;r&apos;: reason = optarg; break; case &apos;w&apos;+&apos;a&apos;: &#123; should_wipe_all = should_wipe_data = should_wipe_cache = true;show_text = true;&#125; break; case &apos;?&apos;: LOGE(&quot;Invalid command argument\\n&quot;); continue; &#125; &#125; 这部分代码很简单，就是通过getopt_long进行命令行参数的解析并赋值； 显示界面和功能选项 接下来就是创建device，显示对应UI界面和功能选项； 12345678 Device* device = make_device();//可以自己实现一个设备 ui = device-&gt;GetUI(); gCurrentUI = ui;//赋值ui界面 ui-&gt;SetLocale(locale);//获取归属地信息 ui-&gt;Init();//初始化，可以重载，在init中实现相应功能ui-&gt;SetStage(st_cur, st_max);ui-&gt;SetBackground(RecoveryUI::NONE); 进行分区挂载操作ensure_path_mounted12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182int ensure_path_mounted(const char* path) &#123; ... Volume* v = volume_for_path(path);//根据路径名获取分区信息 ... int result; result = scan_mounted_volumes(); const MountedVolume* mv = find_mounted_volume_by_mount_point(v-&gt;mount_point);//根据挂载点，获取已挂载分区的信息，如果不为空，说明已经成功挂载 if (mv) &#123; // volume is already mounted return 0; &#125; result = mkdir(v-&gt;mount_point, 0755); // 创建对应目录，确保目录存在，也有可能目录已经存在 if (result!=0) &#123; printf(&quot;failed to create %s dir,err=%s!\\n&quot;,v-&gt;mount_point,strerror(errno)); &#125; // 根据文件系统类型，执行mount操作 if (strcmp(v-&gt;fs_type, &quot;yaffs2&quot;) == 0) &#123; // mount an MTD partition as a YAFFS2 filesystem. mtd_scan_partitions(); const MtdPartition* partition; partition = mtd_find_partition_by_name(v-&gt;blk_device); if (partition == NULL) &#123; LOGE(&quot;failed to find \\&quot;%s\\&quot; partition to mount at \\&quot;%s\\&quot;\\n&quot;, v-&gt;blk_device, v-&gt;mount_point); return -1; &#125; return mtd_mount_partition(partition, v-&gt;mount_point, v-&gt;fs_type, 0); &#125; else if (strcmp(v-&gt;fs_type, &quot;ext4&quot;) == 0 || strcmp(v-&gt;fs_type, &quot;ext3&quot;) == 0) &#123; result = mount(v-&gt;blk_device, v-&gt;mount_point, v-&gt;fs_type, MS_NOATIME | MS_NODEV | MS_NODIRATIME, &quot;&quot;); if (result == 0) return 0; LOGE(&quot;failed to mount %s %s (%s)\\n&quot;, v-&gt;mount_point, v-&gt;blk_device, strerror(errno)); return -1; &#125; else if (strcmp(v-&gt;fs_type, &quot;vfat&quot;) == 0) &#123; result = mount(v-&gt;blk_device, v-&gt;mount_point, v-&gt;fs_type, MS_NOATIME | MS_NODEV | MS_NODIRATIME, &quot;shortname=mixed,utf8&quot;); if (result == 0) return 0; LOGW(&quot;trying mount %s to ntfs\\n&quot;, v-&gt;blk_device); result = mount(v-&gt;blk_device, v-&gt;mount_point, &quot;ntfs&quot;, MS_NOATIME | MS_NODEV | MS_NODIRATIME, &quot;&quot;); if (result == 0) return 0; char *sec_dev = v-&gt;fs_options; if(sec_dev != NULL) &#123; char *temp = strchr(sec_dev, &apos;,&apos;); if(temp) &#123; temp[0] = &apos;\\0&apos;; &#125; result = mount(sec_dev, v-&gt;mount_point, v-&gt;fs_type, MS_NOATIME | MS_NODEV | MS_NODIRATIME, &quot;shortname=mixed,utf8&quot;); if (result == 0) return 0; LOGW(&quot;trying mount %s to ntfs\\n&quot;, sec_dev); result = mount(sec_dev, v-&gt;mount_point, &quot;ntfs&quot;, MS_NOATIME | MS_NODEV | MS_NODIRATIME, &quot;&quot;); if (result == 0) return 0; &#125; LOGE(&quot;failed to mount %s (%s)\\n&quot;, v-&gt;mount_point, strerror(errno)); return -1; &#125;else if (strcmp(v-&gt;fs_type, &quot;ntfs&quot;) == 0) &#123; LOGW(&quot;trying mount %s to ntfs\\n&quot;, v-&gt;blk_device); result = mount(v-&gt;blk_device, v-&gt;mount_point, &quot;ntfs&quot;, MS_NOATIME | MS_NODEV | MS_NODIRATIME, &quot;&quot;); if (result == 0) return 0; LOGE(&quot;failed to mount %s (%s)\\n&quot;, v-&gt;mount_point, strerror(errno)); return -1; &#125; LOGE(&quot;unknown fs_type \\&quot;%s\\&quot; for %s\\n&quot;, v-&gt;fs_type, v-&gt;mount_point); return -1;&#125; 界面定制实现Recovery UI在自己的设备目录下：device/vendor/recovery/recovery_ui.cpp 12345678#include &lt;linux/input.h&gt;#include &lt;sys/stat.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &quot;common.h&quot;#include &quot;device.h&quot;#include &quot;screen_ui.h&quot; 实现头部显示和列表项1234567891011121314const char* HEADERS[] = &#123; &quot;Volume up/down to move highlight;&quot;, &quot;power button to select.&quot;, &quot;&quot;, NULL &#125;;const char* ITEMS[] =&#123; &quot;reboot system now&quot;, //&quot;apply update from ADB&quot;, &quot;apply update from external storage&quot;, &quot;update rkimage from external storage&quot;, &quot;apply update from cache&quot;, &quot;wipe data/factory reset&quot;, &quot;wipe cache partition&quot;, &quot;recovery system from backup&quot;, NULL &#125;; 实现ScreenRecoveryUI12345678910111213141516171819202122232425class DeviceUI : public ScreenRecoveryUI &#123; public: DeviceUI () : consecutive_power_keys(0) &#123; &#125; //实现自己的识别key类型的功能，可以为不同的输入设备适配recovery功能 virtual KeyAction CheckKey(int key) &#123; if (IsKeyPressed(KEY_POWER) &amp;&amp; key == KEY_VOLUMEUP) &#123; return TOGGLE; &#125; if (key == KEY_POWER) &#123; ++consecutive_power_keys; if (consecutive_power_keys &gt;= 7) &#123; return REBOOT; &#125; &#125; else &#123; consecutive_power_keys = 0; &#125; return ENQUEUE; &#125; private: int consecutive_power_keys;&#125;; 实现设备类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class MyDevice : public Device &#123; public: RkDevice() : ui(new DeviceUI ) &#123; &#125; RecoveryUI* GetUI() &#123; return ui; &#125; int HandleMenuKey(int key_code, int visible) &#123; if (visible) &#123; switch (key_code) &#123; case KEY_DOWN: case KEY_VOLUMEDOWN: return kHighlightDown; case KEY_UP: case KEY_VOLUMEUP: return kHighlightUp; case KEY_ENTER: case KEY_POWER: return kInvokeItem; &#125; &#125; return kNoAction; &#125; BuiltinAction InvokeMenuItem(int menu_position) &#123; switch (menu_position) &#123; case 0: return REBOOT; //case 1: return APPLY_ADB_SIDELOAD; case 1: return APPLY_EXT; case 2: return APPLY_INT_RKIMG; case 3: return APPLY_CACHE; case 4: return WIPE_DATA; case 5: return WIPE_CACHE; case 6: return RECOVER_SYSTEM; default: return NO_ACTION; &#125; &#125; const char* const* GetMenuHeaders() &#123; return HEADERS; &#125; const char* const* GetMenuItems() &#123; return ITEMS; &#125; private: RecoveryUI* ui;&#125;;//创建自己实现的设备Device* make_device() &#123; return new MyDevice ;&#125; 添加编译实现主要是覆盖TARGET_RECOVERY_UI_LIB，输出到/out/…./recovery/root目录下： Android.mk1234567891011LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE_TAGS := engLOCAL_C_INCLUDES += bootable/recoveryLOCAL_SRC_FILES := recovery_ui.cpp# should match TARGET_RECOVERY_UI_LIB set in BoardConfig.mkLOCAL_MODULE := librecovery_ui_$(TARGET_PRODUCT)include $(BUILD_STATIC_LIBRARY) recovery 二次开发代码结构： bootable/recoveryRecovery主程序代码，其中recovery.cpp是入口，rkimage.cpp处理update.img升级流程，updater/install.c处理ota update.zip包升级流程。 build/tools/releasetools/Ota升级包编译的python脚本，控制完整包与差异包的生成。 build/tools/drmsigntool/如果开启drm，生成ota包时对boot.img进行签名，使用build/target/product/security/private.key，保证进行ota升级后drm功能还能正常使用。 build/tools/mkparameter/编译ota包时打包可升级的parameter的工具。 build/tools/remkloader/编译ota包时打包可升级的loader的工具。 build/target/product/security/编译ota包时签名使用的密钥 device/rockchip/rksdk/recovery/Recovery菜单及按键定制 device/rockchip/rksdk/loader/将需要升级的loader放在该目录下，可以打包到ota升级包中。 device/rockchip/rksdk/parameter/将需要升级的parameter放在该目录下，可以打包到ota升级包中。 out/target/product/rk3188/obj/PACKAGING/target_files_intermediates/Ota升级包编译生成的素材包，要做差异包必须保存该素材包。 板级配置 Recovery 一些宏配置开关在device/rockchip/rk30sdk/BoardConfig.mk BOARD_HAS_FLIPPED_SCREEN := true 针对lcd装反的情况可以强制recovery ui旋转180° TARGET_RECOVERY_UI_LIB ?= librecovery_ui_rk30sdk 自定义recovery菜单与按键实现。 TARGET_USERIMAGES_USE_EXT4 ?= true Recovery支持ext4 文件系统 RECOVERY_UPDATEIMG_RSA_CHECK ?= false Update.img在升级时进行drm签名校验，防止第三方非法固件升级。Update.img必须使用secureboot工具签名，并勾选sign check复选框。 RECOVERY_BOARD_ID ?= false 一种根据烧录Boardid 串号实现一种固件支持不同硬件不同国家定制的one image方案，该方案支持google 的ota 完整升级和差异升级。 脚本文件命令以及解析升级脚本文件解析, try_update_binary主要命令有1234567progress &lt;frac&gt; &lt;secs&gt;set_progress &lt;frac&gt;firmware &lt;\"hboot\"|\"radio\"&gt; &lt;filename&gt;ui_print &lt;string&gt;wipe_cacheclear_displayenable_reboot (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"Recovery","slug":"Recovery","permalink":"https://austinxishou.github.io/tags/Recovery/"}]},{"title":"RK3288平台img包解压修改","date":"2017-11-01T07:52:09.604Z","path":"2017/11/01/android/rk3288-firefly-img-modify/","text":"解压update.img12./rkImageMaker -unpack update.img output ./afptool -unpack output/firmware.img output 解压 system.img123456789mount -o loop Image/system.img /mnt/systemumount /mnt/system//增加 128M 的空间dd if=/dev/zero bs=1M count=128 &gt;&gt; Image/system.img//扩展文件系统信息e2fsck -f Image/system.imgresize2fs Image/system.img 解压boot.img1234./rkunpack boot.img mkdir boot-extractedcd boot-extractedcat ../boot.img-raw | gunzip | cpio -i 解压resource.img12345resource_tool --unpack --image=resource.img Myresource//dtb 反编译成dts./dtc -I dtb -O dts rk-kernel.dtb &gt; my-rk-kernel.dts//单独编译dts./dtc -I dtS -O dtB &gt; rk-kernel.dts 打包 boot.img12find . | cpio -o -H newc | gzip &gt; ../opinions-on-teclast-p90hdst-boot.imgrkcrc -k test-boot.img newboot.img imgRePackerRK_105 工具imgRePackerRK_105百度云下载 三星平台img解压修改UPDATA.APP文件解压 参考资料：解包官方UPDATA.APP文件神器工具bootimg.exe工具及详细教程 123bootimg --unpack-updata [文件] [文件]为空时，默认使用UPDATA.APP 解开后，会有四个文件，boot.img, recovery.img, system.img, userdata.img bootimg解压12345678910111213141516bootimg --unpack-bootimg [文件] [文件]为空时，默认使用boot.img 解开后，会有两个文件，kernel和ramdisk.gz 同时，注意输出，比如base, cmdline, name等等；例如： arguments: [bootimg file] bootimg file: boot.img output: kernel[.gz] ramdisk[.gz] second[.gz] base=0x10000000 page_size=2048 name=&quot;SYSMAGIC001&quot; cmdline=&quot;&quot; padding_size=2048 ramdisk.gz 文件解压 1、新建一个文件夹 mkdir ramdisk / cd ramdisk 2、gzip -dc ../boot.img-ramdisk.gz | cpio -i bootimg命令说明：12345678910111213bootimg –cpio-listbootimg –repack-565 oemlogo.mbn（生成开机第一屏文件）bootimg –repack-bootimg boot.img（生成boot.img及recovery.img文件）bootimg –repack-ramdisk ramdisk（生成ramdisk文件）bootimg –repack-rlebootimg –unpack-565 oemlogo.mbn（解开开机第一屏文件）bootimg –unpack-bootimg boot.img（解开boot.img及recovery.img文件）bootimg –unpack-ramdisk ramdisk（解开ramdisk文件）bootimg –unpack-rlebootimg –unpack-updata UPDATA.APP（解开UPDATA.APP文件）bootimg –unpack-yafffs system.img（解开system.img及userdata.img文件）bootimg –unpack-yaffs system.img（解开system.img及userdata.img文件）bootimg –unpack-yaffs2 system.img（解开system.img及userdata.img文件） 运行方法：123456789101112131415在cmd下cd到文件所在目录，输入”bootimg.exe 功能 参数”（用源文件的话就是bootimg.py）目前支持以下功能：bootimg –repack-ramdisk, 生成 ramdiskbootimg –unpack-ramdisk, 解开 ramdiskbootimg –repack-bootimg, 生成 bootimg (包括boot.img及recovery.img)bootimg –unpack-bootimg, 解开 bootimgbootimg –unpack-updata, 解开 updata.appbootimg –unpack-yafffs, 解开 yafffs（包括data.img及system.img）(function(){ var bp = document.createElement(‘script’); var curProtocol = window.location.protocol.split(‘:’)[0]; if (curProtocol === ‘https’) { bp.src = ‘https://zz.bdstatic.com/linksubmit/push.js‘; } else { bp.src = ‘http://push.zhanzhang.baidu.com/push.js‘; } var s = document.getElementsByTagName(“script”)[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == &quot;http:&quot;) ? &quot;http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;:&quot;https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;; document.write(&apos;&lt;script src=&quot;&apos; + sozzsrc + &apos;&quot; id=&quot;sozz&quot;&gt;&lt;\\/script&gt;&apos;); })();","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"app","slug":"app","permalink":"https://austinxishou.github.io/tags/app/"}]},{"title":"网易node游戏服务端开源框架","date":"2017-11-01T07:52:08.782Z","path":"2017/11/01/webdesign/pomelo-node-framework/","text":"About Pomelo 是基于 Node.js 的高性能、分布式游戏服务器框架。它包括基础的开发框架和相关的扩展组件（库和工具包），可以帮助你省去游戏开发枯燥中的重复劳动和底层逻辑的开发。Pomelo 不但适用于游戏服务器开发， 也可用于开发高实时 Web应用，它的分布式架构可以使 Pomelo 比普通的实时 Web 框架扩展性更好。 Pomelo 特性 快速、易上手的游戏开发模型和api 高可伸缩的多进程架构， 支持MMO的场景分区和其它各类分区策略 方便的服务器扩展机制，可快速扩展服务器类型和数量 方便的请求、响应、广播、服务器通讯机制， 无需任何配置 注重性能，在性能、可伸缩性上做了大量的测试、优化 提供了较多扩展组件，包括游戏开发常用的库和工具包 提供了完整的MMO demo代码(客户端html5)，可以作为很好的开发参考 基于socket.io开发，支持socket.io支持的多种语言客户端 GetStarted新建项目使用pomelo的命令行工具可以快速创建一个项目，命令如下：1$ pomelo init ./HelloWorld 或者你也可以使用下面的三个命令：123$ mkdir HelloWorld$ cd HelloWorld$ pomelo init 然后，进入到HelloWorld文件夹，安装依赖包：1$ sh npm-install.sh 项目目录结构12345678910111213141516171819.├── game-server \\\\用pomelo框架搭建的游戏服务器，以文件app.js作为入口│ ├── app│ ├── app.js│ ├── config│ ├── logs│ ├── node_modules│ └── package.json├── npm-install.bat├── npm-install.sh├── shared│ ├── server.crt│ └── server.key└── web-server \\\\用pomelo框架搭建的游戏服务器，以文件app.js作为入口 ├── app.js ├── bin ├── node_modules ├── package.json └── public game-server game-server是用pomelo框架搭建的游戏服务器，以文件app.js作为入口，运行游戏的所有逻辑和功能。所有游戏逻辑、功能、配置等都在该目录下进行。 app子目录 这个目录下放置所有的游戏服务器代码的地方，用户在这里实现不同类型的服务器，添加对应的Handler，Remote等等。 config子目录 config包括了游戏服务器的所有配置信息。配置信息以JSON文件的格式进行定义，包含有日志、master、server等服务器的配置信息。该目录还可以进行扩展，对数据库配置信息、地图信息和数值表等信息进行定义。 logs子目录 日志是项目中不可或缺的，可以对项目的运行情况进行很好的备份，也是系统运维的参考数据之一，logs存放了游戏服务器所有的日志信息。 shared shared存放一些前后端、game-server与web-server共用代码，由于都是javascript代码，那么对于一些工具或者算法代码，就可以前后端共用，极大地提高了代码重用性。 web-server web-server是用express 3.x框架搭建的web服务器，以文件app.js作为入口可以选择Nginx等其他web服务器如果游戏的客户端不是web的话，如Android平台的话，这个目录就不是必须的了。 启动项目 如果客户端是web，必须启动game-server(游戏服务器)和web-server(web服务器) 启动game-server服务器12$ cd game-server$ pomelo start 启动web-server服务器12$ cd web-server$ node app pomelo架构分析 pomelo框架在最初设计的时候只为了一个目标：为基于长连接的分布式游戏服务器架构提供基础设施。框架的内容在逐渐扩展，但最核心的框架只为了干以下三件事： 服务器（进程）的抽象与扩展 在web应用中， 每个服务器是无状态、对等的， 开发者无需通过框架或容器来管理服务器。 但游戏应用不同， 游戏可能需要包含多种不同类型的服务器，每类服务器在数量上也可能有不同的需求。这就需要框架对服务器进行抽象和解耦，支持服务器类型和数量上的扩展。 客户端的请求、响应、广播 客户端的请求、响应与web应用是类似的， 但框架是基于长连接的， 实现模式与http请求有一定差别。 广播是游戏服务器最频繁的操作， 需要方便的API， 并且在性能上达到极致。 服务器间的通讯、调用 尽管框架尽量避免跨进程调用，但进程间的通讯是不可避免的， 因此需要一个方便好用的RPC框架来支撑。 相关链接通过以下参考资料将使我们很快地熟悉 pomelo 的全貌与开发过程： Pomelo架构概览 Pomelo快速使用指南 Pomelo中文教程 Pomelo中文FAQ(function(){ var bp = document.createElement(‘script’); var curProtocol = window.location.protocol.split(‘:’)[0]; if (curProtocol === ‘https’) { bp.src = &apos;https://zz.bdstatic.com/linksubmit/push.js&apos;; } else { bp.src = &apos;http://push.zhanzhang.baidu.com/push.js&apos;; } var s = document.getElementsByTagName(“script”)[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == “http:”) ? “http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;:&quot;https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a“; document.write(‘&lt;\\/script&gt;’);})();","tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://austinxishou.github.io/tags/nodejs/"},{"name":"pomelo","slug":"pomelo","permalink":"https://austinxishou.github.io/tags/pomelo/"}]},{"title":"Android发送广播详解","date":"2017-11-01T07:52:08.615Z","path":"2017/11/01/android/android-broadcast-detail/","text":"调用ContextImpl进行发送同样，不管是Activity、Service上发送广播，最终实现都在ContextImpl，最后发送到ActivityManagerService处理 12345678910111213@Override public void sendBroadcast(Intent intent) &#123; warnIfCallingFromSystemProcess(); String resolvedType = intent.resolveTypeIfNeeded(getContentResolver()); try &#123; intent.prepareToLeaveProcess(); ActivityManagerNative.getDefault().broadcastIntent( mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, false, false, getUserId()); &#125; catch (RemoteException e) &#123; &#125; &#125; ActivityManagerProxy发送到AMS由ActivityManagerProxy发送到AMS 123456789101112131415161718192021222324252627282930//resultTo：null，resultCode：-resultData：null，map：null，requiredPermission：null//appOp：-1，serialized：false，sticky：falsepublic int broadcastIntent(IApplicationThread caller, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle map, String requiredPermission, int appOp, boolean serialized, boolean sticky, int userId) throws RemoteException&#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(caller != null ? caller.asBinder() : null); intent.writeToParcel(data, 0); data.writeString(resolvedType); data.writeStrongBinder(resultTo != null ? resultTo.asBinder() : null); data.writeInt(resultCode); data.writeString(resultData); data.writeBundle(map); data.writeString(requiredPermission); data.writeInt(appOp); data.writeInt(serialized ? 1 : 0); data.writeInt(sticky ? 1 : 0); data.writeInt(userId); mRemote.transact(BROADCAST_INTENT_TRANSACTION, data, reply, 0); reply.readException(); int res = reply.readInt(); reply.recycle(); data.recycle(); return res;&#125; AMS处理BROADCAST_INTENT_TRANSACTIONAMS处理BROADCAST_INTENT_TRANSACTION1234567891011121314151617181920212223242526//resultTo：null，resultCode：-resultData：null，map：null，requiredPermission：null//appOp：-1，serialized：false，sticky：falsecase BROADCAST_INTENT_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); IBinder b = data.readStrongBinder(); IApplicationThread app =b != null ? ApplicationThreadNative.asInterface(b) : null;//依然是Binder本地对象 Intent intent = Intent.CREATOR.createFromParcel(data); String resolvedType = data.readString(); b = data.readStrongBinder();//null IIntentReceiver resultTo =b != null ? IIntentReceiver.Stub.asInterface(b) : null;//null int resultCode = data.readInt();//-1 String resultData = data.readString();//null Bundle resultExtras = data.readBundle();//null String perm = data.readString();//null int appOp = data.readInt();//-1 boolean serialized = data.readInt() != 0;//0 boolean sticky = data.readInt() != 0;//0 int userId = data.readInt(); int res = broadcastIntent(app, intent, resolvedType, resultTo, resultCode, resultData, resultExtras, perm, appOp, serialized, sticky, userId); reply.writeNoException(); reply.writeInt(res); return true; &#125; 首先检验Intent的有效性，是否带文件描述符，如果进程未启动完成，带FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT，表示可以在进程未启动完之前接收广播，没有该标识则抛异常，接着调用方法broadcastIntentLocked处理1234567891011121314151617181920212223//resultTo：null，resultCode：-resultData：null，map：null，requiredPermission：null//appOp：-1，serialized：false，sticky：falsepublic final int broadcastIntent(IApplicationThread caller, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle map, String requiredPermission, int appOp, boolean serialized, boolean sticky, int userId) &#123; enforceNotIsolatedCaller(\"broadcastIntent\"); synchronized(this) &#123; //intent有效性检查，不能带文件描述符 intent = verifyBroadcastLocked(intent); final ProcessRecord callerApp = getRecordForAppLocked(caller); final int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); int res = broadcastIntentLocked(callerApp, callerApp != null ? callerApp.info.packageName : null, intent, resolvedType, resultTo, resultCode, resultData, map, requiredPermission, appOp, serialized, sticky, callingPid, callingUid, userId); Binder.restoreCallingIdentity(origId); return res; &#125;&#125; broadcastIntentLocked获取目标Receivers首先处理一些特殊的广播，如：接收到PackageManager发来的应用包移除广播，就会把所有属于该包下的ActivityRecord出栈等，AMS内有两种广播队列，分别是前台广播队列mFgBroadcastQueue保存带FLAG_RECEIVER_FOREGROUND的广播，和后台广播队列mBgBroadcastQueue，先会尝试向并行receivers递送广播，此时会调用到queue.scheduleBroadcastsLocked()，简单地说就是，新建一个BroadcastRecord节点，并插入对应的BroadcastQueue，最后发起实际的广播调度（scheduleBroadcastsLocked()），不光并行处理部分需要一个BroadcastRecord节点，串行处理部分也需要BroadcastRecord节点。也就是说，要激发一次广播，AMS必须构造一个或两个BroadcastRecord节点，并将之插入合适的广播队列。插入成功后，再执行队列的scheduleBroadcastsLocked()动作BroadcastRecord节点内部的receivers列表，记录着和这个广播动作相关的目标receiver信息，该列表内部的子节点可能是ResolveInfo类型的，也可能是BroadcastFilter类型的。ResolveInfo是从PKMS处查到的静态receiver的描述信息，它的源头是PKMS解析的那些AndroidManifest.xml文件。而BroadcastFilter来自于动态注册receiver时，保存在AMS成员变量mReceiverResolver123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332//resultTo：null，resultCode：-resultData：null，map：null，requiredPermission：null//appOp：-1，serialized：false，sticky：falseprivate final int broadcastIntentLocked(ProcessRecord callerApp, String callerPackage, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle map, String requiredPermission, int appOp, boolean ordered, boolean sticky, int callingPid, int callingUid, int userId) &#123; intent = new Intent(intent); // By default broadcasts do not go to stopped apps. //在Android3.1之后，PKMS加强了对“处于停止状态的”应用的管理。如果一个应用在安装后从来没有启动过，或者已经被用户强制停止了，那么这个应用就处于停止状态（stoppedstate）。为了达到精细调整的目的，Android增加了2个flag：FLAG_INCLUDE_STOPPED_PACKAGES和FLAG_EXCLUDE_STOPPED_PACKAGES，以此来表示intent是否要激活“处于停止状态的”应用。而默认则是不激活 intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES); //.... userId = handleIncomingUser(callingPid, callingUid, userId,true, false, \"broadcast\", callerPackage);//权限检测 // Make sure that the user who is receiving this broadcast is started. // If not, we will just skip it. if (userId != UserHandle.USER_ALL &amp;&amp; mStartedUsers.get(userId) == null) &#123; if (callingUid != Process.SYSTEM_UID || (intent.getFlags() &amp; Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) &#123; Slog.w(TAG, \"Skipping broadcast of \" + intent+ \": user \" + userId + \" is stopped\"); return ActivityManager.BROADCAST_SUCCESS; &#125; &#125; /* * Prevent non-system code (defined here to be non-persistent processes) from sending protected broadcasts. */ int callingAppId = UserHandle.getAppId(callingUid); if (callingAppId == Process.SYSTEM_UID || callingAppId == Process.PHONE_UID || callingAppId == Process.SHELL_UID || callingAppId == Process.BLUETOOTH_UID || callingUid == 0) &#123; // Always okay. &#125; else if (callerApp == null || !callerApp.persistent) &#123; //... &#125; // Handle special intents: if this broadcast is from the package // manager about a package being removed, we need to remove all of // its activities from the history stack. final boolean uidRemoved = Intent.ACTION_UID_REMOVED.equals(intent.getAction()); if (Intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction()) || uidRemoved) &#123; if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid, callingUid, -1, true) == PackageManager.PERMISSION_GRANTED) &#123; if (uidRemoved) &#123; final Bundle intentExtras = intent.getExtras(); final int uid = intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1; if (uid &gt;= 0) &#123; BatteryStatsImpl bs = mBatteryStatsService.getActiveStatistics(); synchronized (bs) &#123; bs.removeUidStatsLocked(uid); &#125; mAppOpsService.uidRemoved(uid); &#125; &#125; else &#123; // If resources are unavailable just force stop all // those packages and flush the attribute cache as well. if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())) &#123; String list[] = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST); if (list != null &amp;&amp; (list.length &gt; 0)) &#123; for (String pkg : list) &#123; forceStopPackageLocked(pkg, -1, false, true, true, false, userId, \"storage unmount\"); &#125; sendPackageBroadcastLocked( IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE, list, userId); &#125; &#125; else &#123; Uri data = intent.getData(); String ssp; if (data != null &amp;&amp; (ssp=data.getSchemeSpecificPart()) != null) &#123; boolean removed = Intent.ACTION_PACKAGE_REMOVED.equals( intent.getAction()); if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP, false)) &#123; forceStopPackageLocked(ssp, UserHandle.getAppId( intent.getIntExtra(Intent.EXTRA_UID, -1)), false, true, true, false, userId, removed ? \"pkg removed\" : \"pkg changed\"); &#125; if (removed) &#123; sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REMOVED, new String[] &#123;ssp&#125;, userId); if (!intent.getBooleanExtra(Intent.EXTRA_REPLACING, false)) &#123; mAppOpsService.packageRemoved( intent.getIntExtra(Intent.EXTRA_UID, -1), ssp); // Remove all permissions granted from/to this package removeUriPermissionsForPackageLocked(ssp, userId, true); &#125; &#125; &#125; &#125; &#125; &#125; else &#123; //\"Permission Denial: \" throw new SecurityException(msg); &#125; // Special case for adding a package: by default turn on compatibility mode. &#125; else if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())) &#123; Uri data = intent.getData(); String ssp; if (data != null &amp;&amp; (ssp=data.getSchemeSpecificPart()) != null) &#123; mCompatModePackages.handlePackageAddedLocked(ssp, intent.getBooleanExtra(Intent.EXTRA_REPLACING, false)); &#125; &#125; /* * If this is the time zone changed action, queue up a message that will reset the timezone * of all currently running processes. This message will get queued up before the broadcast * happens. */ if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) &#123; mHandler.sendEmptyMessage(UPDATE_TIME_ZONE); &#125; if (intent.ACTION_CLEAR_DNS_CACHE.equals(intent.getAction())) &#123; mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG); &#125; if (Proxy.PROXY_CHANGE_ACTION.equals(intent.getAction())) &#123; ProxyProperties proxy = intent.getParcelableExtra(\"proxy\"); mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG, proxy)); &#125; // Add to the sticky list if requested. if (sticky) &#123;//false，先忽略 if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid, callingUid) != PackageManager.PERMISSION_GRANTED) &#123; //... throw new SecurityException(msg); &#125; if (requiredPermission != null) &#123; Slog.w(TAG, \"Can't broadcast sticky intent \" + intent+ \" and enforce permission \" + requiredPermission); return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION; &#125; if (intent.getComponent() != null) &#123; throw new SecurityException(\"Sticky broadcasts can't target a specific component\"); &#125; // We use userId directly here, since the \"all\" target is maintained // as a separate set of sticky broadcasts. if (userId != UserHandle.USER_ALL) &#123; // But first, if this is not a broadcast to all users, then // make sure it doesn't conflict with an existing broadcast to // all users. ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get( UserHandle.USER_ALL); if (stickies != null) &#123; ArrayList&lt;Intent&gt; list = stickies.get(intent.getAction()); if (list != null) &#123; int N = list.size(); int i; for (i=0; i&lt;N; i++) &#123; if (intent.filterEquals(list.get(i))) &#123; throw new IllegalArgumentException( \"Sticky broadcast \" + intent + \" for user \" + userId + \" conflicts with existing global broadcast\"); &#125; &#125; &#125; &#125; &#125; ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(userId); if (stickies == null) &#123; stickies = new ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt;(); mStickyBroadcasts.put(userId, stickies); &#125; ArrayList&lt;Intent&gt; list = stickies.get(intent.getAction()); if (list == null) &#123; list = new ArrayList&lt;Intent&gt;(); stickies.put(intent.getAction(), list); &#125; int N = list.size(); int i; for (i=0; i&lt;N; i++) &#123; if (intent.filterEquals(list.get(i))) &#123; // This sticky already exists, replace it. list.set(i, new Intent(intent)); break; &#125; &#125; if (i &gt;= N) &#123; list.add(new Intent(intent)); &#125; &#125; int[] users; if (userId == UserHandle.USER_ALL) &#123; // Caller wants broadcast to go to all started users. users = mStartedUserArray; &#125; else &#123; // Caller wants broadcast to go to one specific user. users = new int[] &#123;userId&#125;; &#125; // Figure out who all will receive this broadcast. List receivers = null; List&lt;BroadcastFilter&gt; registeredReceivers = null; // Need to resolve the intent to interested receivers... //FLAG_RECEIVER_REGISTERED_ONLY标识标识的是动态注册的广播，至于静态注册的广播是通过PackageManager获得 if ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY)== 0) &#123; receivers = collectReceiverComponents(intent, resolvedType, users); &#125; if (intent.getComponent() == null) &#123; //找到符合的接受者（详细之后再看），返回结果按照优先级排序 registeredReceivers = mReceiverResolver.queryIntent(intent,resolvedType, false, userId); &#125; //是否替代 final boolean replacePending =(intent.getFlags()&amp;Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0; int NR = registeredReceivers != null ? registeredReceivers.size() : 0; if (!ordered &amp;&amp; NR &gt; 0) &#123; // If we are not serializing this broadcast, then send the // registered receivers separately so they don't wait for the // components to be launched. final BroadcastQueue queue = broadcastQueueForIntent(intent); BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, resolvedType, requiredPermission, appOp, registeredReceivers, resultTo, resultCode, resultData, map, ordered, sticky, false, userId); final boolean replaced = replacePending &amp;&amp; queue.replaceParallelBroadcastLocked(r); if (!replaced) &#123; queue.enqueueParallelBroadcastLocked(r); queue.scheduleBroadcastsLocked();// &#125; //上面完成了无序广播的调度 registeredReceivers = null; NR = 0; &#125; //看来是先处理动态注册的，之后才是静态注册的 // Merge into one list. int ir = 0; //receiver记录的是在清单文件夹静态注册的广播 if (receivers != null) &#123; // A special case for PACKAGE_ADDED: do not allow the package // being added to see this broadcast. This prevents them from // using this as a back door to get run as soon as they are // installed. Maybe in the future we want to have a special install // broadcast or such for apps, but we'd like to deliberately make // this decision. //防止监听自己的应用安装后自己收到广播而自动启动 String skipPackages[] = null; if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) &#123; Uri data = intent.getData(); if (data != null) &#123; String pkgName = data.getSchemeSpecificPart(); if (pkgName != null) &#123; skipPackages = new String[] &#123; pkgName &#125;; &#125; &#125; &#125; else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) &#123; skipPackages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST); &#125; //移除特定的广播任务 if (skipPackages != null &amp;&amp; (skipPackages.length &gt; 0)) &#123; for (String skipPackage : skipPackages) &#123; if (skipPackage != null) &#123; int NT = receivers.size(); for (int it=0; it&lt;NT; it++) &#123; ResolveInfo curt = (ResolveInfo)receivers.get(it); if (curt.activityInfo.packageName.equals(skipPackage)) &#123; receivers.remove(it); it--; NT--; &#125; &#125; &#125; &#125; &#125; //如果是无序广播，在上面NR已置为了0，下面是用于合并有序和静态注册的广播 int NT = receivers != null ? receivers.size() : 0;//静态注册的广播数量 int it = 0; ResolveInfo curt = null; BroadcastFilter curr = null; while (it &lt; NT &amp;&amp; ir &lt; NR) &#123; if (curt == null) &#123; curt = (ResolveInfo)receivers.get(it); &#125; if (curr == null) &#123; curr = registeredReceivers.get(ir); &#125; if (curr.getPriority() &gt;= curt.priority) &#123; // Insert this broadcast record into the final list. receivers.add(it, curr); ir++; curr = null; it++; NT++; &#125; else &#123; // Skip to the next ResolveInfo in the final list. it++; curt = null; &#125; &#125; &#125; while (ir &lt; NR) &#123; if (receivers == null) &#123; receivers = new ArrayList(); &#125; receivers.add(registeredReceivers.get(ir)); ir++; &#125; //下面的操作和处理无序广播一样 if ((receivers != null &amp;&amp; receivers.size() &gt; 0)|| resultTo != null) &#123; BroadcastQueue queue = broadcastQueueForIntent(intent); //resultTo：null，resultCode：-resultData：null，map：null，requiredPermission：null //appOp：-1，serialized：false，sticky：false BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, resolvedType, requiredPermission, appOp, receivers, resultTo, resultCode, resultData, map, ordered, sticky, false, userId); &#125; boolean replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r); if (!replaced) &#123; queue.enqueueOrderedBroadcastLocked(r); queue.scheduleBroadcastsLocked(); &#125; &#125; return ActivityManager.BROADCAST_SUCCESS;&#125; scheduleBroadcastsLocked调度执行以上不管是处理有序广播还是无序广播，最重要的无疑是scheduleBroadcastsLocked方法调用123456789BroadcastQueue.javapublic void scheduleBroadcastsLocked() &#123; if (mBroadcastsScheduled) &#123; return; &#125; mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this)); mBroadcastsScheduled = true; &#125; 处理BROADCAST_TIMEOUT_MSG消息 12345BroadcastQueue.javacase BROADCAST_INTENT_MSG: &#123; processNextBroadcast(true);&#125; break; 处理广播所有的静态receiver都是串行处理的，而动态receiver则会按照发广播时指定的方式，进行“并行”或“串行”处理。能够并行处理的广播，其对应的若干receiver一定都已经存在了，不会牵扯到启动新进程的操作，所以可以在一个while循环中，一次性全部deliver。而有序广播，则需要一个一个地处理，其滚动处理的手段是发送事件，也就是说，在一个receiver处理完毕后，会利用广播队列（BroadcastQueue）的mHandler，发送一个BROADCAST_INTENT_MSG事件，从而执行下一次的processNextBroadcast的调度 处理无序广播遍历并行列表（mParallelBroadcasts）的每一个BroadcastRecord以及其中的receivers列表。对于无序广播而言，receivers列表中的每个子节点是个BroadcastFilter。我们直接通过方法deliverToRegisteredReceiverLocked将广播递送出去即可 1234567891011121314151617181920212223242526272829final void processNextBroadcast(boolean fromMsg) &#123; synchronized(mService) &#123; BroadcastRecord r; mService.updateCpuStats(); if (fromMsg) &#123; //表示BROADCAST_INTENT_MSG消息已经处理完了 mBroadcastsScheduled = false; &#125; // First, deliver any non-serialized broadcasts right away. while (mParallelBroadcasts.size() &gt; 0) &#123; //BroadcastRecord类型的r内部记录了该广播的所有接收者 r = mParallelBroadcasts.remove(0); r.dispatchTime = SystemClock.uptimeMillis(); r.dispatchClockTime = System.currentTimeMillis(); final int N = r.receivers.size();//接收者数量 for (int i=0; i&lt;N; i++) &#123; Object target = r.receivers.get(i); //把非有序队列中各个广播发送给广播接收者 deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false); &#125; addBroadcastToHistoryLocked(r); &#125; //....... &#125; &#125; BroadcastQueue#deliverToRegisteredReceiverLocked先进行的权限判断、操作的检测、目标进程是否启动等操作，如果都OK，前面可知BroadcastFilter用来关联了动态注册的IIntentReceiver和IntentFilter,所以拿到一个BroadcastFilter接可以知道宿主IIntentReceiver，最后调用performReceiveLocked123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//order=false；private final void deliverToRegisteredReceiverLocked(BroadcastRecord r,BroadcastFilter filter, boolean ordered) &#123; boolean skip = false; if (filter.requiredPermission != null) &#123; int perm = mService.checkComponentPermission(filter.requiredPermission,r.callingPid, r.callingUid, -1, true); if (perm != PackageManager.PERMISSION_GRANTED) &#123; //Permission Denial: broadcasting skip = true; &#125; &#125; if (!skip &amp;&amp; r.requiredPermission != null) &#123; int perm = mService.checkComponentPermission(r.requiredPermission, filter.receiverList.pid, filter.receiverList.uid, -1, true); if (perm != PackageManager.PERMISSION_GRANTED) &#123; //Permission Denial: receiving skip = true; &#125; &#125; if (r.appOp != AppOpsManager.OP_NONE) &#123; int mode = mService.mAppOpsService.noteOperation(r.appOp, filter.receiverList.uid, filter.packageName); if (mode != AppOpsManager.MODE_ALLOWED) &#123; if (DEBUG_BROADCAST) Slog.v(TAG, \"App op \" + r.appOp + \" not allowed for broadcast to uid \" + filter.receiverList.uid + \" pkg \" + filter.packageName); skip = true; &#125; &#125; if (!skip) &#123; skip = !mService.mIntentFirewall.checkBroadcast(r.intent, r.callingUid, r.callingPid, r.resolvedType, filter.receiverList.uid); &#125; if (filter.receiverList.app == null || filter.receiverList.app.crashing) &#123; Slog.w(TAG, \"Skipping deliver [\" + mQueueName + \"] \" + r+ \" to \" + filter.receiverList + \": process crashing\"); skip = true; &#125; if (!skip) &#123; // If this is not being sent as an ordered broadcast, then we // don't want to touch the fields that keep track of the current // state of ordered broadcasts. if (ordered) &#123;//false r.receiver = filter.receiverList.receiver.asBinder();//记录的是IIntentReceiver的Binder本地对象 r.curFilter = filter; filter.receiverList.curBroadcast = r; r.state = BroadcastRecord.CALL_IN_RECEIVE; if (filter.receiverList.app != null) &#123; // Bump hosting application to no longer be in background scheduling class. Note that we can't do that if there // isn't an app... but we can only be in that case for things that directly call the IActivityManager API, which // are already core system stuff so don't matter for this. r.curApp = filter.receiverList.app; filter.receiverList.app.curReceiver = r; mService.updateOomAdjLocked(r.curApp, true); &#125; &#125; try &#123; //filter.receiverList.app:ApplicationThread //filter.receiverList.receiver： performReceiveLocked(filter.receiverList.app, filter.receiverList.receiver, new Intent(r.intent), r.resultCode, r.resultData, r.resultExtras, r.ordered, r.initialSticky, r.userId); if (ordered) &#123; r.state = BroadcastRecord.CALL_DONE_RECEIVE; &#125; &#125; catch (RemoteException e) &#123; Slog.w(TAG, \"Failure sending broadcast \" + r.intent, e); if (ordered) &#123; r.receiver = null; r.curFilter = null; filter.receiverList.curBroadcast = null; if (filter.receiverList.app != null) &#123; filter.receiverList.app.curReceiver = null; &#125; &#125; &#125; &#125;&#125; 6.3 BroadcastQueue#performReceiveLocked接着如果当前进程是存在的且已经启动，通过ApplicationThread来进行回调但实际上还是通过IIntentReceiver来回调，123456789101112131415BroadcastQueue.javaprivate static void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver, Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123; // Send the intent to the receiver asynchronously using one-way binder calls. if (app != null &amp;&amp; app.thread != null) &#123; // If we have an app thread, do the call through that so it is correctly ordered with other one-way calls. app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode, data, extras, ordered, sticky, sendingUser, app.repProcState); &#125; else &#123; receiver.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser); &#125;&#125; 6.4 IIntentReceiver#performReceive1234567891011121314151617181920212223242526LoadedApk#ReceiverDispatcher#IIntentReceiverpublic void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123; //获取宿主ReceiverDispatcher LoadedApk.ReceiverDispatcher rd = mDispatcher.get(); if (rd != null) &#123; rd.performReceive(intent, resultCode, data, extras,ordered, sticky, sendingUser); &#125; else &#123; // The activity manager dispatched a broadcast to a registered // receiver in this process, but before it could be delivered the // receiver was unregistered. Acknowledge the broadcast on its // behalf so that the system's broadcast sequence can continue. if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,\"Finishing broadcast to unregistered receiver\"); IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; if (extras != null) &#123; extras.setAllowFds(false); &#125; mgr.finishReceiver(this, resultCode, data, extras, false); &#125; catch (RemoteException e) &#123; Slog.w(ActivityThread.TAG, \"Couldn't finish broadcast to unregistered receiver\"); &#125; &#125; &#125; 6.5 ReceiverDispatcher#performReceive构造Args封装成一个消息,Args继承自PendingResult实现了Runnable接口1234567891011121314LoadedApk#ReceiverDispatcherpublic void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123; Args args = new Args(intent, resultCode, data, extras, ordered,sticky, sendingUser); if (!mActivityThread.post(args)) &#123; if (mRegistered &amp;&amp; ordered) &#123; IActivityManager mgr = ActivityManagerNative.getDefault(); args.sendFinished(mgr); &#125; &#125;&#125; 6.6 Args#run但是构造一个Args对象又有什么用？或者说PendingResult的作用是什么？这个PendingResult可以在BroadcastReceiver#onReceive方法中通过goAsync方法返回，表示的结果的状态，在一个广播处理完之后必须调用其finish方法（这个在回调onReceiver方法后会自动回调）,finish方法用来完成某个广播，对于一个已经处理完的广播，如果是有序广播，接收完之后需要向AMS发一个回包，以便AMS可以将这个有序广播发送给下一个广播接收者。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647final class Args extends BroadcastReceiver.PendingResult implements Runnable &#123; private Intent mCurIntent; private final boolean mOrdered; public Args(Intent intent, int resultCode, String resultData, Bundle resultExtras, boolean ordered, boolean sticky, int sendingUser) &#123; super(resultCode, resultData, resultExtras, mRegistered ? TYPE_REGISTERED : TYPE_UNREGISTERED, ordered, sticky, mIIntentReceiver.asBinder(), sendingUser); mCurIntent = intent; mOrdered = ordered; &#125; public void run() &#123; final BroadcastReceiver receiver = mReceiver;//具体注册的BroadcastReceiver，保存在ReceiverDispatcher成员变量 final boolean ordered = mOrdered; final IActivityManager mgr = ActivityManagerNative.getDefault(); final Intent intent = mCurIntent; mCurIntent = null; if (receiver == null || mForgotten) &#123; if (mRegistered &amp;&amp; ordered) &#123; sendFinished(mgr); &#125; return; &#125; try &#123; ClassLoader cl = mReceiver.getClass().getClassLoader(); intent.setExtrasClassLoader(cl); setExtrasClassLoader(cl); receiver.setPendingResult(this); receiver.onReceive(mContext, intent);//回调具体的Receiver &#125; catch (Exception e) &#123; if (mRegistered &amp;&amp; ordered) &#123; if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,\"Finishing failed broadcast to \" + mReceiver); sendFinished(mgr); &#125; //... &#125; if (receiver.getPendingResult() != null) &#123; finish(); &#125; &#125;&#125; (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"app","slug":"app","permalink":"https://austinxishou.github.io/tags/app/"},{"name":"sendBroadcast","slug":"sendBroadcast","permalink":"https://austinxishou.github.io/tags/sendBroadcast/"}]},{"title":"Android自启动管理功能","date":"2017-11-01T07:52:08.374Z","path":"2017/11/01/android/android-autostart-managerment/","text":"About基本功能: 获取设备上所有应用的开机启动完成的广播接收者,同时区分系统应用和用户应用.然后,提供界面接口给用户,统一管理应用的自启动功能,这样可以提升系统的运行性能和待机时长; 获取所有receivers 区分是否使能获取包含被禁止自启动receiver的信息1List&lt;ResolveInfo&gt; forbidInfoList = mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_DISABLED_COMPONENTS); 获取所有使能的 receivers1List&lt;ResolveInfo&gt; allowInfoList = mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_RECEIVERS); 两个列表比较,标志receivers是否开启12345for(int k=0; k&lt;allowInfoList.size(); k++)&#123; if( allowInfoList.get(k).activityInfo.packageName.equals(packageName) )&#123; isEnable =true; &#125;&#125; 判断是否为系统应用通过ApplicationInfo.FLAG_SYSTEM标志,判断是否为系统应用1234if((forbidInfoList.get(i).activityInfo.applicationInfo.flags&amp;ApplicationInfo.FLAG_SYSTEM)==1|| (forbidInfoList.get(i).activityInfo.applicationInfo.flags&amp;ApplicationInfo.FLAG_UPDATED_SYSTEM_APP)==1)&#123; isSystem = true;&#125; 判断是否运行并获取内存占用大小123456789101112131415161718192021222324252627float memUsed = 0;ArrayList&lt;Integer&gt; pid = new ArrayList&lt;Integer&gt;(runningApps.size());//循环处理正在运行进程for(int k=0; k&lt;runningApps.size(); k++)&#123; if(runningApps.get(k).processName.equals(packageName))&#123; // Log.e(\"ycltest\",\"in runningApps list find the right process,handle it\"); pid.add( Integer.valueOf(runningApps.get(k).pid) ); &#125;else&#123; continue; &#125;&#125;if( pid.size() == 0)&#123; isRun = false;&#125;else&#123; //获取内存大小 isRun = true; int[] pids = new int[pid.size()]; for (int num=0; num&lt;pid.size(); num++) &#123; pids[num] = pid.get(num).intValue(); &#125; Debug.MemoryInfo[] mi = mActivityManager.getProcessMemoryInfo(pids); for (int num=0; num&lt;mi.length; num++) &#123; memUsed += (float)(mi[num].getTotalPrivateDirty()+mi[num].getTotalPss())/1024; &#125;&#125; 关闭和开启Receiver通过PackageManager.setComponentEnabledSetting方法,关闭和开启Receiver 1234567891011121314private void updatePackageReceiverState( PackageEntry item, boolean isChecked)&#123; String packageReceiverList[] = item.getPackageReceivers().split(\";\"); int newState = isChecked ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED : PackageManager.COMPONENT_ENABLED_STATE_DISABLED; for (int i=0; i&lt;packageReceiverList.length; i++) &#123; if( packageReceiverList[i] != null )&#123; ComponentName comName = new ComponentName(item.getPackageName(), packageReceiverList[i]); int flag = 0; if( item.getPackageName().equals(\"com.android.settings\") )&#123; flag = PackageManager.DONT_KILL_APP; &#125; mPackageManager.setComponentEnabledSetting(comName,newState, flag); &#125; &#125;&#125; 其他功能其他功能包括,列表排序,列表更新,无应用列表图片显示等,不在这里详细展开!(function(){ var bp = document.createElement(‘script’); var curProtocol = window.location.protocol.split(‘:’)[0]; if (curProtocol === ‘https’) { bp.src = ‘https://zz.bdstatic.com/linksubmit/push.js‘; } else { bp.src = ‘http://push.zhanzhang.baidu.com/push.js‘; } var s = document.getElementsByTagName(“script”)[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == &quot;http:&quot;) ? &quot;http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;:&quot;https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;; document.write(&apos;&lt;script src=&quot;&apos; + sozzsrc + &apos;&quot; id=&quot;sozz&quot;&gt;&lt;\\/script&gt;&apos;); })();","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"app","slug":"app","permalink":"https://austinxishou.github.io/tags/app/"}]},{"title":"Android ndk 编程指南","date":"2017-11-01T07:52:08.221Z","path":"2017/11/01/android/Android-ndk-dev-note/","text":"NDK 的基础概念ndk-build ndk-build 脚本用于在 NDK 中心启动构建脚本。这些脚本： * 自动探测您的开发系统和应用项目文件以确定要构建的内容。 * 生成二进制文件。 * 将二进制文件复制到应用的项目路径。 原生共享库：NDK 从原生源代码构建这些库或 .so 文件。原生静态库：NDK 也可构建静态库或 .a 文件，您可以关联到其他库。Java 原生接口 (JNI)：JNI 是 Java 和 C++ 组件用以互相沟通的接口。 本指南假设您具备 JNI 知识；其相关信息请查阅 Java原生接口规范。应用二进制界面 (ABI)：ABI 可以非常精确地定义应用的机器代码在运行时如何与系统交互。 NDK 根据这些定义构建 .so 文件。 不同的 ABI 对应不同的架构：NDK 包含对 ARMEABI（默认）、MIPS 和 x86 的 ABI 支持。 构建项目Android.mkAbout Android.mk 文件位于项目 jni/ 目录的子目录中，用于向构建系统描述源文件和共享库。 它实际上是构建系统解析一次或多次的微小 GNU makefile 片段。 Android.mk 文件用于定义 Application.mk、构建系统和环境变量所未定义的项目范围设置。 它还可替换特定模块的项目范围设置。 Android.mk 的语法用于将源文件分组为模块。 模块是静态库、共享库或独立可执行文件。 可在每个 Android.mk 文件中定义一个或多个模块，也可在多个模块中使用同一个源文件。 构建系统只会将共享库放入应用软件包。 此外，静态库可生成共享库。 变量和宏 构建系统提供许多可用于 Android.mk 文件中的变量。其中许多变量已预先赋值。 另一些变量由您赋值。 除了这些变量之外，您还可以定义自己的任意变量。在定义变量时请注意，NDK 构建系统会预留以下变量名称： * 以 LOCAL_ 开头的名称，例如 LOCAL_MODULE。 * 以 PRIVATE_、NDK_ 或 APP 开头的名称。构建系统在内部使用这些变量。 * 小写名称，例如 my-dir。构建系统也是在内部使用这些变量。 * 如果为了方便而需要在 Android.mk 文件中定义自己的变量，建议在名称前附加 MY_。 BUILD_SHARED_LIBRARY编译目标共享库.请注意，使用此脚本要求您至少已为 LOCAL_MODULE 和 LOCAL_SRC_FILES 赋值 BUILD_STATIC_LIBRARY用于构建静态库的 BUILD_SHARED_LIBRARY 的变体。构建系统不会将静态库复制到您的项目/软件包，但可能使用它们构建共享库,LOCAL_STATIC_LIBRARIES 和 LOCAL_WHOLE_STATIC_LIBRARIES PREBUILT_SHARED_LIBRARY指向用于指定预建共享库的构建脚本。与 BUILD_SHARED_LIBRARY 和 BUILD_STATIC_LIBRARY 的情况不同，这里的 LOCAL_SRC_FILES 值不能是源文件， 而必须是指向预建共享库的单一路径，例如 foo/libfoo.so。 使用此变量的语法为：1include $(PREBUILT_SHARED_LIBRARY) 也可使用 LOCAL_PREBUILTS 变量引用另一个模块中的预建库。 PREBUILT_STATIC_LIBRARY与 PREBUILT_SHARED_LIBRARY 相同，但用于预构建的静态库。 TARGET_ARCHAndroid 开放源代码项目所指定的目标 CPU 架构的名称。 TARGET_PLATFORM作为构建系统目标的 Android API 级别号。 TARGET_ARCH_ABI当构建系统解析此 Android.mk 文件时，此变量将 CPU 和架构的名称存储到目标。 模块描述变量12345678910111213141516LOCAL_PATH := $(call my-dir)LOCAL_MODULE := &quot;foo&quot;LOCAL_SRC_FILESLOCAL_CPP_EXTENSION := .cxx .cpp .cc \\\\使用此可选变量为 C++ 源文件指明 .cpp 以外的文件扩展名。LOCAL_CPP_FEATURES \\\\可以使用此可选变量指明您的代码依赖于特定 C++ 功能。LOCAL_C_INCLUDES \\\\使用此可选变量指定相对于 NDK root 目录的路径列表，以便在编译所有源文件（C、C++ 和 Assembly）时添加到 include 搜索路径。LOCAL_CFLAGS \\\\此可选变量为构建系统设置在构建 C 和 C++ 源文件时要传递的编译器标志。LOCAL_STATIC_LIBRARIES \\\\此变量用于存储当前模块依赖的静态库模块列表。LOCAL_SHARED_LIBRARIES \\\\此变量是此模块在运行时依赖的共享库模块列表。 此信息在链接时需要，并且会在生成的文件中嵌入相应的信息。LOCAL_WHOLE_STATIC_LIBRARIES \\\\此变量是 LOCAL_STATIC_LIBRARIES 的变体，表示链接器应将相关的库模块视为整个存档。LOCAL_LDLIBS \\\\此变量包含在构建共享库或可执行文件时要使用的其他链接器标志列表。 它可让您使用 -l 前缀传递特定系统库的名称。LOCAL_LDFLAGS \\\\构建共享库或可执行文件时供构建系统使用的其他链接器标志列表。LOCAL_ALLOW_UNDEFINED_SYMBOLS \\\\若构建系统在尝试构建共享库时遇到未定义的引用，将会引发“未定义的符号”错误。 此错误可帮助您捕获源代码中的缺陷。LOCAL_ARM_MODE \\\\LOCAL_ARM_NEON \\\\LOCAL_DISABLE_NO_EXECUTE \\\\ NDK 提供的函数宏123456my-dirall-subdir-makefilesthis-makefileparent-makefilegrand-parent-makefileimport-module Application.mkAbout Application.mk 文件实际上是定义要编译的多个变量的微小 GNU Makefile 片段。它通常位于 $PROJECT/jni/ 下，其中 $PROJECT 指向应用的项目目录。 另一种方式是将其放在顶级 $NDK/apps/ 目录的子目录下。 变量 APP_PROJECT_PATH 此变量用于存储应用项目根目录的绝对路径。 APP_OPTIM 此可选变量定义为 release 或 debug。在构建应用的模块时可使用它来更改优化级别。 APP_CFLAGS 此变量用于存储构建系统在为任何模块编译任何 C 或 C++ 源代码时传递到编译器的一组 C 编译器标志。 APP_CPPFLAGS 此变量包含构建系统在仅构建 C++ 源文件时传递到编译器的一组 C++ 编译器标志。 APP_LDFLAGS 构建系统在链接应用时传递的一组链接器标志。 APP_BUILD_SCRIPT NDK 构建系统在 jni/ 下查找名称为 Android.mk 的文件。如果要改写此行为，可以定义 APP_BUILD_SCRIPT 指向替代构建脚本。 APP_ABI NDK 构建系统为 armeabi ABI 生成机器代码。 ndk-build ndk-build 文件是 Android NDK r4 中引入的一个 shell 脚本。其用途是调用正确的 NDK 构建脚本 CMakeAndroid Studio 2.2 之后增加了 Cmake工具支持, 独立工具链Android NDK 原生 API (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"ndk","slug":"ndk","permalink":"https://austinxishou.github.io/tags/ndk/"}]},{"title":"awesome-android��Դ�ռ�","date":"2017-11-01T07:52:07.965Z","path":"2017/11/01/android/awesome-android-resource-collection/","text":"֪����վֵ�ù�ע��Android����վ�� ����վ�� Ӣ��վ�� Android Arsenal (function(){ var bp = document.createElement(‘script’); var curProtocol = window.location.protocol.split(‘:’)[0]; if (curProtocol === ‘https’) { bp.src = &apos;https://zz.bdstatic.com/linksubmit/push.js&apos;; } else { bp.src = &apos;http://push.zhanzhang.baidu.com/push.js&apos;; } var s = document.getElementsByTagName(“script”)[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == “http:”) ? “http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;:&quot;https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a“; document.write(‘&lt;\\/script&gt;’);})();","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"github","slug":"github","permalink":"https://austinxishou.github.io/tags/github/"},{"name":"awesome","slug":"awesome","permalink":"https://austinxishou.github.io/tags/awesome/"}]},{"title":"Java编程资源收集awesome-java","date":"2017-11-01T07:52:07.616Z","path":"2017/11/01/android/awesome-java-tech-collection/","text":"简介平时编程时都会找一些很好的资源,所以在这里统一的整理收录,类似于Github上的Awesome - XXX 系列的资源.内容包括：构建工具、数据库、框架、模板、安全、代码分析、日志、第三方库、书籍、Java 站点等等。** 类似参考目录 awesome-javaawesome-java-cn 构建工具 Gradle：基于XML的构建管理工具。官网 Buck：Facebook构建工具。官网 Apache Maven：Maven是一款声明式构建及依赖管理工具，采用约定优于配置方式进行管理。相对Apache Ant更推荐使用Maven，前者采用了过程式管理，维护相对困难。官网 Bazel：来自Google的构建工具，可以快速、可靠地构建代码。官网 ## Web框架用于处理Web应用程序不同层次间通讯的框架。 Apache Tapestry：基于组件的框架，使用Java创建动态、强健的、高度可扩展的Web应用程序。 官网 GUI JavaFX：Swing的后继者。官网 IDE Eclipse：老牌开源项目，支持多种插件和编程语言。官网 Scala IDE：一款基于Eclipse开源平台打造的Scala集成开发环境。官网 NetBeans：为多种技术提供集成化支持，包括Java SE、Java EE、数据库访问、HTML5等。官网 (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"awesome-java","slug":"awesome-java","permalink":"https://austinxishou.github.io/tags/awesome-java/"}]},{"title":"Android工程编译错误集锦","date":"2017-11-01T07:49:16.524Z","path":"2017/11/01/android/android-build-project-error/","text":"工程编译类Gradle 错误 Failed to complete Gradle execution.问题描述: 更新Android studio 2.3后,出现Gradle 错误 123Error:Failed to complete Gradle execution.Cause:Could not create parent directory for lock file C:\\Users\\Administrator\\.gradle\\wrapper\\dists\\D:AustinDevtoolsgradlegradle-2.10-all\\dn4qn6r39kukmjs5vguem1ak2\\D:AustinDevtoolsgradlegradle-2.10-all.zip.lck 解决方法 找到工程的build.gradle,修改classpath ‘com.android.tools.build:gradle:2.1.0’为classpath ‘com.android.tools.build:gradle:2.3.0’ AAPT err: libpng error: Not a PNG file 问题描述 Android Studio AAPT err: libpng error: Not a PNG file 问题说明: 问题的根源是,项目的png文件已经通过其他工具提前优化过,但是AAPT工具在编译工程时再次进行优化,但是不能识别该图片之前使用的是什么工具,所以编译出错;解决办法只需要把aapt的图片编译优化关掉即可 解决方法 aaptOptions.cruncherEnabled = false 123456789101112131415161718android &#123; compileSdkVersion 25 buildToolsVersion \"25.0.2\" aaptOptions.cruncherEnabled = false useLibrary 'org.apache.http.legacy' defaultConfig &#123; applicationId \"com.Mankewan.manke\" minSdkVersion 15 targetSdkVersion 25 &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt' &#125; &#125;&#125; Gradle Could not create parent directory for lock file问题描述Error:Could not create parent directory for lock file C:\\Users\\Administrator.gradle\\wrapper\\dists\\D:AustinDevtoolsgradlegradle-3.4.1-all…gradlegradle-3.4.1-all.zip.lck 解决方法 在Android studio 设置中,把gradle设置成 Use local gradle distribution Android 支持库问题描述 Error:Could not find method compile() for arguments [com.android.support:appcompat-v7:19.1.0] on root project ‘Aaaa’. Please install the Android Support Repository from the Android SDK Manager. 问题说明Android的支持库位置声明错误,应该放在模块的gradle文件中,而不是顶层的gradle文件中 You’ve put your dependencies block in the wrong build.gradle file. Instead of the top-level build file, put it in your module’s build file instead. 解决方法在模块的gradle文件中,添加 123dependencies &#123; compile 'com.android.support:appcompat-v7:19.1.0'&#125; Android程序报错程序包org.apache.http不存在问题的解决方法问题描述 Android程序报错程序包org.apache.http不存在问题的解决方法 问题说明 Android 6.0已经不支持HttpClient” 解决方法 Android 6.0（api 23）已经不支持HttpClient了，在build.gradle中 加入 useLibrary ‘org.apache.http.legacy’就可以 123456789101112131415161718android &#123; compileSdkVersion 25 buildToolsVersion \"25.0.2\" aaptOptions.cruncherEnabled = false useLibrary 'org.apache.http.legacy' defaultConfig &#123; applicationId \"com.Mankewan.manke\" minSdkVersion 15 targetSdkVersion 25 &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt' &#125; &#125;&#125; Python 工作环境错误问题描述: 最近在写一个Python程序的时候，使用from selenium import webdriver,在run的时候却出现ImportError: cannot import name webdriver的提示，但是在Python IDLE里面跑却没有错误。很是疑惑，谷歌一下才发现有人已经在stackoverflow里面提出类似问题了，原因如下，在当前目录有个名叫selenium的文件，Python会先导入这个文件，然后再导入标准库里面的selenium.py 解决方法1234##可以使用import selenium print selenium.__file__ ##去看打印出的文件路径，如果不是下面类似的C:\\Python27\\lib\\site-packages\\selenium-2.31.0-py2.7.egg\\selenium\\__init__.pyc，需要把当前目录下的文件删除或者重命名。(function(){ var bp = document.createElement(‘script’); var curProtocol = window.location.protocol.split(‘:’)[0]; if (curProtocol === ‘https’) { bp.src = ‘https://zz.bdstatic.com/linksubmit/push.js‘; } else { bp.src = ‘http://push.zhanzhang.baidu.com/push.js‘; } var s = document.getElementsByTagName(“script”)[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == &quot;http:&quot;) ? &quot;http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;:&quot;https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;; document.write(&apos;&lt;script src=&quot;&apos; + sozzsrc + &apos;&quot; id=&quot;sozz&quot;&gt;&lt;\\/script&gt;&apos;); })();","tags":[{"name":"android gradle aapt","slug":"android-gradle-aapt","permalink":"https://austinxishou.github.io/tags/android-gradle-aapt/"}]},{"title":"Android Studio中使用ButterKnife注解框架","date":"2017-11-01T07:49:15.470Z","path":"2017/11/01/android/androidstudio-import-butterKnife-framework/","text":"About 比较复杂的布局文件中，会定义众多的view，在activity中使用findViewById逐个初始化，也是挺繁琐的一项工作，喜欢偷懒的程序员，一定会喜欢ButterKnife的，它大大的简化了这一步骤，只需要鼠标点击三下就OK了。下面是android ButterKnife Zelezny的github上的一个动态使用流程图： 使用方法安装ButterKnife插件 File –&gt; Settings –&gt; Plugins –&gt; Browse repositories 插件安装 查找ButterKnife插件，安装 查找ButterKnife插件 重启Android Studio 使用ButterKnife插件 添加jar包 右键Module，Open Module Settings切换到Dependencies，点击右侧的“+”，选择“Library Dependency” 搜索ButterKnife，添加jar包 生成注解 右键layout的ID，点击“Generate” 选择“Generate Butterknife Injections” 生成注解 (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"butterknife","slug":"butterknife","permalink":"https://austinxishou.github.io/tags/butterknife/"}]},{"title":"selenium相关技术要点总结","date":"2017-11-01T07:46:53.556Z","path":"2017/11/01/python/selenium-resource-collection/","text":"selenium 相关资料文档Selenium Python BindingsSelenium DocumentationWebDriver Living Document 网站techbeamerssoftwaretestingstudiotoolsqaWebDriver中文社区乙醇的blog灰蓝博客灰蓝GITHUB 学习路径 学习路径-成神之路业内牛人 hyddd（陈曦明） ‘FirefoxWebElement’ object is not iterable.wcommonFeed &gt; ul:nth-child(2) &gt; li:nth-child(13) &gt; div:nth-child(2) 相关技术excel读写操作xlrd、xlwt操作excel文件Selenium2+Python–操作Excel读写 xml读写操作json-yaml读写操作日志模块logging库Selenium2+Python–日志管理实例 自动发送报告-Jenkins界面-Django、flask、web2py、web.py打包成exepy2exeAbout 写好了Python selenium脚本，到其他机器上运行，还得要在其他机器上也装一套Python的环境，尤其在你用了一些第三方库的时候，甚至还要顾及操作系统是32位还是64位，是不是很坑，如果能打成一个exe就好了，不论32位还是64位，只要拷过去，安装合适版本的浏览器就行了。今天博主就带你将你的py脚本打包成一个exe 123456789101112131415C:\\Users\\Administrator&gt;pip search py2exepy-exe-builder (0.1) - Uses py2exe to create small exe stubs that leverage a full python installation, rather than packing the required pyc files in to the executable.Manual-de-Py2Exe-en-Espa-ol (1.0) - Manual de Py2Exe en Espa帽olPyBuilder-for-Py2exe (0.3) - A tool to asist in compiling python scripts with py2exepy2exe (0.9.2.2) - Build standalone executables for Windows (python 3 version)py2exe2msi (0.0.2) - An easy way to create Windows standalone applications in Pythonpy2exe_py2 (0.6.9) - A wheel of Py2exe for Python 2unpy2exe (0.3) - Extract pyc files from py2exe executable. 打开CMD窗口，将工作目录切换到python文件所在文件夹，并输入命令“python setup.py py2exe” (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"selenium","slug":"selenium","permalink":"https://austinxishou.github.io/tags/selenium/"}]},{"title":"Krpano入门笔记","date":"2017-11-01T07:42:37.640Z","path":"2017/11/01/krpano/krpano-note/","text":"目录 Krpano Droplet MAKE PANO (NORMAL) MAKE PANO (MULTIRES) MAKE PANO (SINGLESWF) MAKE PANO (FLAT) MAKE VTOUR (NORMAL) MAKE VTOUR (MULTIRES) MAKE OBJECT Convert SPHERE to CUBE Convert CUBE to SPHERE Encrypt XML vtour 文件夹说明 vtour 文件夹结构 vtour 运作机制 krpano XML结构 Krpano 内置元素说明 GitHub: nodeKrpano Krpano DropletMAKE PANO (NORMAL)用法说明 生成普通 (=单分辨率) 全景 制作典型的 360 度全景 全部全景图将会一次性载入. 默认下方块最大变长为 2048 像素(可以在配置文件中修改) 包括默认的导航皮肤 支持 Flash 和 HTML5 Droplet 说明 配置文件: normal.config 默认模版/皮肤配置文件: defaultbuttons.skin MAKE PANO (MULTIRES)用法说明 生成多分辨率全景 制作所有类型的全景 只有特定的切片在需要时载入 没有尺寸/分辨率限制 包含默认的导航皮肤 支持 Flash 和 HTML5 Droplet 说明 配置文件: multiresconfig默认模版/皮肤配置文件: defaultbuttonsskin MAKE PANO (SINGLESWF)用法说明 生成普通 (=单分辨率) 全景同时将所有文件嵌在一个SWF文件中只输出一个SWF文件和一个HTML文件 制作典型的360度全景 全部全景图将会一次性载入 默认下方块最大变长为2048像素(可以在配置文件中修改) 包含默认的导航皮肤 仅支持 Flash Droplet 说明 配置文件: singleswfconfig默认模版/皮肤配置文件: defaultbuttonsskin MAKE PANO (FLAT)用法说明 生成平面切片多分辨率图像 制作平面图像 输出时既定为平面图像 只有特定的切片在需要时载入 没有尺寸/分辨率限制 包含有默认导航按钮的皮肤，针对特定的视角 支持 Flash 与 HTML5 Droplet 说明 配置文件: flatconfig 默认模版/皮肤配置文件: flatxml / flatskinxml MAKE VTOUR (NORMAL)用法说明 生成普通 (=单分辨率) 全景并将它们整合到一个虚拟漫游中 制作典型的 360 度全景 全部全景图将会一次性载入 默认下方块最大变长为 2048 像素(可以在配置文件中修改) 包含一个包括导航按钮、可滚动缩略图以及可选择必应地图以及重力感应插件的默认皮肤 支持 Flash 和 HTML5 Droplet 说明 配置文件: vtour-normalconfig 默认模版/皮肤配置文件: vtourskin-thumbnails-bingmaps-gyroskin MAKE VTOUR (MULTIRES)用法说明 生成多分辨率全景并将它们整合到一个虚拟漫游中 制作所有类型全景图像 只有特定的切片在需要时载入 没有尺寸/分辨率限制 包含一个包括导航按钮、可滚动缩略图以及可选择必应地图以及重力感应插件的默认皮肤 支持 Flash 和 HTML5 Droplet 说明 配置文件: vtour-multiresconfig 默认模版/皮肤配置文件: vtourskin-thumbnails-bingmaps-gyroskin MAKE OBJECT用法说明 生成若干个平面多分辨率图像并将它们整合到一个可缩放旋转的 360 物体影像中 制作平面图像物体 所有物体图片的尺寸必须一致 只有特定的切片在需要时载入 没有尺寸/分辨率限制 包含一个特定的控制物体的皮肤 仅支持 Flash Droplet 说明 配置文件: objectconfig 默认模版/皮肤配置文件: objectxml / objectskinxml Convert SPHERE to CUBE用法说明 将球面图像转换至立方体图 输出的立方体格式、尺寸以及图像尺寸可以在配置文件中修改 Droplet 说明 配置文件: convertdropletsconfig Convert CUBE to SPHERE用法说明 将六张立方体图像转换成一张球面全景图 输出的图像尺寸和格式可以在配置文件中修改 Droplet 说明 配置文件: convertdropletsconfig Encrypt XML用法说明 将 xml 文件拖放进 droplet 进行加密 加密过程中 xml 文件会自动被压缩 自定义 droplet如果内置 droplet 不能满足需求或者需要对一些参数进行自定义。只要复制并重命名一个配置文件与皮肤配置文件，然后复制并重命名一个 droplet，修改里面的配置路径即可。 vtour 文件夹说明vtour 文件夹结构123456789vtour/| -- panos/ #存放全景切片图片的文件夹| -- skin/ #存放皮肤相关文件| -- plugins/ #用来存放插件| -- tour.swf #krpano flash viewer| -- tour.js #krpano HTML5 viewer| -- tour.xml #生成全景的相关配置| -- tour.html #用来浏览全景的页面，需要本地服务环境| -- tour_editor.html #添加热点（hotspot）与初始化视角的设置 vtour 运作机制12345678910111213&lt;div id=\"pano\"&gt;&lt;/div&gt;&lt;script src=\"tour.js\"&gt;&lt;/script&gt;&lt;script&gt;embedpano(&#123; swf: \"tour.swf\", //有则表示加载flash引擎，如果设置html5:only则不需要该值 xml: \"tour.xml\", //启动时的配置文件 target: \"pano\", //要渲染到的目标容器ID html5: \"only\", //如果有需要用到flash，可设置为auto //id: \"krpanoSWFObject\", //默认的krpano对象，每一个viewer对应唯一id，与JS交互时要用到 mobilescale: 1.0, //移动设备缩放，1表示不缩放，默认0.5 passQueryParameters: false //是否接受URL传参，例如：tour.html?html5=only&amp;startscene=scene2&#125;);&lt;/script&gt; krpano XML结构1234567891011121314151617181920212223242526&lt;krpano&gt; &lt;include&gt; &lt;preview&gt; &lt;image&gt; &lt;view&gt; &lt;area&gt; &lt;display&gt; &lt;control&gt; &lt;cursors&gt; &lt;autorotate&gt; &lt;plugin&gt; &lt;layer&gt; &lt;hotspot&gt; &lt;style&gt; &lt;events&gt; &lt;action&gt; &lt;contextmenu&gt; &lt;network&gt; &lt;memory&gt; &lt;security&gt; &lt;textstyle&gt; &lt;lensflareset&gt; &lt;lensflare&gt; &lt;data&gt; &lt;scene&gt;&lt;/krpano&gt; Krpano 内置元素说明01.krpano krpano 元素是 krpano xml 文件的根元素。任何一个 krpano xml 文件内的其它元素都要被 krpano 元素所嵌套。 02.include include 元素可引入其它 xml 文件的内容，例如我们常要用到的 vtourskin.xml 就是使用 include 嵌入到主 xml 中。 03.preview 预览图设置，也就是全景图完全载入之前的模糊图像，但因为体积较小，因此载入速度较快，会在全景图之前先载入，避免黑屏。 04.image image 元素控制全景图设置，包括全景图类型，渐进分辨率切片显示等。 05.view view 元素控制全景的视野，例如起始视角、视角限制与缩放等等。当要设置限制视角或设定特定的初始视角时，需要自行设定或使用插件获取代码。 06.area area 元素控制全景图在浏览器窗口中显示区域大小。 07.display 控制全景图的显示品质。 08.control 设置鼠标、键盘以及触摸设备对全景浏览的控制方式。 09.cursors 设置鼠标光标样式。 10.autorotate 控制自动旋转。 11.plugin 用来调用插件、插入图片或生成容器。 12.layer 与 plugin 作用相同，只是名称不同。 13.hotspot 热点，可在 3D 空间中插入图片，使之随着 3D 空间一同运动，可制作很多特效。 14.style 可以保存其它元素的属性子集。 15.events 可调用各类型事件，例如全景载入的不同阶段以及鼠标触发的不同行为等。 16.action 自定义动态代码。 17.contextmenu 定义右键菜单的内容。 18.network 控制图像的下载、缓存与解码。 19.menory 控制全景图在设备中的存储。 20.security Flashplayer 和 HTML5 相关的安全/跨域设置。 21.lensflareset 镜头眩光的设置（目前只能在 flash 下使用）。 22.lensflare 生成镜头眩光（目前只能在 flash 下使用）。 23.data 可放置任意的数据。 24.scene 可放置任意 krpano 元素。每个 scene 元素只有在被 loadscene 时才会被载入到浏览器进行解析。 常用设置小行星开场开启小行星，先找到 tour.xml ，然后搜索 littleplanetintro 将其值设置为 true 即可。 12345&lt;skin_settings ... littleplanetintro=\"true\" .../&gt; 加载动画在官方的案例文件夹中找到 loading-progress 这个文件夹，将需要的文件内容复制到项目中的 skin 文件夹，然后在 tour.xml 文件中引入该文件即可，这样重新打开就可以看到有动态的进度条了。 1&lt;include url=\"skin/loadingbar.xml\" /&gt; 修改右键菜单找到引入的皮肤文件，默认在 vtourskin.xml ，然后修改下面这些地方即可自定义右键菜单，但像版权、全屏菜单即使删除也会存在。 123&lt;contextmenu&gt; &lt;item name=\"fv\" caption=\"鱼眼视图\" onclick=\"skin_view_fisheye();\" showif=\"view.vlookatrange == 180\" devices=\"flash|webgl\" separator=\"true\" /&gt;&lt;/contextmenu&gt; contextmenu元素 caption 右键菜单显示的文字 onclick 控制点击后执行的动作，动作由 action 定义 showif 显示条目的条件 devices 控制在 flash/webgl 哪个模式中出现 separator 显示分隔符来分隔菜单 自定义热点配置 &lt;hotspot&gt; 中 style 的属性对应的元素（skin对应的文件夹） 1&lt;hotspot name=\"spot1\" style=\"skin_hotspotstyle\" ath=\"93.531\" atv=\"-1.109\" linkedscene=\"scene_shuilifang\" /&gt; 12345678910&lt;!-- skin_hotspotstyle - style for the hotspots --&gt; &lt;style name=\"skin_hotspotstyle\" url=\"vtourskin_hotspot.png\" scale=\"0.5\" edge=\"top\" distorted=\"true\" tooltip=\"\" linkedscene=\"\" linkedscene_lookat=\"\" onclick=\"skin_hotspotstyle_click();\" onover=\"tween(scale,0.55);\" onout=\"tween(scale,0.5);\" onloaded=\"if(linkedscene AND skin_settings.tooltips_hotspots, copy(tooltip,scene[get(linkedscene)].title); loadstyle(skin_tooltips); );\" /&gt; 隐藏皮肤123456789&lt;action name=\"startup\" autorun=\"onstart\"&gt; &lt;!--添加代码 隐藏皮肤 --&gt; set(events[skin_events].name, null); for(set(i,0), i LT layer.count, inc(i), copy(layername, layer[get(i)].name); subtxt(namestart, get(layername), 0, 5); if(namestart == 'skin_', removelayer(get(layername)); dec(i); ); );&lt;/action&gt; 动态热点在 tour.xml 空白处的scene标签的外面，添加动作代码 123456789101112131415161718192021222324&lt;action name=\"do_crop_animation\"&gt; &lt;!-- 为热点注册属性 --&gt; registerattribute(xframes, calc((imagewidth / %1) BOR 0)); registerattribute(yframes, calc((imageheight / %2) BOR 0)); registerattribute(frames, calc(xframes * yframes)); registerattribute(frame, 0); set(crop, '0|0|%1|%2'); setinterval(calc('crop_anim_' + name), calc(1.0 / %3), if(loaded, inc(frame); if(frame GE frames, if(onlastframe !== null, onlastframe() ); set(frame,0); ); mod(xpos, frame, xframes); div(ypos, frame, xframes); Math.floor(ypos); mul(xpos, %1); mul(ypos, %2); calc(crop, xpos + '|' + ypos + '|%1|%2'); , clearinterval(calc('crop_anim_' + name)); ); );&lt;/action&gt; 在 hotspot 或 layer 的代码添加代码， do_crop_animation(每帧宽,每帧高,fps) 1url=\"explosion.png\" onloaded=\"do_crop_animation(100,100, 60)\" 动态热点添加始终显示的文字显示 &lt;scene&gt; title 中的文字 1&lt;hotspot name=\"spot1\" url=\"animatedhotspot_white.png\" onloaded=\"do_crop_animation(64,64, 60);\" ath=\"-15\" atv=\"-12\" onclick=\"loadscene(get(linkedscene))\" linkedscene=\"scene_01\"/&gt; 或者在 &lt;hotpsot&gt; text 中添加显示自定义的文字 1&lt;hotspot name=\"spot1\" url=\"animatedhotspot_white.png\" onloaded=\"do_crop_animation(64,64, 60);\" ath=\"-15\" atv=\"-12\" onclick=\"loadscene(get(linkedscene))\" text=\"自定义文字\"/&gt; 在热点的 onload 事件中加上 add_all_the_time_tooltip() 1onloaded=\"do_crop_animation(64,64, 60);add_all_the_time_tooltip()\" 空白处加上 action 1234567891011121314151617181920212223242526272829303132&lt;action name=\"add_all_the_time_tooltip\"&gt; txtadd(tooltipname, 'tooltip_', get(name)); addplugin(get(tooltipname)); txtadd(plugin[get(tooltipname)].parent, 'hotspot[', get(name), ']'); set(plugin[get(tooltipname)].url,'%SWFPATH%/plugins/textfield.swf'); set(plugin[get(tooltipname)].align,top); set(plugin[get(tooltipname)].edge,bottom); set(plugin[get(tooltipname)].x,0); set(plugin[get(tooltipname)].y,0); set(plugin[get(tooltipname)].autowidth,true); set(plugin[get(tooltipname)].autoheight,true); set(plugin[get(tooltipname)].vcenter,true); set(plugin[get(tooltipname)].background,true); set(plugin[get(tooltipname)].backgroundcolor,0x000000); set(plugin[get(tooltipname)].roundedge,5); set(plugin[get(tooltipname)].backgroundalpha,0.65); set(plugin[get(tooltipname)].padding,5); set(plugin[get(tooltipname)].border,false); set(plugin[get(tooltipname)].glow,0); set(plugin[get(tooltipname)].glowcolor,0xFFFFFF); set(plugin[get(tooltipname)].css,'text-align:center; color:#FFFFFF; font-family:MicrosoftYahei; font-size:24px;'); if(device.mobile,set(plugin[get(tooltipname)].css,'text-align:center; color:#FFFFFF; font-family:MicrosoftYahei; font-weight:bold; font-size:24px;'); ); set(plugin[get(tooltipname)].textshadow,0); set(plugin[get(tooltipname)].textshadowrange,6.0); set(plugin[get(tooltipname)].textshadowangle,90); if(text == '' OR text === null, copy(plugin[get(tooltipname)].html,scene[get(linkedscene)].title), copy(plugin[get(tooltipname)].html,text) ); set(plugin[get(tooltipname)].enabled,false); &lt;/action&gt; 热点和或图层在鼠标点击或鼠标悬停时进入动态模式123456789101112131415161718192021222324252627282930313233343536&lt;action name=\"do_crop_animation_onclick\"&gt; if(hotspot[get(name)].animated === null OR hotspot[get(name)].animated == false, set(hotspot[get(name)].animated,true); setinterval(calc('crop_anim_' + name), calc(1.0 / %3), inc(frame); if(frame GE frames, if(onlastframe !== null, onlastframe() ); set(frame,0); ); mod(xpos, frame, xframes); div(ypos, frame, xframes); Math.floor(ypos); mul(xpos, %1); mul(ypos, %2); calc(crop, xpos + '|' + ypos + '|%1|%2'); ); , set(hotspot[get(name)].animated,false); clearinterval(calc('crop_anim_' + name)); set(crop, '0|0|%1|%2'); );&lt;/action&gt; &lt;action name=\"do_crop_animation_register\"&gt; registerattribute(xframes, calc((imagewidth / %1) BOR 0)); registerattribute(yframes, calc((imageheight / %2) BOR 0)); registerattribute(frames, calc(xframes * yframes)); registerattribute(frame, 0); set(crop, '0|0|%1|%2'); &lt;/action&gt; &lt;!-- example hotspots --&gt;&lt;hotspot name=\"spot1\" url=\"animatedhotspot_white.png\" onover=\"do_crop_animation_onclick(64,64,60)\" onout=\"do_crop_animation_onclick(64,64,60)\" ath=\"-15\" atv=\"-12\" onloaded=\"do_crop_animation_register(64,64)\" /&gt; &lt;hotspot name=\"spot1\" url=\"animatedhotspot_white.png\" onclick=\"do_crop_animation_onclick(64,64,60)\" ath=\"-15\" atv=\"-12\" onloaded=\"do_crop_animation_register(64,64)\" /&gt; 以上代码执行了一次动态循环后，序列图停留在第一帧，如果只是需要执行一次动态循环，并且序列图停留在最后一帧的话，那么 do_crop_animation_onclick 需更改（区别就是 frame 这个变量没有重置为 0 ，并且没有重新设置 crop ） 1234567891011121314151617181920&lt;action name=\"do_crop_animation_onclick\"&gt; if(hotspot[get(name)].animated === null OR hotspot[get(name)].animated == false, set(hotspot[get(name)].animated,true); setinterval(calc('crop_anim_' + name), calc(1.0 / %3), inc(frame); if(frame GE frames, if(onlastframe !== null, onlastframe() ); add(frame,frames,-1); ); mod(xpos, frame, xframes); div(ypos, frame, xframes); Math.floor(ypos); mul(xpos, %1); mul(ypos, %2); calc(crop, xpos + '|' + ypos + '|%1|%2'); ); , set(hotspot[get(name)].animated,false); clearinterval(calc('crop_anim_' + name)); );&lt;/action&gt; 拖拽热点在 &lt;hotspot/&gt; 中添加代码 1ondown=\"draghotspot();\" 添加 action 代码 12345678910&lt;action name=\"draghotspot\"&gt; spheretoscreen(ath, atv, hotspotcenterx, hotspotcentery, 'l'); sub(drag_adjustx, mouse.stagex, hotspotcenterx); sub(drag_adjusty, mouse.stagey, hotspotcentery); asyncloop(pressed, sub(dx, mouse.stagex, drag_adjustx); sub(dy, mouse.stagey, drag_adjusty); screentosphere(dx, dy, ath, atv); );&lt;/action&gt; 添加简单的全景视频从 viewer/examples/videopano 中复制 vtourskin.xml，在主xml 添加代码 1234567891011121314151617181920212223242526272829303132333435&lt;scene name=\"videopano\" title=\"户外全景视频\"&gt; &lt;!-- include the videoplayer interface / skin (with VR support) --&gt; &lt;include url=\"skin/videointerface.xml\" /&gt; &lt;!-- include the videoplayer plugin --&gt; &lt;plugin name=\"video\" url.html5=\"%SWFPATH%/plugins/videoplayer.js\" url.flash=\"%SWFPATH%/plugins/videoplayer.swf\" pausedonstart=\"true\" loop=\"true\" volume=\"1.0\" onloaded=\"add_video_sources();\" /&gt; &lt;!-- use the videoplayer plugin as panoramic image source --&gt; &lt;image&gt; &lt;sphere url=\"plugin:video\" /&gt; &lt;/image&gt; &lt;!-- set the default view --&gt; &lt;view hlookat=\"0\" vlookat=\"0\" fovtype=\"DFOV\" fov=\"130\" fovmin=\"75\" fovmax=\"150\" distortion=\"0.0\" /&gt; &lt;!-- add the video sources and play the video --&gt; &lt;action name=\"add_video_sources\"&gt; videointerface_addsource('1024x512', '%CURRENTXML%/video/video-1024x512.mp4|%CURRENTXML%/video/video-1024x512.webm|%CURRENTXML%/video/iphone-audio.m4a', '%CURRENTXML%/video/video-1024x512-poster.jpg'); videointerface_addsource('1920x960', '%CURRENTXML%/video/video-1920x960.mp4|%CURRENTXML%/video/video-1920x960.webm|%CURRENTXML%/video/iphone-audio.m4a', '%CURRENTXML%/video/video-1920x960-poster.jpg'); if(device.ios, &lt;!-- iOS Safari has a very slow 'video-to-webgl-texture' transfer, therefore use a low-res video by default --&gt; videointerface_play('1024x512'); , videointerface_play('1920x960'); ); &lt;/action&gt;&lt;/scene&gt; 添加雨雪特效 添加文件 http://pan.baidu.com/s/1gfLTx6N 密码：6shh 在 viewer\\plugins 拷贝 snow.swf 和 snow.js 添加 &lt;scene onstart=&quot;snowballs();&quot;&gt; 目前可选的特效 默认雪 onstart=&#39;defaultsnow();&#39; 雪球 onstart=&#39;snowball();&#39; 雪花 onstart=&#39;snowflakes();&#39; 银色星星 onstart=&#39;silverstars();&#39; 金色星星 onstart=&#39;goldenstars();&#39; 心形 onstart=&#39;hearts();&#39; 笑脸 onstart=&#39;smileys();&#39; 钱 onstart=&#39;money();&#39; 雨 onstart=&#39;rain();&#39; 大雨 onstart=&#39;heavyrain();&#39; 在 &lt;scene&gt; 添加代码 1234567891011121314&lt;include url=\"snow.xml\" /&gt;``` ### 自动旋转添加代码```xml&lt;autorotate enabled=\"true\"waittime=\"5.0\"speed=\"-3.0\"horizon=\"0.0\"tofov=\"120.0\"/&gt; waittime 代表在最近一次用户交互行为之后要开始自动旋转之前的等待时间。以秒为单位。 speed 为旋转速度。当该数值为正值时向右旋转，为负值时向左旋转。 horizon 为场景在自动旋转时将达到的水平位置。 tofov 为旋转中要达到的视场角。 无按钮控制的自动旋转自动旋转场景，场景旋转一圈后自动进入下一个场景，最后一个场景浏览结束后，进入第一个场景。需添加如下代码： 123456&lt;autorotate enabled=\"true\"waittime=\"5.0\"speed=\"-3.0\"horizon=\"0.0\"tofov=\"120.0\"/&gt; 修改 &lt;action name=&quot;startup/&gt; 中的代码 12345&lt;action name=\"startup\"&gt;if(startscene === null, copy(startscene,scene[0].name));loadscene(get(startscene), null, MERGE);if(autorotate.enabled,bombtimer(0));&lt;/action&gt; 在 xml 文件中加入下面的代码 12345678910111213141516171819&lt;events onmousedown=\"set(bt,0);\" /&gt;&lt;action name=\"bombtimer\"&gt;set(autorotate.enabled,true);set(bt,%1);add(bt,1);delayedcall(1, bombtimer(get(bt)));copy(bt_1,autorotate.speed);Math.abs(bt_1);div(bt_2,360,bt_1);add(bt_2,autorotate.waittime);if(bt GE bt_2, set(bt,0); nextscene(););&lt;/action&gt;&lt;action name=\"nextscene\"&gt;set(ns, get(scene[get(xml.scene)].index));set(maxs, get(scene.count));add(ns,1);if(ns == maxs, set(ns,0));loadscene(get(scene[get(ns)].name), null, MERGE, BLEND(1.5));&lt;/action&gt; 按钮控制的自动旋转添加代码 123456&lt;autorotate enabled=\"true\"waittime=\"5.0\"speed=\"-3.0\"horizon=\"0.0\"tofov=\"120.0\"/&gt; 在对应的按钮，通常为 &lt;layer&gt; 标签中找到 onclick 属性替换，如果没有则直接添加 1&lt;layer ... onclick=\"switch(autorotate.enabled);\" ... /&gt; 添加陀螺仪加载插件 123456789&lt;plugin name=\"gyro\" devices=\"html5\" url=\"%SWFPATH%/plugins/gyro2.js\" enabled=\"false\" onavailable=\"gyro_available_info();\" /&gt; &lt;action name=\"gyro_available_info\"&gt; set(layer[gyrobutton].visible, true);&lt;/action&gt; 控制按钮 123&lt;layer name=\"gyrobutton\" url=\"gyroicon.png\" scale=\"0.5\" align=\"right\" x=\"10\" visible=\"false\" onclick=\"switch(plugin[gyro].enabled);\" /&gt; 默认皮肤开启陀螺仪功能（在 tour.xml 的 skin_settings中设置） 1gyro=&quot;true&quot; 在 tour.xml 的 include 的下一行添加 12345&lt;plugin name=\"skin_gyro\" enabled=\"true\" camroll=\"false\" onenable=\"set(view.limitview, range);\" /&gt; 场景过渡效果修改全部过渡效果，只需修改 &lt;skin_settings /&gt;中以下代码 123loadscene_blend=\"OPENBLEND(0.5, 0.0, 0.75, 0.05, linear)\"loadscene_blend_prev=\"SLIDEBLEND(0.5, 180, 0.75, linear)\"loadscene_blend_next=\"SLIDEBLEND(0.5, 0, 0.75, linear)\" 如果想为某个特殊的 loadscene 动作加上不一样的过渡效果，在主 xml 的 scene 外加入以下代码 123456789101112&lt;blendmodes name=\"no blending\" description=\"无过渡效果\" blend=\"NOBLEND\" /&gt;&lt;blendmodes name=\"simple crossblending\" description=\"简单淡入淡出\" blend=\"BLEND(1.0, easeInCubic)\" /&gt;&lt;blendmodes name=\"zoom blend\" description=\"缩放过渡\" blend=\"ZOOMBLEND(2.0, 2.0, easeInOutSine)\" /&gt;&lt;blendmodes name=\"black-out\" description=\"黑场过渡\" blend=\"COLORBLEND(2.0, 0x000000, easeOutSine)\" /&gt;&lt;blendmodes name=\"white-flash\" description=\"白场过渡\" blend=\"LIGHTBLEND(1.0, 0xFFFFFF, 2.0, linear)\" /&gt;&lt;blendmodes name=\"right-to-left\" description=\"从右至左\" blend=\"SLIDEBLEND(1.0, 0.0, 0.2, linear)\" /&gt;&lt;blendmodes name=\"top-to-bottom\" description=\"从上至下\" blend=\"SLIDEBLEND(1.0, 90.0, 0.01, linear)\" /&gt;&lt;blendmodes name=\"diagonal\" description=\"对角线\" blend=\"SLIDEBLEND(1.0, 135.0, 0.4, linear)\" /&gt;&lt;blendmodes name=\"circle open\" description=\"圆形展开\" blend=\"OPENBLEND(1.0, 0.0, 0.2, 0.0, linear)\" /&gt;&lt;blendmodes name=\"vertical open\" description=\"垂直展开\" blend=\"OPENBLEND(0.7, 1.0, 0.1, 0.0, linear)\" /&gt;&lt;blendmodes name=\"horizontal open\" description=\"水平展开\" blend=\"OPENBLEND(1.0, -1.0, 0.3, 0.0, linear)\" /&gt;&lt;blendmodes name=\"elliptic + zoom\" description=\"椭圆缩放\" blend=\"OPENBLEND(1.0, -0.5, 0.3, 0.8, linear)\" /&gt; 修改 loadscene(scenename, null, MERGE, get(blendmodes[black-out].blend)); 1&lt;hotspot onclick=\"loadscene(scene_shuilifang, null, MERGE, get(blendmodes[vertical open].blend));\" /&gt; 隐藏显示热点添加 &lt;action&gt; 123456789101112&lt;action name=\"hideBox\"&gt; tween(%1.alpha,0,0.5); wait(1); set(%1.visible,false);&lt;/action&gt;&lt;action name=\"showBox\"&gt; set(%1.alpha,0); set(%1.visible,true); tween(%1.alpha,1,0.5); tween(%1.scale,1,0.5,easeOutBack);&lt;/action&gt; 使用1234&lt;hotspot name=\"spot1\" style=\"skin_hotspotstyle\" ath=\"46.131\" atv=\"24.389\" visible=\"true\" onclick=\"spot1Click\" /&gt;&lt;action name=\"spot1Click\"&gt; hideBox(hotspot[spot1]);&lt;/action&gt; 获取全景视频进度12345678910111213141516171819&lt;!-- 获取视频进度 --&gt;&lt;action name=\"get_video_time\"&gt; setinterval(skin_video_seek_updates0, 0.1, skin_video_updatetime0())&lt;/action&gt;&lt;action name=\"skin_video_updatetime0\"&gt; setStop(4,video_pause_events(););&lt;/action &gt; &lt;action name=\"setStop\"&gt; copy(t1, plugin[video].time); if(t1 GT %1,%2);&lt;/action&gt; &lt;!-- 视频暂停回调 --&gt;&lt;action name=\"video_pause_events\"&gt; plugin[video].pause(); clearinterval(skin_video_seek_updates0);&lt;/action&gt; 官方文档 集成到HTML krpano XML krpano-action-script 动作与脚本1. 语法跟应用 2. 表达式 3. 数组 4. 全局变量 对应动作的局部变量 获取全局变量 参照(http://www.visita3d.com/)(function(){ var bp = document.createElement(‘script’); var curProtocol = window.location.protocol.split(‘:’)[0]; if (curProtocol === ‘https’) { bp.src = ‘https://zz.bdstatic.com/linksubmit/push.js‘; } else { bp.src = ‘http://push.zhanzhang.baidu.com/push.js‘; } var s = document.getElementsByTagName(“script”)[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == &quot;http:&quot;) ? &quot;http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;:&quot;https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;; document.write(&apos;&lt;script src=&quot;&apos; + sozzsrc + &apos;&quot; id=&quot;sozz&quot;&gt;&lt;\\/script&gt;&apos;); })();","tags":[{"name":"krpano","slug":"krpano","permalink":"https://austinxishou.github.io/tags/krpano/"}]},{"title":"生活工作想法记录","date":"2017-11-01T03:12:20.842Z","path":"2017/11/01/killtime/patent-idea-collection/","text":"## 安卓双系统引导 (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"idea","slug":"idea","permalink":"https://austinxishou.github.io/tags/idea/"}]},{"title":"Android OTA (一) 升级包编译制作","date":"2017-11-01T02:15:39.761Z","path":"2017/11/01/android/android-updater-ota-from-target/","text":"OTA完整包生成方法 OTA完整包可用于T卡本地升级和OTA在线升级。OTA完整包包含完整的system、recovery.和boot.img。发布一个版本固件正确顺序：123make -j4make otapackage./mkimage.sh ota 即可获得：out/target/product/{product_name}/ {product_name}-ota-eng.{uid}.zip 注意：发布固件必须使用./mkimage.sh ota，将boot与kernel打包，不需要单独烧kernel，如果量产固件是分开的，将会影响后面差异包升级，除非你不需要用差异升级！ 在out/target/product/rk3288/目录下会生成ota完整包rk3288-ota-eng.root.zip，改名成update.zip即可拷贝到T卡或内置flash中进行固件升级。 OTA差异包生成方法 OTA差异包只有差异内容，包大小比较小，主要用于OTA在线升级，也可T卡本地升级。OTA差异包制作需要特殊的编译进行手动制作。 首先发布v1版本的固件，生成v1版本的完整包 保存out/target/product/rk3288/obj/PACKAGING/target_files_intermediates/rk3288-target_files-eng.root.zip 为rk3288-target_files-v1.zip，作为v1版本的基础素材包。 修改kernel代码或者android代码，发布v2版本固件，生成v2版本完整包 保存out/target/product/rk3288/obj/PACKAGING/target_files_intermediates/rk3288-target_files-eng.root.zip 为rk3288-target_files-v2.zip，作为v2版本的基础素材包。 生成v1-v2的差异升级包：./build/tools/releasetools/ota_from_target_files -v -i rk3288-target_files-v1.zip -p out/host/linux-x86 -k build/target/product/security/testkey rk3288-target_files-v2.zip out/target/product/rk3288/rk3288-v1-v2.zip 最后生成的ota差异包 编译过程编译主要分两步， 会准备一个包，其中包含升级需要的内容(原材料)，比如，system 目录。 运行python 脚本 ./build/tools/releasetools/ota_from_target_files，以步骤一准备的ZIP包作为输入，最终生成需要的升级包。 第一步:填充所需要的材料Makefile 依赖otapackage 是一个伪目标12.PHONY: otapackageotapackage: $(INTERNAL_OTA_PACKAGE_TARGET) RECOVERY目录下的组件填充 RECOVERY 子目录的内容。用于生成recovery.img。包括：kernel 的image, recovery 根文件系统的 image, recovery 根文件系统的内容 123456789101112@# Components of the recovery image $(hide) mkdir -p $(zip_root)/RECOVERY //创建中间包中的RECOVERY目录$(hide) $(call package_files-copy-root, \\ $(TARGET_RECOVERY_ROOT_OUT),$(zip_root)/RECOVERY/RAMDISK)//拷贝相关分区文件到 RECOVERY 目录1. $(ACP) $(INSTALLED_KERNEL_TARGET) $(zip_root)/RECOVERY/kernel2. $(ACP) $(INSTALLED_2NDBOOTLOADER_TARGET) $(zip_root)/RECOVERY/second3. echo \"$(BOARD_KERNEL_CMDLINE)\" &gt; $(zip_root)/RECOVERY/cmdline4. echo \"$(BOARD_KERNEL_BASE)\" &gt; $(zip_root)/RECOVERY/base5. echo \"$(BOARD_KERNEL_PAGESIZE)\" &gt; $(zip_root)/RECOVERY/pagesize BOOT 目录下的组件填充 BOOT子目录的内容，用于生成boot.img。和 RECOVERY目录类似，包括：kernel 的image,根文件系统的 image,根文件系统的内容： 1234567891011@# Components of the boot image$(hide) mkdir -p $(zip_root)/BOOT$(hide) $(call package_files-copy-root, \\ $(TARGET_ROOT_OUT),$(zip_root)/BOOT/RAMDISK)1. $(ACP) $(INSTALLED_KERNEL_TARGET) $(zip_root)/BOOT/kernel2. $(ACP) $(INSTALLED_2NDBOOTLOADER_TARGET) $(zip_root)/BOOT/second3. echo \"$(BOARD_KERNEL_CMDLINE)\" &gt; $(zip_root)/BOOT/cmdline4. echo \"$(BOARD_KERNEL_BASE)\" &gt; $(zip_root)/BOOT/base5. echo \"$(BOARD_KERNEL_PAGESIZE)\" &gt; $(zip_root)/BOOT/pagesize6. RADIO 目录下的组件123$(hide) $(foreach t,$(INSTALLED_RADIOIMAGE_TARGET),\\ mkdir -p $(zip_root)/RADIO; \\ $(ACP) $(t) $(zip_root)/RADIO/$(notdir $(t));) BOOTLOADER 组件内容BOOTLOADER 需要提供之前使用的 BOOTLOADER 和 新的 BOOTLOADER 文件 以及 MISC 分区文件之前使用的BOOTLOADER 放置在目录：$(TARGET_DEVICE_DIR)/ota/loader/RKLoader.bin)新的 BOOTLOADER 文件 放置在目录：$(PRODUCT_OUT)/RKLoader_new.binMISC 分区文件 放置在目录：$(TARGET_DEVICE_DIR)/ota/loader/misc_loadercmd.img 12345678ifeq ($(INSTALLED_LOADER_TARGET),) $(info No RK Loader for TARGET_DEVICE $(TARGET_DEVICE) to otapackage) //不需要更新BOOTLOADERelse @# Contents of the rk loader bin $(hide) mkdir -p $(zip_root)/LOADER $(hide) $(HOST_OUT_EXECUTABLES)/remkloader '$(INSTALLED_LOADER_TARGET)' $(INSTALLED_NEW_LOADER_TARGET) $(hide) cat $(INSTALLED_LOADER_MISC_TARGET) $(INSTALLED_NEW_LOADER_TARGET) &gt; $(zip_root)/LOADER/RKLoader.img endif Parameter 组件内容parameter 需要放置在 $(TARGET_DEVICE_DIR)/ota/parameter/parameter*) 目录中1234567ifeq ($(INSTALLED_PARAMETER_TARGET),) $(info No parameter for TARGET_DEVICE $(TARGET_DEVICE) to otapackage) //不需要更新Parameterelse $(hide) rm -rf $(zip_root)/PARAMETER $(hide) mkdir -p $(zip_root)/PARAMETER $(hide) $(HOST_OUT_EXECUTABLES)/mkparameter '$(INSTALLED_PARAMETER_TARGET)' $(zip_root)/PARAMETER/parameterendif 常规的system 以及 data 分区内容填充 SYSTEM子目录的内容。 这是升级的主要内容。生成 META/filesystem_config.txt 并将其加入到 zip 包中。该文件保存了 system 目录下各目录、文件的权限及 owner 123456@# Contents of the system image$(hide) $(call package_files-copy-root, \\ $(SYSTEMIMAGE_SOURCE_DIR),$(zip_root)/SYSTEM)@# Contents of the data image$(hide) $(call package_files-copy-root, \\ $(TARGET_OUT_DATA),$(zip_root)/DATA) 供应商定制相关内容12345ifdef BOARD_VENDORIMAGE_FILE_SYSTEM_TYPE @# Contents of the vendor image $(hide) $(call package_files-copy-root, \\ $(TARGET_OUT_VENDOR),$(zip_root)/VENDOR)endif 第二步:ota_from_target_files 命令执行核心是一个python脚本: ota_from_target_files, 它以前一步骤生成的ZIP包作为输入，生成可用于OTA升级的zip包。生成的完整升级包会存放在out\\target\\product[project-name]\\目录下 12345678910INTERNAL_OTA_PACKAGE_TARGET :# $(PRODUCT_OUT)/$(name).zip$(INTERNAL_OTA_PACKAGE_TARGET): KEY_CERT_PAIR :# $(DEFAULT_KEY_CERT_PAIR) 签名$(INTERNAL_OTA_PACKAGE_TARGET): $(BUILT_TARGET_FILES_PACKAGE) $(DISTTOOLS) @echo \"Package OTA: $@\" $(hide) PATH#$(foreach p,$(INTERNAL_USERIMAGES_BINARY_PATHS),$(p):)$$PATH MKBOOTIMG#$(MKBOOTIMG) \\ ./build/tools/releasetools/ota_from_target_files -v \\ -p $(HOST_OUT) \\ -k $(KEY_CERT_PAIR) \\ $(if $(OEM_OTA_CONFIG), -o $(OEM_OTA_CONFIG)) \\ $(BUILT_TARGET_FILES_PACKAGE) $@ 生成中间包生成的中间包存放在out/target/product/[project-name]/obj/PACKAGING/target_files_intermediates/目录下,该文件可用于创建差分升级包以及全量包源码中的英文注释为：12A zip of the directories that map to the target filesystem.This zip can be used to create an OTA package or filesystem image as a post-build step. 中间包宏变量为： BUILT_TARGET_FILES_PACKAGE部分代码为：12345678910111213141516171819202122232425262728293031intermediates :# $(call intermediates-dir-for,PACKAGING,target_files) //定义目录BUILT_TARGET_FILES_PACKAGE :# $(intermediates)/$(name).zip //宏变量赋值$(BUILT_TARGET_FILES_PACKAGE): intermediates :# $(intermediates) //定义依赖$(BUILT_TARGET_FILES_PACKAGE): \\ zip_root :# $(intermediates)/$(name) //定义依赖... //省略一部分依赖说明 # Depending on the various images guarantees that the underlying# directories are up-to-date.$(BUILT_TARGET_FILES_PACKAGE): \\ $(INSTALLED_BOOTIMAGE_TARGET) \\ $(INSTALLED_RADIOIMAGE_TARGET) \\ $(INSTALLED_LOADER_TARGET) \\ $(INSTALLED_PARAMETER_TARGET) \\ $(INSTALLED_RECOVERYIMAGE_TARGET) \\ $(INSTALLED_SYSTEMIMAGE) \\ $(INSTALLED_USERDATAIMAGE_TARGET) \\ $(INSTALLED_CACHEIMAGE_TARGET) \\ $(INSTALLED_VENDORIMAGE_TARGET) \\ $(INSTALLED_ANDROID_INFO_TXT_TARGET) \\ $(SELINUX_FC) \\ $(built_ota_tools) \\ $(APKCERTS_FILE) \\ $(HOST_OUT_EXECUTABLES)/fs_config \\ | $(ACP)上述依赖主要定义各个分区系统的文件//之后执行命令 @echo \"Package target files: $@\" //打印日志 $(hide) rm -rf $@ $(zip_root) //删除原有文件目录 $(hide) mkdir -p $(dir $@) $(zip_root) //重新创建目录 (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"OTA","slug":"OTA","permalink":"https://austinxishou.github.io/tags/OTA/"}]},{"title":"找资源","date":"2017-11-01T02:14:56.983Z","path":"2017/11/01/killtime/search-resource-collection/","text":"找资源 西林街：http://www.xilinjie.com/ 胖次：http://www.panc.cc/ 找文件：http://www.zhaofile.com/ 呆木瓜：http://www.daimugua.com/ 爱挖盘：http://www.iwapan.com/ 57百度云：http://baiduyun.57fx.cn/index-index.html 云盘搜索大师:http://www.xiandoudou.com/ 靠谱搜索:http://kaopu.so/ 网盘搜: http://www.wangpansou.cn/ BT种子搜索引擎 BT搜搜 :http://www.btsoso.me/ BTbook: http://www.btbook.net/ Runbt : http://www.runbt.com/ Diggbt: http://www.diggbt.com/ BT樱桃:http://www.btcherry.com/ BTdigg: https://btdigg.org/ btsoufuli: http://www.btsoufuli.com/ btkitty: http://btkitty.bid/ btdao: http://www.btdao.biz/ rarbg: https://rarbg.to/torrents.php/ btavmo: http://www.btavmo.com/ coretorrents: http://coretorrents.com/ mytorrents: http://mytorrents.org/ bt1024: http://www.bt1024.net/ 导航 龙轩导航 : http://ilxdh.com/(function(){ var bp = document.createElement(‘script’); var curProtocol = window.location.protocol.split(‘:’)[0]; if (curProtocol === ‘https’) { bp.src = &apos;https://zz.bdstatic.com/linksubmit/push.js&apos;; } else { bp.src = &apos;http://push.zhanzhang.baidu.com/push.js&apos;; } var s = document.getElementsByTagName(“script”)[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == “http:”) ? “http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a&quot;:&quot;https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a“; document.write(‘&lt;\\/script&gt;’);})();","tags":[{"name":"driver","slug":"driver","permalink":"https://austinxishou.github.io/tags/driver/"}]},{"title":"在线工具类网站","date":"2017-11-01T02:14:55.500Z","path":"2017/11/01/killtime/soft-tools-collection/","text":"生活类 在线听歌: http://lab.mkblog.cn/music/ 翻译平台 Google翻译x: https://translate.google.com/ 有道: http://youdao.com/ 扇贝英语 : https://www.shanbay.com/ CNKI翻译助手：http://dict.cnki.net/ 句酷：http://www.jukuu.com/ 词都：http://www.dictall.com/ LINE Dictionary：http://ce.linedict.com/dict.html#/cnen/ Glosbe：https://glosbe.com/ 程序工具箱 在线正则 : http://regexr.com/ 编码转换 : http://tool.chinaz.com/Tools/Unicode.aspx Json检验 : http://www.bejson.com/ Json检验 : http://pro.jsonlint.com/ Json检验带错误行 : http://www.json.cn/ ping工具 : http://ping.chinaz.com/ RGB颜色查询 : http://www.atool.org/colorpicker.php 字符串处理 : http://www.5ixuexiwang.com/str/compress.php 在线运行代码 : http://www.shucunwang.com/RunCode/php/ 在线运行代码 : http://codepad.org/ 在线Sql : http://sqlfiddle.com/#!4/c0be1c/1 Ascii流程图 : http://asciiflow.com/ 1024tools:https://1024tools.com/ oschina:http://tool.oschina.net/ shell练习:http://cb.vu/ rsa和pkcs8转换:https://www.chinassl.net/ssltools/convert-key.html 程序在线工具:http://tool.lu/ 多线路速度测试:http://ping.chinaz.com/45.76.185.184 github的star管理:http://gitconstellation.com/#/ 在线mock工具:http://apizza.cc 在线gitignore生成工具:https://www.gitignore.io/ API 百度语音朗读:http://tts.baidu.com/text2audio?lan=zh&amp;ie=UTF-8&amp;text=%E4%BC%98%E9%85%B7%E5%BD%95%E5%B1%8F%E5%A4%A7%E5%B8%88 模拟数据:https://apiary.io/ 在线api文档: http://devdocs.io/ 解密 php在线解密: http://dezend.qiling.org/ md5解密: http://cmd5.com/ 国家代码查询 : https://countrycode.org/ 在线编辑 zybuluo : https://www.zybuluo.com/ markdown_table生成 : http://www.tablesgenerator.com/markdown_tables processon协作:http://www.processon.com/ 石墨:https://shimo.im/ tower在线办公:https://tower.im/ 钉钉:https://www.dingtalk.com/ 马克飞象:https://maxiang.io/ 在线时序图:https://www.websequencediagrams.com/ stackedit:https://stackedit.io/ 其他工具 video_to_gif: http://ezgif.com/video-to-gif markdwon转换: http://pandoc.org/try/ 在线测速: http://www.speedtest.net/ 在线签到: https://qiandao.today/ 微信对话生成: http://www.duihuashengchengqi.com/ 飞机航班追踪：https://www.flightradar24.com/ 清华大学镜像站:https://mirrors.tuna.tsinghua.edu.cn/ dll之家:http://www.dllzj.com/ 流量宝:http://www.liuliangbao.cn/ 百度网盘永久直链外链:http://pan.plyz.net/ 艺匠独立作品:https://artizen.cc/ dnsmasq:https://g2w.online/ tinypng:https://tinypng.com/ 方糖收微信消息:http://sc.ftqq.com/3.version 随机生成美国身份: http://www.haoweichi.com/Index/random 前端预处理器语言图形编译工具: http://koala-app.com/index-zh.html (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"design","slug":"design","permalink":"https://austinxishou.github.io/tags/design/"}]},{"title":"软件及源码仓库收集","date":"2017-11-01T02:14:54.103Z","path":"2017/11/01/killtime/code-resource-collection/","text":"通用软件墙网站 小众软件 异次元 精品绿色 大眼仔 少轻狂 殁漂遥 冰点软件 Android软件站点 每日APP推送 零度游戏源码 拼命玩游戏 tap游戏墙 国内源码资源站 资源爱好者 游戏素材 车库源码 我爱h5游戏 盘多多 a5 A5 互站 [模板集](http://www.mobanji.com 源码之家 codeforge codeproject 黑锐 站长下载 吾爱源码网 免费资源部落 就爱开发 平台收集 oschina项目大厅 csdn项目列表 码市项目 国外源码资源网站 thefreecountry codeforge sourcecodester sourceforge H5游戏 freewebtemplates 通用站长平台 首赚网 (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"soft","slug":"soft","permalink":"https://austinxishou.github.io/tags/soft/"},{"name":"sourcecode","slug":"sourcecode","permalink":"https://austinxishou.github.io/tags/sourcecode/"}]},{"title":"老司机资源汇总","date":"2017-11-01T02:13:39.313Z","path":"2017/11/01/killtime/driver-resource-collection/","text":"磁力 磁力播播: http://cilibobo.cc/ 九秒在线: http://apiv.ga/magnet/ youtube下载 yout: https://yout.com/ savefrom: http://en.savefrom.net/ savemedia: https://savemedia.com/en/ clipconverter: http://www.clipconverter.cc/ Tumblr Tumblr热度: http://heimu360.applinzi.com/index.php?m=Home&amp;c=Index&amp;a=stat 91视频: http://freeget.co/ 直播聚合 直播盒子: http://www.zhubohezi.com/ vip视频,广告过滤 硕鼠 : http://www.flvcd.com/index.htm dsqndh: http://v.dsqndh.com/ 紫狐:http://api.zihu.tv/ 测试地址 爱奇艺: http://www.iqiyi.com/v_19rr9nt2p8.html 优酷: http://v.youku.com/v_show/id_XMTc3NjUxMDU2MA==.html?spm=a2h03.8164468.2069780.11 乐视: http://www.le.com/ptv/vplay/26677046.html?ref=hypdrydp 芒果TV: http://www.mgtv.com/v/1/303260/f/3665598.html 腾讯: http://v.qq.com/x/cover/mhlkz47d7thi2k4.html 通用接口 wmxz: http://www.wmxz.wang/video.php?url=http://www.mgtv.com/v/1/303260/f/3665598.html (高清)其他域名http://100000001.top(1-10):支持域名绑定A记录解析到47.89.49.245 aikantv: http://jx.aikantv.cc/index.php?url=http://www.mgtv.com/v/3/8849/f/307467.html (高清) moondown:http://moon.moondown.net/tong.php?url=http://www.mgtv.com/v/2/104817/f/3621326.html 测试页面 000o: http://000o.cc/jx/ty.php?url=http://www.mgtv.com/v/1/298442/f/3640929.html yydy8: http://www.yydy8.com/Common/?url=http://www.mgtv.com/v/1/303260/f/3665598.html (高清) ckparse: http://www.ckparse.com/ckparse/?url=http://www.mgtv.com/v/1/303260/f/3665598.html (高清) 九澧影院:http://dy.jiuli8.com/jiuli8/?url= 紫狐:http://yun.zihu.tv/play.html?url=http://v.qq.com/x/cover/mhlkz47d7thi2k4.html wbg3721:http://api.wbg3721.club/?url=http://www.iqiyi.com/v_19rrm2pgd4.html?fc=8b62d5327a54411b#vfrm=19-9-0-1 mp4la : http://api.mp4la.net/?url=http://v.youku.com/v_show/id_XMTc3NjUxMDU2MA==.html?spm=a2h03.8164468.2069780.11 990969_1: http://www.990969.top/jiu/vip1.php?url=http://www.iqiyi.com/v_19rr9nt2p8.html 990969_2: http://www.990969.top/jiu/vip2.php?url=http://www.iqiyi.com/v_19rr9nt2p8.html 990969_3: http://www.990969.top/jiu/vip3.php?url=http://www.iqiyi.com/v_19rr9nt2p8.html mt2t:http://mt2t.com/yun?url=http://www.mgtv.com/v/1/303260/f/3665598.html 五奇艺:http://vip.sdyhy.cn/ckflv/?url= qtzr:http://qtzr.net/s/?qt=http://v.qq.com/x/cover/mhlkz47d7thi2k4.html xiguaso:http://www.xiguaso.com/api/index.php?url=http://v.qq.com/x/cover/mhlkz47d7thi2k4.html vipjiexi:http://www.vipjiexi.com/yun.php?url=http://v.qq.com/x/cover/mhlkz47d7thi2k4.html 芒果tv 47ks: http://v.47ks.com/v2/videoplayer/api.html?u=http://www.mgtv.com/v/3/293930/f/3623801.html mmhhw: http://api.mmhhw.cn/huan6/mgtv.php?vid=3665598 1314yq: http://api.1314yq.com/mgtv.php?url=http://www.mgtv.com/v/1/303260/f/3665598.html 52jizhi: http://52jizhi.cn/6/vip1.php?url=http://www.mgtv.com/v/1/303260/f/3665598.html 优酷 200919 : http://www.200919.com/tv/v.php?url=http://v.youku.com/v_show/id_XMTc3NjUxMDU2MA==.html?spm=a2h03.8164468.2069780.11 quankan : http://www.quankan.tv/playz/youku.php?url=http://v.youku.com/v_show/id_XMTc2NjA1NDgwNA==.html?spm=a2h03.8164468.2069780.5 moease: http://www.moease.org/tao_ddv.php?vid=http://v.youku.com/v_show/id_XMTc3NjUxMDU2MA==.html?spm=a2h03.8164468.2069780.11 mmhhw : http://api.mmhhw.cn/huan6/mgtv66.php?vid=CMzcxNTUzMg== (c值) zhaogou8 : http://ykyun.zhaogou8.com/?v=CNjgzODc5Ng== (c值) zai63 : http://player.zai63.com/yunparse/?vid=CMzcxNTUzMg== (c值) 腾讯 quankan: http://www.quankan.tv/playpc/index.php?url=http://v.qq.com/x/cover/nye24rhm7f8dyry.html aikantv: http://api.aikantv.cc/?url=http://v.qq.com/x/cover/mhlkz47d7thi2k4.html apifree : http://www.apifree.net/ckplayer.jsp?id=apifree&amp;sp=vqq&amp;by=url&amp;value=http%3A%2F%2Fv.qq.com%2Fx%2Fcover%2Fczi2qltdys4wc3k.html&amp;single= 爱奇艺 72du: http://v.72du.com/api/?url=http://www.iqiyi.com/v_19rr9nt2p8.html ckplayer: http://ckplayer.duapp.com/?url=http://www.iqiyi.com/v_19rr9nt2p8.html yydy8: http://www.yydy8.com/Common/?url=http://www.iqiyi.com/v_19rr9nt2p8.html 97zxkan: http://www.97zxkan.com/jiexi/97zxkanapi.php?url=http://www.iqiyi.com/v_19rr9nt2p8.html 20000817: http://sp.20000817.pw/?url=http://www.iqiyi.com/v_19rrm2t3x0.html wanwantv: http://vip.wanwantv.com/yunparse/?url=http://www.iqiyi.com/v_19rrlzki4s.html 乐视 mmhhw:http://api.mmhhw.cn/huan6/letvvip.php?vid=26677046 A 站 aiwlan : http://hp.aiwlan.net/79iw.php?vid=1238251&amp;t=ykyun&amp;w=100%&amp;h=94% 2mm moondown:http://moon.moondown.net/2mm.php?url=http://www.2ni.la/sy147 接口失效黑色单 jiexi.71ki.com wyccoo.cn avziliao lklhd ehecom.com ivlook.com rpsofts.com shop.freegx.cn licoy.cn yunbofang.duapp.cn api.ppypp ccok.top qqdzz.com vip.77ds.vip litools.licoy.cn 其他 舒克高清视频下载:http://www.shokdown.com/index.php 夏贝贝网盘: http://xabb360.net/index.php?m=Login uzer: https://uzer.me/ 买家秀: http://www.mjxzs.cc/ 豆瓣请不要害羞: https://f.binux.me/haixiuzu.html 豆瓣请不要害羞: https://haixiu.herokuapp.com/ reddit: https://www.reddit.com/ 微博视频下载: http://www.weibovideo.com/ bilibili解析: http://www.ibilibili.com/video/av8355080/ 斗鱼火箭监控: http://douyu.shiniv.com/ 百度外链不限速: http://pan.plyz.net/ 福利油猴脚本: https://sleazyfork.org/zh-CN 网易云音乐: http://projects.qiyichao.cn/netease-music-parse/ 资讯 免费吧: http://www.mianfeib.com/ 福利吧: http://fuliba.net/ nanrenfuli: http://www.nanrenfuli.com 番号村: http://www.fanhaocun.com/ 宅男福利社: http://www.zhainanfulishe.net/ avbaike: http://www.avbaike.net leglegs: http://www.leglegs.com/ sexvid: http://sexvid.cc/ fuzokuav: http://fuzokuav.com/main.html 和邪社: http://www.hexieshe.com/ magazinesdownload: http://magazinesdownload.org/ vr: https://www.alicex.com/ 绝对领域 : http://www.jdlingyu.moe/ 骨感女穿包臀裙:https://www.douban.com/photos/album/1632810621/ 别总是在我背后:https://www.douban.com/people/56491865/ 看bilibili:http://www.kanbilibili.com/ (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"driver","slug":"driver","permalink":"https://austinxishou.github.io/tags/driver/"}]},{"title":"设计资源汇总","date":"2017-11-01T02:13:37.196Z","path":"2017/11/01/killtime/webdesign-source-collection/","text":"导航 牛大拿:http://niudana.com/ 全景图 flickr : https://www.flickr.com/ 视频素材 视崛:http://www.shij001.com/ 92素材网:http://www.92sucai.com/ 新GG儿:http://www.newcger.com/ 39视频:http://www.39video.com/ 字体 找字体: http://www.qiuziti.com/ 设计网站 优设: http://www.uisdc.com 设计癖 : http://www.shejipi.com/ 站酷 : http://www.zcool.com.cn indienova : http://indienova.com/ 建筑 : http://afasiaarchzine.com/ 创客贴 : https://www.chuangkit.com/ toptal : https://www.toptal.com/designers/ 设计工具 马克鳗设计稿标注 : http://www.getmarkman.com/ cutterman切图标注 : http://www.cutterman.cn/parker 标你妹 : http://www.biaonimeia.com/main 截图贴图 : http://zh.snipaste.com/ 配色 : http://www.fancynode.com.cn/colorcube/home 壁纸 picswalls : http://www.picswalls.com/ brothersoft : http://wallpapers.brothersoft.com/ Icon nucleoapp : https://nucleoapp.com/ easyicon : http://www.easyicon.net/ dribbble : https://dribbble.com/ pixabay : http://pixabay.com/ on1 : http://www.on1.com/500px/ icons8 : http://icons8.com/ findicons : http://findicons.com iconmatrix : http://iconmatrix.sharpmark.net/ thenounproject : https://thenounproject.com/ (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"design","slug":"design","permalink":"https://austinxishou.github.io/tags/design/"}]},{"title":"电影资源汇总","date":"2017-11-01T02:07:47.704Z","path":"2017/11/01/killtime/movie-resource-collection/","text":"电视直播 直播吧: http://www.zhiboo.net/ 江苏卫视: http://live.jstv.com/ jsr体育直播: http://nba.tmiaoo.com/nba.html 电影资源网站 PVideos-97:http://www.id97.com/ 云影院：http://www.yunyy.cc/ 高清控联盟：http://www.gaoqingkong.com/ 中国高清网：http://gaoqing.la/ 小无相：http://movtop.cn/ 优质电影网：http://www.youzhidy.com/ 蓝光电影网：http://www.hd1080.cn/ 电影王国：http://www.moviewg.com/ 电影天堂 : http://www.dy2018.com/ 电影小二网: http://movie002.com/ 搬运工 : http://banyungong.net/ 龙部落: http://www.xuandy.com/ 我飞网: http://www.bestxl.com/ 泡饭影视: http://www.chapaofan.com/ 天天美剧: http://www.ttmeiju.com/ 天天美剧电影:http://www.ttmeiju.com/meiju/Movie.html 电影FM : http://dianying.fm/ kickass: https://kickass.to/ MP4吧: http://www.mp4ba.com/ 迅播影院: http://www.xiamp4.com/ 新视觉影院:http://www.yy6080.org/ 深影论坛:http://www.shinybbs.com/forum.php 破烂熊乐园:http://www.ragbear.com/ 謦灵风软美剧论坛:http://1000fr.net/ 66kk:http://www.66kk.com/meiju/ 豆瓣皮:http://movie.doubanpi.com/ 豆瓣X:http://www.doubanx.com/ 特片:http://www.tepian.com/ 同步影院:http://www.tongbuyy.com/oumeiju/ 原来天天美剧网:http://www.yuanlai521.com/ ~~ 高清视界:http://www.4567.tv/ ~~ 8oS: http://www.80s.tw 全看TV : http://www.quankan.tv/ 起飞电影网 : http://www.ehecom.com/index.html 手机影院 大卫手机影院 : http://140tv.com/ 影视之家 : http://www.yingshimp.com/ 74hy: http://www.74hy.com/type/1.html 纪录片精品网站 Free DocumentAries：http://freedocumentaries.org/ Top DocumentaryFilm：http://topdocumentaryfilms.com/ District 7 Media:http://www.district7media.net/main/ Citizen 4Film:https://citizenfourfilm.com/ Documentary：http://documentaryaddict.com/ 腾讯记录片频道：http://v.qq.com/doco/ 央视记录片：http://jishi.cntv.cn/vod/keji/index.shtml 国外 iitv : http://iitv.pl/ 专业影评类网站 时光网: http://www.mtime.com/community/ 豆瓣电影:http://movie.douban.com/ 烂番茄: http://www.rottentomatoes.com/ IMBD: http://www.imdb.com/ 美国广播影评人协会:http://www.criticschoice.com/ 纽约影评家协会:http://www.nyfcc.com/ Film: http://www.film.com/ GoodFil.ms: http://goodfil.ms/ Cinephilia: http://cinephilia.net/ 公开课网站 网易公开课：http://open.163.com/ 中国大学MOOC：http://www.icourse163.org/ 新浪公开课：http://open.sina.com.cn/ 央视网–公开课：http://opencla.cntv.cn/ 爱课堂：http://www.icourses.cn/home/ MOOC中国：http://www.mooc.cn/ 超星公开课：http://openv.chaoxing.com/ (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); var sozzsrc = (document.location.protocol == \"http:\") ? \"http://js.passport.qihucdn.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\":\"https://jspassport.ssl.qhimg.com/11.0.1.js?6934e60f0fcbf5f113646cf0c3c61c6a\"; document.write(''); })();","tags":[{"name":"video","slug":"video","permalink":"https://austinxishou.github.io/tags/video/"}]}]