[{"title":"在线工具类网站","date":"2017-05-12T02:16:41.523Z","path":"killtime/cj2l840xk000l5opxp4bz0u29/killtime/tools/","text":"生活类 在线听歌: http://lab.mkblog.cn/music/ 翻译平台 Google翻译x: https://translate.google.com/ 有道: http://youdao.com/ 扇贝英语 : https://www.shanbay.com/ CNKI翻译助手：http://dict.cnki.net/ 句酷：http://www.jukuu.com/ 词都：http://www.dictall.com/ LINE Dictionary：http://ce.linedict.com/dict.html#/cnen/ Glosbe：https://glosbe.com/ 程序工具箱 在线正则 : http://regexr.com/ 编码转换 : http://tool.chinaz.com/Tools/Unicode.aspx Json检验 : http://www.bejson.com/ Json检验 : http://pro.jsonlint.com/ Json检验带错误行 : http://www.json.cn/ ping工具 : http://ping.chinaz.com/ RGB颜色查询 : http://www.atool.org/colorpicker.php 字符串处理 : http://www.5ixuexiwang.com/str/compress.php 在线运行代码 : http://www.shucunwang.com/RunCode/php/ 在线运行代码 : http://codepad.org/ 在线Sql : http://sqlfiddle.com/#!4/c0be1c/1 Ascii流程图 : http://asciiflow.com/ 1024tools:https://1024tools.com/ oschina:http://tool.oschina.net/ shell练习:http://cb.vu/ rsa和pkcs8转换:https://www.chinassl.net/ssltools/convert-key.html 程序在线工具:http://tool.lu/ 多线路速度测试:http://ping.chinaz.com/45.76.185.184 github的star管理:http://gitconstellation.com/#/ 在线mock工具:http://apizza.cc 在线gitignore生成工具:https://www.gitignore.io/ API 百度语音朗读:http://tts.baidu.com/text2audio?lan=zh&amp;ie=UTF-8&amp;text=%E4%BC%98%E9%85%B7%E5%BD%95%E5%B1%8F%E5%A4%A7%E5%B8%88 模拟数据:https://apiary.io/ 在线api文档: http://devdocs.io/ 解密 php在线解密: http://dezend.qiling.org/ md5解密: http://cmd5.com/ 国家代码查询 : https://countrycode.org/ 在线编辑 zybuluo : https://www.zybuluo.com/ markdown_table生成 : http://www.tablesgenerator.com/markdown_tables processon协作:http://www.processon.com/ 石墨:https://shimo.im/ tower在线办公:https://tower.im/ 钉钉:https://www.dingtalk.com/ 马克飞象:https://maxiang.io/ 在线时序图:https://www.websequencediagrams.com/ stackedit:https://stackedit.io/ 其他工具 video_to_gif: http://ezgif.com/video-to-gif markdwon转换: http://pandoc.org/try/ 在线测速: http://www.speedtest.net/ 在线签到: https://qiandao.today/ 微信对话生成: http://www.duihuashengchengqi.com/ 飞机航班追踪：https://www.flightradar24.com/ 清华大学镜像站:https://mirrors.tuna.tsinghua.edu.cn/ dll之家:http://www.dllzj.com/ 流量宝:http://www.liuliangbao.cn/ 百度网盘永久直链外链:http://pan.plyz.net/ 艺匠独立作品:https://artizen.cc/ dnsmasq:https://g2w.online/ tinypng:https://tinypng.com/ 方糖收微信消息:http://sc.ftqq.com/3.version 随机生成美国身份: http://www.haoweichi.com/Index/random 前端预处理器语言图形编译工具: http://koala-app.com/index-zh.html","tags":[{"name":"design","slug":"design","permalink":"https://austinxishou.github.io/tags/design/"}]},{"title":"软件及源码仓库收集","date":"2017-05-12T02:16:41.522Z","path":"killtime/cj2l840xi000j5opx6rgt5wv5/killtime/soft_site/","text":"软件 小众软件: http://www.appinn.com/ 异次元:http://www.iplaysoft.com/ 精品绿色便携软件 : http://www.portablesoft.org/ 大眼仔 : http://www.dayanzai.me/ 少轻狂: http://www.flighty.cn/ 殁漂遥: http://www.shaoit.com/ 冰点软件:http://www.bingdian001.com/ mac xclient : http://xclient.info/ 反斗软件: http://www.apprcn.com/ 爱情守望者: http://www.waitsun.com/ 威锋: http://bbs.feng.com/forum.php?mod=forumdisplay&amp;fid=19&amp;page= 源码站 资源爱好者: http://www.aihao.org/ 游戏素材: http://www.6m5m.com/index.php 车库源码: http://www.src.cool/portal.php 零度源码:http://www.0dyx.cn/ 我爱h5游戏:http://www.52h5game.com/","tags":[{"name":"design","slug":"design","permalink":"https://austinxishou.github.io/tags/design/"}]},{"title":"找资源","date":"2017-05-12T02:16:41.521Z","path":"killtime/cj2l840x6000f5opxj5ytl0wb/killtime/search/","text":"找资源 西林街：http://www.xilinjie.com/ 胖次：http://www.panc.cc/ 找文件：http://www.zhaofile.com/ 呆木瓜：http://www.daimugua.com/ 爱挖盘：http://www.iwapan.com/ 57百度云：http://baiduyun.57fx.cn/index-index.html 云盘搜索大师:http://www.xiandoudou.com/ 靠谱搜索:http://kaopu.so/ 网盘搜: http://www.wangpansou.cn/ BT种子搜索引擎 BT搜搜 :http://www.btsoso.me/ BTbook: http://www.btbook.net/ Runbt : http://www.runbt.com/ Diggbt: http://www.diggbt.com/ BT樱桃:http://www.btcherry.com/ BTdigg: https://btdigg.org/ btsoufuli: http://www.btsoufuli.com/ btkitty: http://btkitty.bid/ btdao: http://www.btdao.biz/ rarbg: https://rarbg.to/torrents.php/ btavmo: http://www.btavmo.com/ coretorrents: http://coretorrents.com/ mytorrents: http://mytorrents.org/ bt1024: http://www.bt1024.net/ 导航 龙轩导航 : http://ilxdh.com/","tags":[{"name":"driver","slug":"driver","permalink":"https://austinxishou.github.io/tags/driver/"}]},{"title":"电影资源汇总","date":"2017-05-12T02:16:41.519Z","path":"killtime/cj2l840x4000e5opx152r88xj/killtime/movie/","text":"电视直播 直播吧: http://www.zhiboo.net/ 江苏卫视: http://live.jstv.com/ jsr体育直播: http://nba.tmiaoo.com/nba.html 电影资源网站 PVideos-97:http://www.id97.com/ 云影院：http://www.yunyy.cc/ 高清控联盟：http://www.gaoqingkong.com/ 中国高清网：http://gaoqing.la/ 小无相：http://movtop.cn/ 优质电影网：http://www.youzhidy.com/ 蓝光电影网：http://www.hd1080.cn/ 电影王国：http://www.moviewg.com/ 电影天堂 : http://www.dy2018.com/ 电影小二网: http://movie002.com/ 搬运工 : http://banyungong.net/ 龙部落: http://www.xuandy.com/ 我飞网: http://www.bestxl.com/ 泡饭影视: http://www.chapaofan.com/ 天天美剧: http://www.ttmeiju.com/ 天天美剧电影:http://www.ttmeiju.com/meiju/Movie.html 电影FM : http://dianying.fm/ kickass: https://kickass.to/ MP4吧: http://www.mp4ba.com/ 迅播影院: http://www.xiamp4.com/ 新视觉影院:http://www.yy6080.org/ 深影论坛:http://www.shinybbs.com/forum.php 破烂熊乐园:http://www.ragbear.com/ 謦灵风软美剧论坛:http://1000fr.net/ 66kk:http://www.66kk.com/meiju/ 豆瓣皮:http://movie.doubanpi.com/ 豆瓣X:http://www.doubanx.com/ 特片:http://www.tepian.com/ 同步影院:http://www.tongbuyy.com/oumeiju/ 原来天天美剧网:http://www.yuanlai521.com/ ~~ 高清视界:http://www.4567.tv/ ~~ 8oS: http://www.80s.tw 全看TV : http://www.quankan.tv/ 起飞电影网 : http://www.ehecom.com/index.html 手机影院 大卫手机影院 : http://140tv.com/ 影视之家 : http://www.yingshimp.com/ 74hy: http://www.74hy.com/type/1.html 纪录片精品网站 Free DocumentAries：http://freedocumentaries.org/ Top DocumentaryFilm：http://topdocumentaryfilms.com/ District 7 Media:http://www.district7media.net/main/ Citizen 4Film:https://citizenfourfilm.com/ Documentary：http://documentaryaddict.com/ 腾讯记录片频道：http://v.qq.com/doco/ 央视记录片：http://jishi.cntv.cn/vod/keji/index.shtml 国外 iitv : http://iitv.pl/ 专业影评类网站 时光网: http://www.mtime.com/community/ 豆瓣电影:http://movie.douban.com/ 烂番茄: http://www.rottentomatoes.com/ IMBD: http://www.imdb.com/ 美国广播影评人协会:http://www.criticschoice.com/ 纽约影评家协会:http://www.nyfcc.com/ Film: http://www.film.com/ GoodFil.ms: http://goodfil.ms/ Cinephilia: http://cinephilia.net/ 公开课网站 网易公开课：http://open.163.com/ 中国大学MOOC：http://www.icourse163.org/ 新浪公开课：http://open.sina.com.cn/ 央视网–公开课：http://opencla.cntv.cn/ 爱课堂：http://www.icourses.cn/home/ MOOC中国：http://www.mooc.cn/ 超星公开课：http://openv.chaoxing.com/","tags":[{"name":"video","slug":"video","permalink":"https://austinxishou.github.io/tags/video/"}]},{"title":"","date":"2017-05-12T02:16:41.518Z","path":"uncategorized/cj2l840x2000d5opxypwkjfhg/killtime/game/","text":"游戏站推荐 拼命玩游戏 : http://wanga.me/ ArmorGames : http://armorgames.com/ u77汉化 : http://www.u77.com/ taptap : https://www.taptap.com/","tags":[]},{"title":"老司机资源汇总","date":"2017-05-12T02:16:41.518Z","path":"killtime/cj2l840wr000a5opxhjwobsby/killtime/driver/","text":"磁力 磁力播播: http://cilibobo.cc/ 九秒在线: http://apiv.ga/magnet/ youtube下载 yout: https://yout.com/ savefrom: http://en.savefrom.net/ savemedia: https://savemedia.com/en/ clipconverter: http://www.clipconverter.cc/ Tumblr Tumblr热度: http://heimu360.applinzi.com/index.php?m=Home&amp;c=Index&amp;a=stat 91视频: http://freeget.co/ 直播聚合 直播盒子: http://www.zhubohezi.com/ vip视频,广告过滤 硕鼠 : http://www.flvcd.com/index.htm dsqndh: http://v.dsqndh.com/ 紫狐:http://api.zihu.tv/ 测试地址 爱奇艺: http://www.iqiyi.com/v_19rr9nt2p8.html 优酷: http://v.youku.com/v_show/id_XMTc3NjUxMDU2MA==.html?spm=a2h03.8164468.2069780.11 乐视: http://www.le.com/ptv/vplay/26677046.html?ref=hypdrydp 芒果TV: http://www.mgtv.com/v/1/303260/f/3665598.html 腾讯: http://v.qq.com/x/cover/mhlkz47d7thi2k4.html 通用接口 wmxz: http://www.wmxz.wang/video.php?url=http://www.mgtv.com/v/1/303260/f/3665598.html (高清)其他域名http://100000001.top(1-10):支持域名绑定A记录解析到47.89.49.245 aikantv: http://jx.aikantv.cc/index.php?url=http://www.mgtv.com/v/3/8849/f/307467.html (高清) moondown:http://moon.moondown.net/tong.php?url=http://www.mgtv.com/v/2/104817/f/3621326.html 测试页面 000o: http://000o.cc/jx/ty.php?url=http://www.mgtv.com/v/1/298442/f/3640929.html yydy8: http://www.yydy8.com/Common/?url=http://www.mgtv.com/v/1/303260/f/3665598.html (高清) ckparse: http://www.ckparse.com/ckparse/?url=http://www.mgtv.com/v/1/303260/f/3665598.html (高清) 九澧影院:http://dy.jiuli8.com/jiuli8/?url= 紫狐:http://yun.zihu.tv/play.html?url=http://v.qq.com/x/cover/mhlkz47d7thi2k4.html wbg3721:http://api.wbg3721.club/?url=http://www.iqiyi.com/v_19rrm2pgd4.html?fc=8b62d5327a54411b#vfrm=19-9-0-1 mp4la : http://api.mp4la.net/?url=http://v.youku.com/v_show/id_XMTc3NjUxMDU2MA==.html?spm=a2h03.8164468.2069780.11 990969_1: http://www.990969.top/jiu/vip1.php?url=http://www.iqiyi.com/v_19rr9nt2p8.html 990969_2: http://www.990969.top/jiu/vip2.php?url=http://www.iqiyi.com/v_19rr9nt2p8.html 990969_3: http://www.990969.top/jiu/vip3.php?url=http://www.iqiyi.com/v_19rr9nt2p8.html mt2t:http://mt2t.com/yun?url=http://www.mgtv.com/v/1/303260/f/3665598.html 五奇艺:http://vip.sdyhy.cn/ckflv/?url= qtzr:http://qtzr.net/s/?qt=http://v.qq.com/x/cover/mhlkz47d7thi2k4.html xiguaso:http://www.xiguaso.com/api/index.php?url=http://v.qq.com/x/cover/mhlkz47d7thi2k4.html vipjiexi:http://www.vipjiexi.com/yun.php?url=http://v.qq.com/x/cover/mhlkz47d7thi2k4.html 芒果tv 47ks: http://v.47ks.com/v2/videoplayer/api.html?u=http://www.mgtv.com/v/3/293930/f/3623801.html mmhhw: http://api.mmhhw.cn/huan6/mgtv.php?vid=3665598 1314yq: http://api.1314yq.com/mgtv.php?url=http://www.mgtv.com/v/1/303260/f/3665598.html 52jizhi: http://52jizhi.cn/6/vip1.php?url=http://www.mgtv.com/v/1/303260/f/3665598.html 优酷 200919 : http://www.200919.com/tv/v.php?url=http://v.youku.com/v_show/id_XMTc3NjUxMDU2MA==.html?spm=a2h03.8164468.2069780.11 quankan : http://www.quankan.tv/playz/youku.php?url=http://v.youku.com/v_show/id_XMTc2NjA1NDgwNA==.html?spm=a2h03.8164468.2069780.5 moease: http://www.moease.org/tao_ddv.php?vid=http://v.youku.com/v_show/id_XMTc3NjUxMDU2MA==.html?spm=a2h03.8164468.2069780.11 mmhhw : http://api.mmhhw.cn/huan6/mgtv66.php?vid=CMzcxNTUzMg== (c值) zhaogou8 : http://ykyun.zhaogou8.com/?v=CNjgzODc5Ng== (c值) zai63 : http://player.zai63.com/yunparse/?vid=CMzcxNTUzMg== (c值) 腾讯 quankan: http://www.quankan.tv/playpc/index.php?url=http://v.qq.com/x/cover/nye24rhm7f8dyry.html aikantv: http://api.aikantv.cc/?url=http://v.qq.com/x/cover/mhlkz47d7thi2k4.html apifree : http://www.apifree.net/ckplayer.jsp?id=apifree&amp;sp=vqq&amp;by=url&amp;value=http%3A%2F%2Fv.qq.com%2Fx%2Fcover%2Fczi2qltdys4wc3k.html&amp;single= 爱奇艺 72du: http://v.72du.com/api/?url=http://www.iqiyi.com/v_19rr9nt2p8.html ckplayer: http://ckplayer.duapp.com/?url=http://www.iqiyi.com/v_19rr9nt2p8.html yydy8: http://www.yydy8.com/Common/?url=http://www.iqiyi.com/v_19rr9nt2p8.html 97zxkan: http://www.97zxkan.com/jiexi/97zxkanapi.php?url=http://www.iqiyi.com/v_19rr9nt2p8.html 20000817: http://sp.20000817.pw/?url=http://www.iqiyi.com/v_19rrm2t3x0.html wanwantv: http://vip.wanwantv.com/yunparse/?url=http://www.iqiyi.com/v_19rrlzki4s.html 乐视 mmhhw:http://api.mmhhw.cn/huan6/letvvip.php?vid=26677046 A 站 aiwlan : http://hp.aiwlan.net/79iw.php?vid=1238251&amp;t=ykyun&amp;w=100%&amp;h=94% 2mm moondown:http://moon.moondown.net/2mm.php?url=http://www.2ni.la/sy147 接口失效黑色单 jiexi.71ki.com wyccoo.cn avziliao lklhd ehecom.com ivlook.com rpsofts.com shop.freegx.cn licoy.cn yunbofang.duapp.cn api.ppypp ccok.top qqdzz.com vip.77ds.vip litools.licoy.cn 其他 舒克高清视频下载:http://www.shokdown.com/index.php 夏贝贝网盘: http://xabb360.net/index.php?m=Login uzer: https://uzer.me/ 买家秀: http://www.mjxzs.cc/ 豆瓣请不要害羞: https://f.binux.me/haixiuzu.html 豆瓣请不要害羞: https://haixiu.herokuapp.com/ reddit: https://www.reddit.com/ 微博视频下载: http://www.weibovideo.com/ bilibili解析: http://www.ibilibili.com/video/av8355080/ 斗鱼火箭监控: http://douyu.shiniv.com/ 百度外链不限速: http://pan.plyz.net/ 福利油猴脚本: https://sleazyfork.org/zh-CN 网易云音乐: http://projects.qiyichao.cn/netease-music-parse/ 资讯 免费吧: http://www.mianfeib.com/ 福利吧: http://fuliba.net/ nanrenfuli: http://www.nanrenfuli.com 番号村: http://www.fanhaocun.com/ 宅男福利社: http://www.zhainanfulishe.net/ avbaike: http://www.avbaike.net leglegs: http://www.leglegs.com/ sexvid: http://sexvid.cc/ fuzokuav: http://fuzokuav.com/main.html 和邪社: http://www.hexieshe.com/ magazinesdownload: http://magazinesdownload.org/ vr: https://www.alicex.com/ 绝对领域 : http://www.jdlingyu.moe/ 骨感女穿包臀裙:https://www.douban.com/photos/album/1632810621/ 别总是在我背后:https://www.douban.com/people/56491865/ 看bilibili:http://www.kanbilibili.com/","tags":[{"name":"driver","slug":"driver","permalink":"https://austinxishou.github.io/tags/driver/"}]},{"title":"设计资源汇总","date":"2017-05-12T02:16:41.517Z","path":"killtime/cj2l840wp00085opx0u9exkmb/killtime/design/","text":"导航 牛大拿:http://niudana.com/ 视频素材 视崛:http://www.shij001.com/ 92素材网:http://www.92sucai.com/ 新GG儿:http://www.newcger.com/ 39视频:http://www.39video.com/ 字体 找字体: http://www.qiuziti.com/ 设计网站 优设: http://www.uisdc.com 设计癖 : http://www.shejipi.com/ 站酷 : http://www.zcool.com.cn indienova : http://indienova.com/ 建筑 : http://afasiaarchzine.com/ 创客贴 : https://www.chuangkit.com/ 设计工具 马克鳗设计稿标注 : http://www.getmarkman.com/ cutterman切图标注 : http://www.cutterman.cn/parker 标你妹 : http://www.biaonimeia.com/main 截图贴图 : http://zh.snipaste.com/ 配色 : http://www.fancynode.com.cn/colorcube/home 壁纸 picswalls : http://www.picswalls.com/ brothersoft : http://wallpapers.brothersoft.com/ Icon nucleoapp : https://nucleoapp.com/ easyicon : http://www.easyicon.net/ dribbble : https://dribbble.com/ pixabay : http://pixabay.com/ on1 : http://www.on1.com/500px/ icons8 : http://icons8.com/ findicons : http://findicons.com iconmatrix : http://iconmatrix.sharpmark.net/ thenounproject : https://thenounproject.com/","tags":[{"name":"design","slug":"design","permalink":"https://austinxishou.github.io/tags/design/"}]},{"title":"","date":"2017-05-12T02:16:41.513Z","path":"uncategorized/cj2l840wn00065opxhqmercv2/killtime/cartoon/","text":"动漫动漫资源网站 Animation World Network：http://www.awn.com/ 皮克斯帝国：http://pixarempire.com/ 动漫花园：http://share.dmhy.org 简单动漫：http://www.36dm.com/ 漫画书：http://manhuashu.net/ 旋风动漫：http://bt.xfsub.com/","tags":[]},{"title":"Android 冻结APP","date":"2017-05-04T03:07:12.925Z","path":"android/cj29uf5ph0000zopxa5jy1cqz/android/Android 冻结不常用的app/","text":"功能说明 在国内的Android生态中,所有的APP开发者都是一种流氓的心态,后台服务一大堆,还监听各种广播,导致用户根本不可能完全删除后台服务;有人说既然他们流氓,你不用他们就是,卸载掉啊!!哎,一些主流公司的APP,即使知道他流氓,还真的继续用它,比如支付宝\\微信等; 所以采用冻结的方法是最有效,最干净的,只是可惜 pm disable 这个权限Android并没有对普通应用开放,也是一个蛋疼的事情.Android生态也是,申请各种权限不需要root,反而关闭权限需要; 使用冻结APP的场景: 某些应用开启大量后台服务,导致系统响应缓慢,再不能卸载的情况下,冻结它; 某些不常用的APP,但是需要的时候重新下载又麻烦,冻结它; 某些应用后台大量更新数据,消耗流量,冻结它; 冻结app解冻后,保留所有应用数据,不用担心数据丢失,账号重新登录等; 主要代码实现冻结APP1234567891011121314public void disableApp(String appPackageName)&#123; try &#123; Process localProcess=Runtime.getRuntime().exec(\"su\"); String cmd=\"pm disable \"+appPackageName+\"\\n\"; DataOutputStream dataOutputStream=new DataOutputStream(localProcess.getOutputStream()); dataOutputStream.writeBytes(cmd); dataOutputStream.flush(); dataOutputStream.writeBytes(\"exit\\n\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 解冻APP123456789101112131415public void enableApp(String appPackageName)&#123; try &#123; Process localProcess=Runtime.getRuntime().exec(\"su\"); String cmd=\"pm enable \"+appPackageName+\"\\n\"; DataOutputStream dataOutputStream=new DataOutputStream(localProcess.getOutputStream()); dataOutputStream.writeBytes(cmd); dataOutputStream.flush(); dataOutputStream.writeBytes(\"exit\\n\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"}]},{"title":"python 多线程实践","date":"2017-05-04T01:43:52.969Z","path":"python/cj29tr79i0006fkpxmknjd74o/python/python多线程实践/","text":"多线程 threading模块 Python中的多线程操作有两种方式： 函数式(thread)和继承(threading.Threading)式 python是支持多线程的，并且是native的线程。主要是通过thread和threading这两个模块来实现的。thread是比较底层的模 块，threading是对thread做了一些包装的，可以更加方便的被使用。 函数式 1234def function adbc()threading.Thread(target=fun,args=(a,b))或者thread.start_new_thread(fun,(a,b))启动线程 守护进程 如果你的主线程在退出的时候，不用等待那些子线程完成，那就设置这些线程的 daemon 属性。即，在线程开始 thread.start()之前，调用setDeamon()函数，设定线程的daemon标志。thread.setDaemon(True)就表示这个线程“不重要”。 如果你想等待子线程完成再退出，那就什么都不用做。，或者显示地调用thread.setDaemon(False)，设置daemon的值为false。新的子线程会继承父线程的daemon标志。整个Python会在所有的非守护线程退出后才会结束，即进程中没有非守护线程存在的时候才结束。 根据原装官方文档的解释，主线程在所有非守护线程都死亡后才会被kill，这样当你忘记使用threading.Thread.exit_thread()或者thread_stop()的时候，嘿嘿，你的程序中主线程收到结束信号，但是因为有一个非守护进程的存在，所以等待。 Queue模块 Queue模块实现了多生产者、多消费者队列。它特别适用于信息必须在多个线程间安全地交换的多线程程序中。这个模块中的Queue类实现了所有必须的锁语义。它依赖于Python中线程支持的可用性；参见threading模块。 特性参数模块实现了三类队列：FIFO（First In First Out，先进先出，默认为该队列）、LIFO（Last In First Out，后进先出）、基于优先级的队列。以下为其常用方法：12345678910111213先进先出 q = Queue.Queue(maxsize)后进先出 a = Queue.LifoQueue(maxsize)优先级 Queue.PriorityQueue(maxsize)Queue.qsize() 返回队列的大小Queue.empty() 如果队列为空，返回True,反之FalseQueue.full() 如果队列满了，返回True,反之FalseQueue.full 与 maxsize 大小对应Queue.put(item) 写入队列，timeout等待时间 非阻塞Queue.get([block[, timeout]]) 获取队列，timeout等待时间Queue.get_nowait() 相当Queue.get(False)Queue.put_nowait(item) 相当Queue.put(item, False)Queue.task_done() 在完成一项工作之后，函数向任务已经完成的队列发送一个信号Queue.join()： 实际上意味着等到队列为空，再执行别的操作","tags":[{"name":"python","slug":"python","permalink":"https://austinxishou.github.io/tags/python/"},{"name":"threading","slug":"threading","permalink":"https://austinxishou.github.io/tags/threading/"}]},{"title":"Android-OTA(四) updater功能解析","date":"2017-04-14T09:12:59.419Z","path":"android/cj1hopnwb0000kkpxjlyt3iyd/android/Android-OTA(四) updater功能解析/","text":"简介 可以说，前面分析的OTA升级的各部分代码都是在搭一个舞台，而主角现在终于登场，它就是updater. Google的代码架构设计非常好，各部分尽量松耦合。前面介绍升级脚本时，可知有两种类型的脚本，amend&amp; edify. 他们各自对应一个updater. 这里，我们主要关注新的edify的updater. 源码文件tree12345678.├── Android.mk├── blockimg.c├── blockimg.h├── install.c├── install.h├── updater.c└── updater.h 入口函数 main 处理version 参数 获取命令管道 Set up the pipe for sending commands back to the parent process. 读入脚本 mzFindZipEntry(&amp;za, SCRIPT_NAME); 注册语句处理函数 Configure edify’s functions. 解析脚本命令 Parse the script. 执行脚本 核心函数是 Evaluate。它会调用其他callback函数，而这些callback函数又会调用Evaluate去解析不同的脚本片段。 主流程的代码非常简单,因为细节隐藏在那些 callback 函数里。 callback函数 RegisterBuiltins 1234567891011void RegisterBuiltins() &#123; RegisterFunction(\"ifelse\", IfElseFn); RegisterFunction(\"abort\", AbortFn); RegisterFunction(\"assert\", AssertFn); RegisterFunction(\"concat\", ConcatFn); RegisterFunction(\"is_substring\", SubstringFn); RegisterFunction(\"stdout\", StdoutFn); RegisterFunction(\"sleep\", SleepFn); RegisterFunction(\"less_than_int\", LessThanIntFn); RegisterFunction(\"greater_than_int\", GreaterThanIntFn);&#125; RegisterInstallFunctions 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void RegisterInstallFunctions() &#123; RegisterFunction(\"mount\", MountFn); RegisterFunction(\"is_mounted\", IsMountedFn); RegisterFunction(\"unmount\", UnmountFn); RegisterFunction(\"format\", FormatFn); RegisterFunction(\"show_progress\", ShowProgressFn); RegisterFunction(\"set_progress\", SetProgressFn); RegisterFunction(\"delete\", DeleteFn); RegisterFunction(\"delete_recursive\", DeleteFn); RegisterFunction(\"package_extract_dir\", PackageExtractDirFn); RegisterFunction(\"package_extract_file\", PackageExtractFileFn); RegisterFunction(\"symlink\", SymlinkFn); // Usage: // set_metadata(\"filename\", \"key1\", \"value1\", \"key2\", \"value2\", ...) // Example: // set_metadata(\"/system/bin/netcfg\", \"uid\", 0, \"gid\", 3003, \"mode\", 02750, \"selabel\", \"u:object_r:system_file:s0\", \"capabilities\", 0x0); RegisterFunction(\"set_metadata\", SetMetadataFn); // Usage: // set_metadata_recursive(\"dirname\", \"key1\", \"value1\", \"key2\", \"value2\", ...) // Example: // set_metadata_recursive(\"/system\", \"uid\", 0, \"gid\", 0, \"fmode\", 0644, \"dmode\", 0755, \"selabel\", \"u:object_r:system_file:s0\", \"capabilities\", 0x0); RegisterFunction(\"set_metadata_recursive\", SetMetadataFn); RegisterFunction(\"getprop\", GetPropFn); RegisterFunction(\"file_getprop\", FileGetPropFn); RegisterFunction(\"write_raw_image\", WriteRawImageFn); RegisterFunction(\"write_raw_parameter_image\", WriteRawParameterImageFn); RegisterFunction(\"clear_misc_command\", ClearMiscCommandFn); RegisterFunction(\"apply_patch\", ApplyPatchFn); RegisterFunction(\"apply_patch_check\", ApplyPatchCheckFn); RegisterFunction(\"apply_patch_space\", ApplyPatchSpaceFn); RegisterFunction(\"wipe_block_device\", WipeBlockDeviceFn); RegisterFunction(\"read_file\", ReadFileFn); RegisterFunction(\"sha1_check\", Sha1CheckFn); RegisterFunction(\"rename\", RenameFn); RegisterFunction(\"wipe_cache\", WipeCacheFn); RegisterFunction(\"ui_print\", UIPrintFn); RegisterFunction(\"run_program\", RunProgramFn); RegisterFunction(\"reboot_now\", RebootNowFn); RegisterFunction(\"get_stage\", GetStageFn); RegisterFunction(\"set_stage\", SetStageFn); RegisterFunction(\"enable_reboot\", EnableRebootFn); RegisterFunction(\"tune2fs\", Tune2FsFn);&#125; RegisterBlockImageFunctions 12345void RegisterBlockImageFunctions() &#123; RegisterFunction(\"block_image_verify\", BlockImageVerifyFn); RegisterFunction(\"block_image_update\", BlockImageUpdateFn); RegisterFunction(\"range_sha1\", RangeSha1Fn);&#125; FinishRegistration123void FinishRegistration() &#123; qsort(fn_table, fn_entries, sizeof(NamedFunction), fn_entry_compare);&#125;","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"OTA","slug":"OTA","permalink":"https://austinxishou.github.io/tags/OTA/"},{"name":"recovery","slug":"recovery","permalink":"https://austinxishou.github.io/tags/recovery/"}]},{"title":"Android-OTA(三) recovery 功能解析","date":"2017-04-14T03:45:15.978Z","path":"android/cj1hl960a0001pgpxwqpxtw16/android/Android-OTA(三)recovery功能解析/","text":"简介recovery 作为系统的恢复工具,有以下几点功能: 首先是我们熟悉的恢复工厂设置 –&gt; wipe_data wipe_cache 刷升级包，可以通过sdcard升级，通常说的卡刷，有些还提供ADB sideload升级； 可以进行系统的系统的OTA升级，本质上同手动刷包一样； recovery 与 主系统交互是通过 /cache 目录下的文件: /cache/recovery/command 作为recovery的输入参数,以行为分割 /cache/recovery/log 收集recovery的日志文件 /cache/recovery/intent 输出后续操作指令 recovery最后是编译成一个可执行的命令，放在recovery文件系统中的/sbin/recovery；所以我们可以在终端中直接运行该命令，具体的参数如下： 1234567--send_intent=anystring - 传递给recovery的信息--adbd -adb sideload升级--update_package=path - 指定OTA升级包--wipe_data - 清楚用户数据并重启--wipe_cache - 清楚缓存并重启--set_encrypted_filesystem=on|off - 使能或者关闭文件系统加密--just_exit - 退出并重启 recovery生成先看一下 build/core/Makefile 的依赖文件:123456789101112$(INSTALLED_RECOVERYIMAGE_TARGET): $(MKBOOTFS) $(MKBOOTIMG) $(MINIGZIP) \\ $(INSTALLED_RAMDISK_TARGET) \\ $(INSTALLED_BOOTIMAGE_TARGET) \\ $(INTERNAL_RECOVERYIMAGE_FILES) \\ $(recovery_initrc) $(recovery_sepolicy) $(recovery_kernel) \\ $(INSTALLED_2NDBOOTLOADER_TARGET) \\ $(recovery_build_prop) $(recovery_resource_deps) \\ $(recovery_fstab) \\ $(recovery_fstab_mtd) \\ $(recovery_fstab_emmc) \\ $(RECOVERY_INSTALL_OTA_KEYS) $(call build-recoveryimage-target, $@) 123456789101．MKBOOTFS, MINIGZIP, MKBOOTIMG，PC端工具软件 2．INSTALLED_RAMDISK_TARGET,标准根文件系统 ramdisk.img 3．INSTALLED_BOOTIMAGE_TARGET,即boot.img,标准内核及标准根文件系统 4. recovery_binary, Recovery可执行程序，源码位于：bootable/recovery 5. recovery_initrc，recovery模式的init.rc, 位于 bootable/recovery/etc/init.rc 6. recovery_kernel, recovery 模式的kernel, 同标准内核 7. INSTALLED_2NDBOOTLOADER_TARGET，我们不用 8. recovery_build_prop， recovery 模式的build.prop, 同标准模式 9. recovery_resource_deps， recovery 模式使用的res, 位于：recovery/custom/&#123;product_name&#125;/res 10. RECOVERY_INSTALL_OTA_KEYS, ota 密钥 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455recovery├── charger -&gt; /sbin/healthd├── data├── default.prop├── dev├── drmboot.ko├── etc│ ├── recovery.emmc.fstab│ └── recovery.fstab├── file_contexts├── fstab.rk30board.bootmode.emmc├── fstab.rk30board.bootmode.unknown├── init├── init.bootmode.emmc.rc├── init.bootmode.unknown.rc├── init.rc├── oem├── proc├── property_contexts├── res│ ├── images│ │ ├── erasing_text.png│ │ ├── error_text.png│ │ ├── font.png│ │ ├── icon_error.png│ │ ├── icon_installing.png│ │ ├── installing_text.png│ │ ├── no_command_text.png│ │ ├── progress_empty.png│ │ ├── progress_fill.png│ │ ├── stage_empty.png│ │ └── stage_fill.png│ └── keys├── rk30xxnand_ko.ko├── sbin│ ├── adbd│ ├── busybox│ ├── e2fsck│ ├── healthd│ ├── mkdosfs│ ├── mkfs.f2fs│ ├── recovery│ ├── resize2fs│ ├── sh│ ├── ueventd -&gt; ../init│ └── watchdogd -&gt; ../init├── seapp_contexts├── selinux_version├── sepolicy├── service_contexts├── sys├── system├── tmp├── ueventd.rc└── ueventd.rk30board.rc recovery根文件系统从bootloader 进入Recovery 模式后，首先也是运行Linux内核，该内核跟普通模式没有区别(减轻了BSP开发者的任务)。区别从执行文件系统开始。 Recovery 模式的细节就隐藏在其根文件系统中。下面，我们就看看进入Recovery 根文件系统都干些啥。 init.rc和正常启动一样，内核进入文件系统会执行/init, init 的配置文件就是 /init.rc 主要功能为: 设置环境变量; 建立 etc 链接; 挂载文件系统并创建文件夹目录; 启动 recovery主程序; 执行流程分析在Android源码环境中，recovery的源码主要在bootable/recovery文件下，另外在device目录下，会根据各个设备定制自己的接口以及UI界面，也就是文章后半部分分析的界面定制的内容； 在bootable/recovery目录下，看Android.mk文件的源文件列表：123456789101112LOCAL_SRC_FILES := \\ adb_install.cpp \\ asn1_decoder.cpp \\ bootloader.cpp \\ device.cpp \\ fuse_sdcard_provider.c \\ install.cpp \\ recovery.cpp \\ roots.cpp \\ screen_ui.cpp \\ ui.cpp \\ verifier.cpp \\ 主要执行流程 标准错误输出重定向 将标准输出和标准错误输出重定位到”/tmp/recovery.log”,如果是eng模式，就可以通过adb pull /tmp/recovery.log, 看到当前的log信息，这为我们提供了有效的调试手段。后面还会看到，recovery模式运行完毕后，会将其拷贝到cache分区，以便后续分析。 miniui初始化 Recovery 使用了一个简单的基于framebuffer的ui系统，叫miniui,这里，进行了简单的初始化（主要是图形部分以及事件部分），并启动了一个 event 线程用于响应用户按键。 解析参数 从misc 分区以及 CACHE:recovery/command 文件中读入参数，写入到argc, argv ,并且，如果有必要，回写入misc分区。这样，如果recovery没有操作成功（比如，升级还没有结束，就拔电池），系统会一直进入recovery模式。提醒用户继续升级，直到成功。 设备定制文件初始化 device_recovery_start() 它給设备制造商提供了一个调用机会，可写入设备相关初始化代码。 根据命令参数,执行命令 根据用户提供参数，调用各项功能，比如，安装一个升级包，擦除cache分区, 擦除user data分区，install_package比较复杂。 完成指令后,等待用户后续指令 如果前面已经做了某项操作并且成功，则进入重启流程。否则，等待用户选择具体操作。而用户可选操作为： reboot, 安装update.zip，除cache分区, 擦除user data分区,如前所述，只有安装package 比较复杂，其它简单。 结束recovery finish_recovery(send_intent); 它的功能如下： 1. 将前面定义的intent字符串写入（如果有的话）：CACHE:recovery/command 2. 将 /tmp/recovery.log 复制到 &quot;CACHE:recovery/log&quot;; 3. 清空 misc 分区，这样重启就不会进入recovery模式4)删除command 文件：CACHE:recovery/command; 核心函数 really_install_package 更新UI显示 ui-&gt;Print 更新升级时UI界面显示 确保所有分区正确挂载 ensure_path_mounted ,主要是cache分区或者SD分区 读取update.zip文件 load_keys 装载公钥 verify_file 注释很清楚,就是签名的验证; 打开升级包 mzOpenZipArchive，将相关信息存到 ZipArchive 数据结构中，便于后面处理。 调用try_update_binary继续执行 如果升级包中包含脚本文件,则解压执行;主要功能都在这个函数中完成,接下去继续分析; 复制脚本文件 将升级包内文件META-INF/com/google/android/update-binary 复制为/tmp/update_binary 创建新的进程，执行：/tmp/update_binary 主进程与子进程通过管道进行进程间通信;原进程变成一个服务进程，它提供UI更新服务;包括:更新精度条,打印提示信息,清除缓存,清除显示等 执行update_binary 这样，我们又回到了升级包中的文件：META-INF/com/google/android/update-binary","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"OTA","slug":"OTA","permalink":"https://austinxishou.github.io/tags/OTA/"},{"name":"recovery","slug":"recovery","permalink":"https://austinxishou.github.io/tags/recovery/"}]},{"title":"Android-OTA(二)ota_from_target_files命令解析","date":"2017-04-14T03:25:29.926Z","path":"android/cj1hl960a0003pgpx0z33z1lg/android/Android-OTA(二)ota_from_target_files命令解析/","text":"简介主要是从一个输入的中间压缩包,生成OTA升级包 1234567./build/tools/releasetools/ota_from_target_filesGiven a target-files zipfile, produces an OTA package that installsthat build. An incremental OTA is produced if -i is given, otherwisea full OTA is produced.Usage: ota_from_target_files [flags] input_target_files output_ota_package 常用的参数:12345678-k 指定签名文件,默认为\"build/target/product/security/testkey\"-i 指定源文件-p 指定编译主机可执行文件路径-v 冗余信息打印-w 清除用户数据-e 定义额外运行的脚本-m 定义采用的脚本格式，目前有两种，amend &amp; edify, 其中amend为较老的格式。-s 定义额外运行的脚本的路径 源码分析入口：main按照python惯例，单独执行的代码执行从main开始： 将用户设定的 Option 存入 OPTIONS 变量中。 解开输入包 设定输出文件，如果要签名（our case）,则还需要一个临时输出文件。 根据参数，调用全量包或差分包创建 ZIP 创建函数。 WriteFullOTAPackage 全量包生成 主要函数 WriteFullOTAPackage 获得脚本生成器，他们的实现见脚本 edify_generator.py 等 获得一些环境变量，来自android 环境变量。 创建连接 MakeRecoveryPatch : 在输出 ZIP包中生成一个patch 在输出 ZIP包中生成一个脚本：recovery/etc/install-recovery.sh , 它最后会位于system/etc/install-recovery.sh 设置 system 目录下文件的权限及属主等。 script.WriteRawImage(“boot”, “boot.img”) 在脚本中增加语句，将 boot.img 写到 boot 分区。 将前面生成的脚本输出到：META-INF/com/google/android/updater-script （对于edify）","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"OTA","slug":"OTA","permalink":"https://austinxishou.github.io/tags/OTA/"}]},{"title":"Android Studio中使用ButterKnife注解框架","date":"2017-04-13T03:38:02.387Z","path":"android/cj1fzsj3r002s0kpxoxf3ks7c/android/AndroidStudio中使用ButterKnife注解框架/","text":"About 比较复杂的布局文件中，会定义众多的view，在activity中使用findViewById逐个初始化，也是挺繁琐的一项工作，喜欢偷懒的程序员，一定会喜欢ButterKnife的，它大大的简化了这一步骤，只需要鼠标点击三下就OK了。下面是android ButterKnife Zelezny的github上的一个动态使用流程图： 使用方法安装ButterKnife插件 File –&gt; Settings –&gt; Plugins –&gt; Browse repositories 插件安装 查找ButterKnife插件，安装 查找ButterKnife插件 重启Android Studio 使用ButterKnife插件 添加jar包 右键Module，Open Module Settings切换到Dependencies，点击右侧的“+”，选择“Library Dependency” 搜索ButterKnife，添加jar包 生成注解 右键layout的ID，点击“Generate” 选择“Generate Butterknife Injections” 生成注解","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"butterknife","slug":"butterknife","permalink":"https://austinxishou.github.io/tags/butterknife/"}]},{"title":"Android工程编译错误集锦","date":"2017-04-13T01:48:54.373Z","path":"android/cj2a7pbix0001swpxmedpxfs7/android/Android工程编译错误集锦/","text":"工程编译类Gradle 错误 Failed to complete Gradle execution.问题描述: 更新Android studio 2.3后,出现Gradle 错误 123Error:Failed to complete Gradle execution.Cause:Could not create parent directory for lock file C:\\Users\\Administrator\\.gradle\\wrapper\\dists\\D:AustinDevtoolsgradlegradle-2.10-all\\dn4qn6r39kukmjs5vguem1ak2\\D:AustinDevtoolsgradlegradle-2.10-all.zip.lck 解决方法 找到工程的build.gradle,修改classpath ‘com.android.tools.build:gradle:2.1.0’为classpath ‘com.android.tools.build:gradle:2.3.0’ AAPT err: libpng error: Not a PNG file 问题描述 Android Studio AAPT err: libpng error: Not a PNG file 问题说明: 问题的根源是,项目的png文件已经通过其他工具提前优化过,但是AAPT工具在编译工程时再次进行优化,但是不能识别该图片之前使用的是什么工具,所以编译出错;解决办法只需要把aapt的图片编译优化关掉即可 解决方法 aaptOptions.cruncherEnabled = false 123456789101112131415161718android &#123; compileSdkVersion 25 buildToolsVersion \"25.0.2\" aaptOptions.cruncherEnabled = false useLibrary 'org.apache.http.legacy' defaultConfig &#123; applicationId \"com.Mankewan.manke\" minSdkVersion 15 targetSdkVersion 25 &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt' &#125; &#125;&#125; Gradle Could not create parent directory for lock file问题描述Error:Could not create parent directory for lock file C:\\Users\\Administrator.gradle\\wrapper\\dists\\D:AustinDevtoolsgradlegradle-3.4.1-all…gradlegradle-3.4.1-all.zip.lck 解决方法 在Android studio 设置中,把gradle设置成 Use local gradle distribution Android 支持库问题描述 Error:Could not find method compile() for arguments [com.android.support:appcompat-v7:19.1.0] on root project ‘Aaaa’. Please install the Android Support Repository from the Android SDK Manager. 问题说明Android的支持库位置声明错误,应该放在模块的gradle文件中,而不是顶层的gradle文件中 You’ve put your dependencies block in the wrong build.gradle file. Instead of the top-level build file, put it in your module’s build file instead. 解决方法在模块的gradle文件中,添加 123dependencies &#123; compile 'com.android.support:appcompat-v7:19.1.0'&#125; Android程序报错程序包org.apache.http不存在问题的解决方法问题描述 Android程序报错程序包org.apache.http不存在问题的解决方法 问题说明 Android 6.0已经不支持HttpClient” 解决方法 Android 6.0（api 23）已经不支持HttpClient了，在build.gradle中 加入 useLibrary ‘org.apache.http.legacy’就可以 123456789101112131415161718android &#123; compileSdkVersion 25 buildToolsVersion \"25.0.2\" aaptOptions.cruncherEnabled = false useLibrary 'org.apache.http.legacy' defaultConfig &#123; applicationId \"com.Mankewan.manke\" minSdkVersion 15 targetSdkVersion 25 &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt' &#125; &#125;&#125; Python 工作环境错误问题描述: 最近在写一个Python程序的时候，使用from selenium import webdriver,在run的时候却出现ImportError: cannot import name webdriver的提示，但是在Python IDLE里面跑却没有错误。很是疑惑，谷歌一下才发现有人已经在stackoverflow里面提出类似问题了，原因如下，在当前目录有个名叫selenium的文件，Python会先导入这个文件，然后再导入标准库里面的selenium.py 解决方法1234##可以使用import selenium print selenium.__file__ ##去看打印出的文件路径，如果不是下面类似的C:\\Python27\\lib\\site-packages\\selenium-2.31.0-py2.7.egg\\selenium\\__init__.pyc，需要把当前目录下的文件删除或者重命名。","tags":[{"name":"android gradle aapt","slug":"android-gradle-aapt","permalink":"https://austinxishou.github.io/tags/android-gradle-aapt/"}]},{"title":"Android OTA升级测试以及问题汇总","date":"2017-04-12T07:13:17.361Z","path":"android/cj1fzsj3b002a0kpxlnd8va6w/android/Android OTA升级测试以及问题汇总/","text":"OTA包本地升级操作步骤","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"OTA","slug":"OTA","permalink":"https://austinxishou.github.io/tags/OTA/"}]},{"title":"Android优化OTA包大小和开机启动时间","date":"2017-04-12T06:21:18.535Z","path":"android/cj1fzsj3r002w0kpx1izsx79u/android/Android优化OTA包大小和开机启动时间/","text":"问题说明在Android 升级到 5.0 (Lollipop/L)之后，虚拟机实例换成了ART，这加快了应用运行时的速度，但是在系统升级中却引入了一些不便之处： 在生成升级包时，因为ART采用了预编译优化功能，会把 APK 及JAR等通过dex2ota预编译成odex文件，这样极大的增加了升级包的大小，动辄上G的大小不方便用户的下载和网络的传播； 如果不进行预编译优化，则这部分操作会转移到刷机完成后第一次开机时间，十几分钟甚至更多的时间，让用户不确认是否升级出问题； 预编译配置-兼顾大小和时间上述问题，Android系统设计者，早已考虑周全，尤其是针对存储空间有限的设备，提供了丰富的编译配置选项，方便开发者根据自己实际情况进行针对性的配置修改； 下面就针对这些配置选项进行说明和标记，方便后续开发人员参考； 打开odex编译优化首先，可以完全关闭预编译优化功能，跟dalvik虚拟机时代的升级包相同：1product BoardConfig.mk 文件中，添加编译变量： WITH_DEXPREOPT := true 当然，这样的结果就是升级包小了，第一次开机时间极其慢； 预编译的包不进行优化预编译的包是指那些在模块编译文件中指定为：include $(BUILD_PREBUILT) 的APK和JAR包等，这在升级包中占了一大部门；DONT_DEXPREOPT_PREBUILTS 变量就可以配置这部门代码是否进行预编译优化；1DONT_DEXPREOPT_PREBUILTS := true 后，编译系统将会阻止 prebuild 包的odex优化； 只进行BOOT.img 优化Android启动过程中，boot.img包含了大部分底层系统的启动和初始化，主要包含在boot.art文件中；使用 WITH_DEXPREOPT_BOOT_IMG_ONLY 编译变量，可以控制编译系统只进行boot.img的优化；使能该变量后，将会大量节省system分区的大小，但同时意味着所有的app都需要在第一次重启的时候进行odex优化； 所以最好是通过 DONT_DEXPREOPT_PREBUILTS 进行更精确的控制； LOCAL_DEX_PREOPT 编译变量使用每个app应用，可以通过该编译变量进行控制是否进行odex优化；在 app’s Android.mk，进行变量赋值 LOCAL_DEX_PREOPT := false PRODUCT_DEXPREOPT 编译变量使用在 post-L 发行版本之后，添加了这个系列的编译变量，进行更深入控制预编译的优化； PRODUCT_DEX_PREOPT_BOOT_FLAGS 传递参数给 dex2oat 命令，控制boot.img的编译 PRODUCT_DEX_PREOPT_DEFAULT_FLAGS 传递默认参数给 dex2oat 命令，控制除了 boot.img的编译，即jar包和apk文件1$(call add-product-dex-preopt-module-config,services,--compiler-filter=space) 或者 直接关闭模块的预编译优化1$(call add-product-dex-preopt-module-config,Calculator,disable) Android 7.0 之后的优化7.0后，系统可以分为A/B两个分区，OTA升级以及APK的优化不影响用户前台的正常使用，这样既减小了升级包的大小，又提升了第一次开机速度； 预加载类文件预加载类会由zygote统一初始化，这样使后续使用到这些类的app开启速度加快；但是预加载类的使用在实际项目中要非常注意，需要仔细评估后确认权衡值，太多的预加载类会导致一些不常用的类消耗宝贵的内存资源，相反则会导致常用的类在不同应用中独立加载，各自有一个备份，既减慢应用开启速度，也是浪费内存； 预加载类的定义列表，默认放置在 frameworks/base/preloaded-classes ，也可以在产品的devic.mk中添加自行定义的预加载列表：1PRODUCT_COPY_FILES += &lt;filename&gt;:system/etc/preloaded-classes 编译类列表结合 PRODUCT_DEX_PREOPT_BOOT_FLAGS 和 compiled-classes 可以控制编译系统是否在预编译优化中编译这些类；不过上述列表只能定义启动类的一个子集，适合用于那些存储空间非常有限，不能全局优化编译整个boot.img 分区的设备，所以对我们来说并不适合；","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"odex","slug":"odex","permalink":"https://austinxishou.github.io/tags/odex/"}]},{"title":"Android-OTA(四)Recovery二次开发","date":"2017-04-12T06:17:58.664Z","path":"android/cj1hl960a0007pgpxevrl423o/android/Android-OTA(四)Recovery二次开发/","text":"main 函数从main入口函数分析recovery的主要源码： 输出重定向 123456 redirect_stdio(TEMPORARY_LOG_FILE); //redirect log to serial output#ifdef LogToSerial freopen(&quot;/dev/ttyFIQ0&quot;, &quot;a&quot;, stdout); setbuf(stdout, NULL); freopen(&quot;/dev/ttyFIQ0&quot;, &quot;a&quot;, stderr); setbuf(stderr, NULL);#endif 这部分代码很容易理解，主要作用是输出log到/tem/recovery.log文件中 执行adb sideload分支 1234if (argc == 2 &amp;&amp; strcmp(argv[1], &quot;--adbd&quot;) == 0) &#123; adb_main(0, DEFAULT_ADB_PORT); return 0;&#125; 判断命令行参数是否为–adbd，并执行adb_main函数，这部分代码在后续adb_install.cpp中分析； 填充fstab结构体 在main函数中调用 load_volume_table()，读取/etc/recovery.emmc.fstab文件内容，并填充fstab结构体，但是并没有执行挂载操作：load_volume_table函数在roots.cpp文件中，也是很容易理解：1234567891011121314151617181920212223void load_volume_table()&#123; ... int emmcState = getEmmcState();//判断是否为emmc设备 if(emmcState) &#123; fstab = fs_mgr_read_fstab(&quot;/etc/recovery.emmc.fstab&quot;); &#125;else &#123; fstab = fs_mgr_read_fstab(&quot;/etc/recovery.fstab&quot;); &#125; ... //读取文件中每个条目内容，填充fstab结构体 ret = fs_mgr_add_entry(fstab, &quot;/tmp&quot;, &quot;ramdisk&quot;, &quot;ramdisk&quot;); ... //日志打印fstable信息 printf(&quot;recovery filesystem table\\n&quot;); printf(&quot;=========================\\n&quot;); for (i = 0; i &lt; fstab-&gt;num_entries; ++i) &#123; Volume* v = &amp;fstab-&gt;recs[i]; printf(&quot; %d %s %s %s %lld\\n&quot;, i, v-&gt;mount_point, v-&gt;fs_type, v-&gt;blk_device, v-&gt;length); &#125; printf(&quot;\\n&quot;);&#125; 读取控制参数recovery 和 bootloader 必须通过内存的一个特定分区，才能进行相互的通信，这个分区一般是/misc；对应的信息数据结构体为bootloader_message；参照源码中bootloader_message 的注释 1234567struct bootloader_message &#123; char command[32];//bootloader 启动时读取改数据，决定是否进入recovery模式 char status[32];//由bootloader进行更新，标识升级的结果； char recovery[768];//由Android系统进行写入，recovery从中读取信息； char stage[32]; char reserved[224];&#125;; recovery 根据命令行参数，再从/misc分区中解析出对应的参数，进行后续的操作，具体的调用函数为get_args(&amp;argc, &amp;argv); 123456789101112131415161718192021222324252627282930313233343536373839404142434445static voidget_args(int *argc, char ***argv) &#123; struct bootloader_message boot;//参数结构体 memset(&amp;boot, 0, sizeof(boot)); get_bootloader_message(&amp;boot); // 具体的读取信息的函数，可能为空的情况 stage = strndup(boot.stage, sizeof(boot.stage)); ... // 如果上述情况为空，则从/cache/recovery/command获取参数，其中COMMAND_FILE=/cache/recovery/command if (*argc &lt;= 1) &#123; FILE *fp = fopen_path(COMMAND_FILE, &quot;r&quot;); if (fp != NULL) &#123; char *token; char *argv0 = (*argv)[0]; *argv = (char **) malloc(sizeof(char *) * MAX_ARGS); (*argv)[0] = argv0; // use the same program name char buf[MAX_ARG_LENGTH]; for (*argc = 1; *argc &lt; MAX_ARGS; ++*argc) &#123; if (!fgets(buf, sizeof(buf), fp)) break; token = strtok(buf, &quot;\\r\\n&quot;); if (token != NULL) &#123; (*argv)[*argc] = strdup(token); // Strip newline. &#125; else &#123; --*argc; &#125; &#125; check_and_fclose(fp, COMMAND_FILE); LOGI(&quot;Got arguments from %s\\n&quot;, COMMAND_FILE); &#125; &#125; //把从/cache/recovery/command获取参数重新写回到/misc分区 // --&gt; write the arguments we have back into the bootloader control block // always boot into recovery after this (until finish_recovery() is called) strlcpy(boot.command, &quot;boot-recovery&quot;, sizeof(boot.command)); strlcpy(boot.recovery, &quot;recovery\\n&quot;, sizeof(boot.recovery)); int i; for (i = 1; i &lt; *argc; ++i) &#123; strlcat(boot.recovery, (*argv)[i], sizeof(boot.recovery)); strlcat(boot.recovery, &quot;\\n&quot;, sizeof(boot.recovery)); &#125; set_bootloader_message(&amp;boot);&#125; 解析命令行参数 123456789101112131415161718192021222324252627282930313233343536373839 while ((arg = getopt_long(argc, argv, &quot;&quot;, OPTIONS, NULL)) != -1) &#123; switch (arg) &#123; case &apos;f&apos;: factory_mode = optarg; bFactoryMode = true; break; case &apos;i&apos;: send_intent = optarg; break; case &apos;u&apos;: update_package = optarg; break; case &apos;w&apos;: should_wipe_data = true; break;case &apos;k&apos;: update_rkimage = optarg;break; case &apos;c&apos;: should_wipe_cache = true; break; case &apos;t&apos;: show_text = true; break; case &apos;s&apos;: sideload = true; break; case &apos;a&apos;: sideload = true; sideload_auto_reboot = true; break; case &apos;x&apos;: just_exit = true; break; case &apos;l&apos;: locale = optarg; break; case &apos;g&apos;: &#123; if (stage == NULL || *stage == &apos;\\0&apos;) &#123; char buffer[20] = &quot;1/&quot;; strncat(buffer, optarg, sizeof(buffer)-3); stage = strdup(buffer); &#125; break; &#125; case &apos;f&apos;+&apos;w&apos;: //fw_update if((optarg)&amp;&amp;(!sdboot_update_package))&#123; sdboot_update_package = strdup(optarg); &#125; break; case &apos;d&apos;: //demo_copy if((optarg)&amp;&amp;(! demo_copy_path))&#123; demo_copy_path = strdup(optarg); &#125; break; case &apos;p&apos;: shutdown_after = true; break; case &apos;r&apos;: reason = optarg; break; case &apos;w&apos;+&apos;a&apos;: &#123; should_wipe_all = should_wipe_data = should_wipe_cache = true;show_text = true;&#125; break; case &apos;?&apos;: LOGE(&quot;Invalid command argument\\n&quot;); continue; &#125; &#125; 这部分代码很简单，就是通过getopt_long进行命令行参数的解析并赋值； 显示界面和功能选项 接下来就是创建device，显示对应UI界面和功能选项； 12345678 Device* device = make_device();//可以自己实现一个设备 ui = device-&gt;GetUI(); gCurrentUI = ui;//赋值ui界面 ui-&gt;SetLocale(locale);//获取归属地信息 ui-&gt;Init();//初始化，可以重载，在init中实现相应功能ui-&gt;SetStage(st_cur, st_max);ui-&gt;SetBackground(RecoveryUI::NONE); 进行分区挂载操作ensure_path_mounted12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182int ensure_path_mounted(const char* path) &#123; ... Volume* v = volume_for_path(path);//根据路径名获取分区信息 ... int result; result = scan_mounted_volumes(); const MountedVolume* mv = find_mounted_volume_by_mount_point(v-&gt;mount_point);//根据挂载点，获取已挂载分区的信息，如果不为空，说明已经成功挂载 if (mv) &#123; // volume is already mounted return 0; &#125; result = mkdir(v-&gt;mount_point, 0755); // 创建对应目录，确保目录存在，也有可能目录已经存在 if (result!=0) &#123; printf(&quot;failed to create %s dir,err=%s!\\n&quot;,v-&gt;mount_point,strerror(errno)); &#125; // 根据文件系统类型，执行mount操作 if (strcmp(v-&gt;fs_type, &quot;yaffs2&quot;) == 0) &#123; // mount an MTD partition as a YAFFS2 filesystem. mtd_scan_partitions(); const MtdPartition* partition; partition = mtd_find_partition_by_name(v-&gt;blk_device); if (partition == NULL) &#123; LOGE(&quot;failed to find \\&quot;%s\\&quot; partition to mount at \\&quot;%s\\&quot;\\n&quot;, v-&gt;blk_device, v-&gt;mount_point); return -1; &#125; return mtd_mount_partition(partition, v-&gt;mount_point, v-&gt;fs_type, 0); &#125; else if (strcmp(v-&gt;fs_type, &quot;ext4&quot;) == 0 || strcmp(v-&gt;fs_type, &quot;ext3&quot;) == 0) &#123; result = mount(v-&gt;blk_device, v-&gt;mount_point, v-&gt;fs_type, MS_NOATIME | MS_NODEV | MS_NODIRATIME, &quot;&quot;); if (result == 0) return 0; LOGE(&quot;failed to mount %s %s (%s)\\n&quot;, v-&gt;mount_point, v-&gt;blk_device, strerror(errno)); return -1; &#125; else if (strcmp(v-&gt;fs_type, &quot;vfat&quot;) == 0) &#123; result = mount(v-&gt;blk_device, v-&gt;mount_point, v-&gt;fs_type, MS_NOATIME | MS_NODEV | MS_NODIRATIME, &quot;shortname=mixed,utf8&quot;); if (result == 0) return 0; LOGW(&quot;trying mount %s to ntfs\\n&quot;, v-&gt;blk_device); result = mount(v-&gt;blk_device, v-&gt;mount_point, &quot;ntfs&quot;, MS_NOATIME | MS_NODEV | MS_NODIRATIME, &quot;&quot;); if (result == 0) return 0; char *sec_dev = v-&gt;fs_options; if(sec_dev != NULL) &#123; char *temp = strchr(sec_dev, &apos;,&apos;); if(temp) &#123; temp[0] = &apos;\\0&apos;; &#125; result = mount(sec_dev, v-&gt;mount_point, v-&gt;fs_type, MS_NOATIME | MS_NODEV | MS_NODIRATIME, &quot;shortname=mixed,utf8&quot;); if (result == 0) return 0; LOGW(&quot;trying mount %s to ntfs\\n&quot;, sec_dev); result = mount(sec_dev, v-&gt;mount_point, &quot;ntfs&quot;, MS_NOATIME | MS_NODEV | MS_NODIRATIME, &quot;&quot;); if (result == 0) return 0; &#125; LOGE(&quot;failed to mount %s (%s)\\n&quot;, v-&gt;mount_point, strerror(errno)); return -1; &#125;else if (strcmp(v-&gt;fs_type, &quot;ntfs&quot;) == 0) &#123; LOGW(&quot;trying mount %s to ntfs\\n&quot;, v-&gt;blk_device); result = mount(v-&gt;blk_device, v-&gt;mount_point, &quot;ntfs&quot;, MS_NOATIME | MS_NODEV | MS_NODIRATIME, &quot;&quot;); if (result == 0) return 0; LOGE(&quot;failed to mount %s (%s)\\n&quot;, v-&gt;mount_point, strerror(errno)); return -1; &#125; LOGE(&quot;unknown fs_type \\&quot;%s\\&quot; for %s\\n&quot;, v-&gt;fs_type, v-&gt;mount_point); return -1;&#125; 界面定制实现Recovery UI在自己的设备目录下：device/vendor/recovery/recovery_ui.cpp 12345678#include &lt;linux/input.h&gt;#include &lt;sys/stat.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &quot;common.h&quot;#include &quot;device.h&quot;#include &quot;screen_ui.h&quot; 实现头部显示和列表项1234567891011121314const char* HEADERS[] = &#123; &quot;Volume up/down to move highlight;&quot;, &quot;power button to select.&quot;, &quot;&quot;, NULL &#125;;const char* ITEMS[] =&#123; &quot;reboot system now&quot;, //&quot;apply update from ADB&quot;, &quot;apply update from external storage&quot;, &quot;update rkimage from external storage&quot;, &quot;apply update from cache&quot;, &quot;wipe data/factory reset&quot;, &quot;wipe cache partition&quot;, &quot;recovery system from backup&quot;, NULL &#125;; 实现ScreenRecoveryUI12345678910111213141516171819202122232425class DeviceUI : public ScreenRecoveryUI &#123; public: DeviceUI () : consecutive_power_keys(0) &#123; &#125; //实现自己的识别key类型的功能，可以为不同的输入设备适配recovery功能 virtual KeyAction CheckKey(int key) &#123; if (IsKeyPressed(KEY_POWER) &amp;&amp; key == KEY_VOLUMEUP) &#123; return TOGGLE; &#125; if (key == KEY_POWER) &#123; ++consecutive_power_keys; if (consecutive_power_keys &gt;= 7) &#123; return REBOOT; &#125; &#125; else &#123; consecutive_power_keys = 0; &#125; return ENQUEUE; &#125; private: int consecutive_power_keys;&#125;; 实现设备类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class MyDevice : public Device &#123; public: RkDevice() : ui(new DeviceUI ) &#123; &#125; RecoveryUI* GetUI() &#123; return ui; &#125; int HandleMenuKey(int key_code, int visible) &#123; if (visible) &#123; switch (key_code) &#123; case KEY_DOWN: case KEY_VOLUMEDOWN: return kHighlightDown; case KEY_UP: case KEY_VOLUMEUP: return kHighlightUp; case KEY_ENTER: case KEY_POWER: return kInvokeItem; &#125; &#125; return kNoAction; &#125; BuiltinAction InvokeMenuItem(int menu_position) &#123; switch (menu_position) &#123; case 0: return REBOOT; //case 1: return APPLY_ADB_SIDELOAD; case 1: return APPLY_EXT; case 2: return APPLY_INT_RKIMG; case 3: return APPLY_CACHE; case 4: return WIPE_DATA; case 5: return WIPE_CACHE; case 6: return RECOVER_SYSTEM; default: return NO_ACTION; &#125; &#125; const char* const* GetMenuHeaders() &#123; return HEADERS; &#125; const char* const* GetMenuItems() &#123; return ITEMS; &#125; private: RecoveryUI* ui;&#125;;//创建自己实现的设备Device* make_device() &#123; return new MyDevice ;&#125; 添加编译实现主要是覆盖TARGET_RECOVERY_UI_LIB，输出到/out/…./recovery/root目录下： Android.mk1234567891011LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE_TAGS := engLOCAL_C_INCLUDES += bootable/recoveryLOCAL_SRC_FILES := recovery_ui.cpp# should match TARGET_RECOVERY_UI_LIB set in BoardConfig.mkLOCAL_MODULE := librecovery_ui_$(TARGET_PRODUCT)include $(BUILD_STATIC_LIBRARY) recovery 二次开发代码结构： bootable/recoveryRecovery主程序代码，其中recovery.cpp是入口，rkimage.cpp处理update.img升级流程，updater/install.c处理ota update.zip包升级流程。 build/tools/releasetools/Ota升级包编译的python脚本，控制完整包与差异包的生成。 build/tools/drmsigntool/如果开启drm，生成ota包时对boot.img进行签名，使用build/target/product/security/private.key，保证进行ota升级后drm功能还能正常使用。 build/tools/mkparameter/编译ota包时打包可升级的parameter的工具。 build/tools/remkloader/编译ota包时打包可升级的loader的工具。 build/target/product/security/编译ota包时签名使用的密钥 device/rockchip/rksdk/recovery/Recovery菜单及按键定制 device/rockchip/rksdk/loader/将需要升级的loader放在该目录下，可以打包到ota升级包中。 device/rockchip/rksdk/parameter/将需要升级的parameter放在该目录下，可以打包到ota升级包中。 out/target/product/rk3188/obj/PACKAGING/target_files_intermediates/Ota升级包编译生成的素材包，要做差异包必须保存该素材包。 板级配置 Recovery 一些宏配置开关在device/rockchip/rk30sdk/BoardConfig.mk BOARD_HAS_FLIPPED_SCREEN := true 针对lcd装反的情况可以强制recovery ui旋转180° TARGET_RECOVERY_UI_LIB ?= librecovery_ui_rk30sdk 自定义recovery菜单与按键实现。 TARGET_USERIMAGES_USE_EXT4 ?= true Recovery支持ext4 文件系统 RECOVERY_UPDATEIMG_RSA_CHECK ?= false Update.img在升级时进行drm签名校验，防止第三方非法固件升级。Update.img必须使用secureboot工具签名，并勾选sign check复选框。 RECOVERY_BOARD_ID ?= false 一种根据烧录Boardid 串号实现一种固件支持不同硬件不同国家定制的one image方案，该方案支持google 的ota 完整升级和差异升级。 脚本文件命令以及解析升级脚本文件解析, try_update_binary主要命令有1234567progress &lt;frac&gt; &lt;secs&gt;set_progress &lt;frac&gt;firmware &lt;\"hboot\"|\"radio\"&gt; &lt;filename&gt;ui_print &lt;string&gt;wipe_cacheclear_displayenable_reboot","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"Recovery","slug":"Recovery","permalink":"https://austinxishou.github.io/tags/Recovery/"}]},{"title":"Android OTA (一) 升级包编译制作","date":"2017-04-12T03:55:40.770Z","path":"android/cj1hl95zv0000pgpxraz1yd5r/android/Android-OTA(一)升级包编译制作/","text":"OTA完整包生成方法 OTA完整包可用于T卡本地升级和OTA在线升级。OTA完整包包含完整的system、recovery.和boot.img。发布一个版本固件正确顺序：123make -j4make otapackage./mkimage.sh ota 即可获得：out/target/product/{product_name}/ {product_name}-ota-eng.{uid}.zip 注意：发布固件必须使用./mkimage.sh ota，将boot与kernel打包，不需要单独烧kernel，如果量产固件是分开的，将会影响后面差异包升级，除非你不需要用差异升级！ 在out/target/product/rk3288/目录下会生成ota完整包rk3288-ota-eng.root.zip，改名成update.zip即可拷贝到T卡或内置flash中进行固件升级。 OTA差异包生成方法 OTA差异包只有差异内容，包大小比较小，主要用于OTA在线升级，也可T卡本地升级。OTA差异包制作需要特殊的编译进行手动制作。 首先发布v1版本的固件，生成v1版本的完整包 保存out/target/product/rk3288/obj/PACKAGING/target_files_intermediates/rk3288-target_files-eng.root.zip 为rk3288-target_files-v1.zip，作为v1版本的基础素材包。 修改kernel代码或者android代码，发布v2版本固件，生成v2版本完整包 保存out/target/product/rk3288/obj/PACKAGING/target_files_intermediates/rk3288-target_files-eng.root.zip 为rk3288-target_files-v2.zip，作为v2版本的基础素材包。 生成v1-v2的差异升级包：./build/tools/releasetools/ota_from_target_files -v -i rk3288-target_files-v1.zip -p out/host/linux-x86 -k build/target/product/security/testkey rk3288-target_files-v2.zip out/target/product/rk3288/rk3288-v1-v2.zip 最后生成的ota差异包 编译过程编译主要分两步， 会准备一个包，其中包含升级需要的内容(原材料)，比如，system 目录。 运行python 脚本 ./build/tools/releasetools/ota_from_target_files，以步骤一准备的ZIP包作为输入，最终生成需要的升级包。 第一步:填充所需要的材料Makefile 依赖otapackage 是一个伪目标12.PHONY: otapackageotapackage: $(INTERNAL_OTA_PACKAGE_TARGET) RECOVERY目录下的组件填充 RECOVERY 子目录的内容。用于生成recovery.img。包括：kernel 的image, recovery 根文件系统的 image, recovery 根文件系统的内容 123456789101112@# Components of the recovery image $(hide) mkdir -p $(zip_root)/RECOVERY //创建中间包中的RECOVERY目录$(hide) $(call package_files-copy-root, \\ $(TARGET_RECOVERY_ROOT_OUT),$(zip_root)/RECOVERY/RAMDISK)//拷贝相关分区文件到 RECOVERY 目录1. $(ACP) $(INSTALLED_KERNEL_TARGET) $(zip_root)/RECOVERY/kernel2. $(ACP) $(INSTALLED_2NDBOOTLOADER_TARGET) $(zip_root)/RECOVERY/second3. echo \"$(BOARD_KERNEL_CMDLINE)\" &gt; $(zip_root)/RECOVERY/cmdline4. echo \"$(BOARD_KERNEL_BASE)\" &gt; $(zip_root)/RECOVERY/base5. echo \"$(BOARD_KERNEL_PAGESIZE)\" &gt; $(zip_root)/RECOVERY/pagesize BOOT 目录下的组件填充 BOOT子目录的内容，用于生成boot.img。和 RECOVERY目录类似，包括：kernel 的image,根文件系统的 image,根文件系统的内容： 1234567891011@# Components of the boot image$(hide) mkdir -p $(zip_root)/BOOT$(hide) $(call package_files-copy-root, \\ $(TARGET_ROOT_OUT),$(zip_root)/BOOT/RAMDISK)1. $(ACP) $(INSTALLED_KERNEL_TARGET) $(zip_root)/BOOT/kernel2. $(ACP) $(INSTALLED_2NDBOOTLOADER_TARGET) $(zip_root)/BOOT/second3. echo \"$(BOARD_KERNEL_CMDLINE)\" &gt; $(zip_root)/BOOT/cmdline4. echo \"$(BOARD_KERNEL_BASE)\" &gt; $(zip_root)/BOOT/base5. echo \"$(BOARD_KERNEL_PAGESIZE)\" &gt; $(zip_root)/BOOT/pagesize6. RADIO 目录下的组件123$(hide) $(foreach t,$(INSTALLED_RADIOIMAGE_TARGET),\\ mkdir -p $(zip_root)/RADIO; \\ $(ACP) $(t) $(zip_root)/RADIO/$(notdir $(t));) BOOTLOADER 组件内容BOOTLOADER 需要提供之前使用的 BOOTLOADER 和 新的 BOOTLOADER 文件 以及 MISC 分区文件之前使用的BOOTLOADER 放置在目录：$(TARGET_DEVICE_DIR)/ota/loader/RKLoader.bin)新的 BOOTLOADER 文件 放置在目录：$(PRODUCT_OUT)/RKLoader_new.binMISC 分区文件 放置在目录：$(TARGET_DEVICE_DIR)/ota/loader/misc_loadercmd.img 12345678ifeq ($(INSTALLED_LOADER_TARGET),) $(info No RK Loader for TARGET_DEVICE $(TARGET_DEVICE) to otapackage) //不需要更新BOOTLOADERelse @# Contents of the rk loader bin $(hide) mkdir -p $(zip_root)/LOADER $(hide) $(HOST_OUT_EXECUTABLES)/remkloader '$(INSTALLED_LOADER_TARGET)' $(INSTALLED_NEW_LOADER_TARGET) $(hide) cat $(INSTALLED_LOADER_MISC_TARGET) $(INSTALLED_NEW_LOADER_TARGET) &gt; $(zip_root)/LOADER/RKLoader.img endif Parameter 组件内容parameter 需要放置在 $(TARGET_DEVICE_DIR)/ota/parameter/parameter*) 目录中1234567ifeq ($(INSTALLED_PARAMETER_TARGET),) $(info No parameter for TARGET_DEVICE $(TARGET_DEVICE) to otapackage) //不需要更新Parameterelse $(hide) rm -rf $(zip_root)/PARAMETER $(hide) mkdir -p $(zip_root)/PARAMETER $(hide) $(HOST_OUT_EXECUTABLES)/mkparameter '$(INSTALLED_PARAMETER_TARGET)' $(zip_root)/PARAMETER/parameterendif 常规的system 以及 data 分区内容填充 SYSTEM子目录的内容。 这是升级的主要内容。生成 META/filesystem_config.txt 并将其加入到 zip 包中。该文件保存了 system 目录下各目录、文件的权限及 owner 123456@# Contents of the system image$(hide) $(call package_files-copy-root, \\ $(SYSTEMIMAGE_SOURCE_DIR),$(zip_root)/SYSTEM)@# Contents of the data image$(hide) $(call package_files-copy-root, \\ $(TARGET_OUT_DATA),$(zip_root)/DATA) 供应商定制相关内容12345ifdef BOARD_VENDORIMAGE_FILE_SYSTEM_TYPE @# Contents of the vendor image $(hide) $(call package_files-copy-root, \\ $(TARGET_OUT_VENDOR),$(zip_root)/VENDOR)endif 第二步:ota_from_target_files 命令执行核心是一个python脚本: ota_from_target_files, 它以前一步骤生成的ZIP包作为输入，生成可用于OTA升级的zip包。生成的完整升级包会存放在out\\target\\product[project-name]\\目录下 12345678910INTERNAL_OTA_PACKAGE_TARGET :# $(PRODUCT_OUT)/$(name).zip$(INTERNAL_OTA_PACKAGE_TARGET): KEY_CERT_PAIR :# $(DEFAULT_KEY_CERT_PAIR) 签名$(INTERNAL_OTA_PACKAGE_TARGET): $(BUILT_TARGET_FILES_PACKAGE) $(DISTTOOLS) @echo \"Package OTA: $@\" $(hide) PATH#$(foreach p,$(INTERNAL_USERIMAGES_BINARY_PATHS),$(p):)$$PATH MKBOOTIMG#$(MKBOOTIMG) \\ ./build/tools/releasetools/ota_from_target_files -v \\ -p $(HOST_OUT) \\ -k $(KEY_CERT_PAIR) \\ $(if $(OEM_OTA_CONFIG), -o $(OEM_OTA_CONFIG)) \\ $(BUILT_TARGET_FILES_PACKAGE) $@ 生成中间包生成的中间包存放在out/target/product/[project-name]/obj/PACKAGING/target_files_intermediates/目录下,该文件可用于创建差分升级包以及全量包源码中的英文注释为：12A zip of the directories that map to the target filesystem.This zip can be used to create an OTA package or filesystem image as a post-build step. 中间包宏变量为： BUILT_TARGET_FILES_PACKAGE部分代码为：12345678910111213141516171819202122232425262728293031intermediates :# $(call intermediates-dir-for,PACKAGING,target_files) //定义目录BUILT_TARGET_FILES_PACKAGE :# $(intermediates)/$(name).zip //宏变量赋值$(BUILT_TARGET_FILES_PACKAGE): intermediates :# $(intermediates) //定义依赖$(BUILT_TARGET_FILES_PACKAGE): \\ zip_root :# $(intermediates)/$(name) //定义依赖... //省略一部分依赖说明 # Depending on the various images guarantees that the underlying# directories are up-to-date.$(BUILT_TARGET_FILES_PACKAGE): \\ $(INSTALLED_BOOTIMAGE_TARGET) \\ $(INSTALLED_RADIOIMAGE_TARGET) \\ $(INSTALLED_LOADER_TARGET) \\ $(INSTALLED_PARAMETER_TARGET) \\ $(INSTALLED_RECOVERYIMAGE_TARGET) \\ $(INSTALLED_SYSTEMIMAGE) \\ $(INSTALLED_USERDATAIMAGE_TARGET) \\ $(INSTALLED_CACHEIMAGE_TARGET) \\ $(INSTALLED_VENDORIMAGE_TARGET) \\ $(INSTALLED_ANDROID_INFO_TXT_TARGET) \\ $(SELINUX_FC) \\ $(built_ota_tools) \\ $(APKCERTS_FILE) \\ $(HOST_OUT_EXECUTABLES)/fs_config \\ | $(ACP)上述依赖主要定义各个分区系统的文件//之后执行命令 @echo \"Package target files: $@\" //打印日志 $(hide) rm -rf $@ $(zip_root) //删除原有文件目录 $(hide) mkdir -p $(dir $@) $(zip_root) //重新创建目录","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"OTA","slug":"OTA","permalink":"https://austinxishou.github.io/tags/OTA/"}]},{"title":"RK3288平台img包解压修改","date":"2017-04-12T03:26:38.078Z","path":"android/cj1fzsj46003b0kpxy0t31dsx/android/RK3288平台img包解压修改/","text":"解压update.img12./rkImageMaker -unpack update.img output ./afptool -unpack output/firmware.img output 解压 system.img123456789mount -o loop Image/system.img /mnt/systemumount /mnt/system//增加 128M 的空间dd if=/dev/zero bs=1M count=128 &gt;&gt; Image/system.img//扩展文件系统信息e2fsck -f Image/system.imgresize2fs Image/system.img 解压boot.img1234./rkunpack boot.img mkdir boot-extractedcd boot-extractedcat ../boot.img-raw | gunzip | cpio -i 解压resource.img12345resource_tool --unpack --image=resource.img Myresource//dtb 反编译成dts./dtc -I dtb -O dts rk-kernel.dtb &gt; my-rk-kernel.dts//单独编译dts./dtc -I dtS -O dtB &gt; rk-kernel.dts 打包 boot.img12find . | cpio -o -H newc | gzip &gt; ../opinions-on-teclast-p90hdst-boot.imgrkcrc -k test-boot.img newboot.img imgRePackerRK_105 工具imgRePackerRK_105百度云下载","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"app","slug":"app","permalink":"https://austinxishou.github.io/tags/app/"}]},{"title":"Android自启动管理功能","date":"2017-03-31T06:37:05.178Z","path":"android/cj1fzsj46003e0kpxof6t7b5z/android/Android自启动管理功能/","text":"About基本功能: 获取设备上所有应用的开机启动完成的广播接收者,同时区分系统应用和用户应用.然后,提供界面接口给用户,统一管理应用的自启动功能,这样可以提升系统的运行性能和待机时长; 获取所有receivers 区分是否使能获取包含被禁止自启动receiver的信息1List&lt;ResolveInfo&gt; forbidInfoList = mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_DISABLED_COMPONENTS); 获取所有使能的 receivers1List&lt;ResolveInfo&gt; allowInfoList = mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_RECEIVERS); 两个列表比较,标志receivers是否开启12345for(int k=0; k&lt;allowInfoList.size(); k++)&#123; if( allowInfoList.get(k).activityInfo.packageName.equals(packageName) )&#123; isEnable =true; &#125;&#125; 判断是否为系统应用通过ApplicationInfo.FLAG_SYSTEM标志,判断是否为系统应用1234if((forbidInfoList.get(i).activityInfo.applicationInfo.flags&amp;ApplicationInfo.FLAG_SYSTEM)==1|| (forbidInfoList.get(i).activityInfo.applicationInfo.flags&amp;ApplicationInfo.FLAG_UPDATED_SYSTEM_APP)==1)&#123; isSystem = true;&#125; 判断是否运行并获取内存占用大小123456789101112131415161718192021222324252627float memUsed = 0;ArrayList&lt;Integer&gt; pid = new ArrayList&lt;Integer&gt;(runningApps.size());//循环处理正在运行进程for(int k=0; k&lt;runningApps.size(); k++)&#123; if(runningApps.get(k).processName.equals(packageName))&#123; // Log.e(\"ycltest\",\"in runningApps list find the right process,handle it\"); pid.add( Integer.valueOf(runningApps.get(k).pid) ); &#125;else&#123; continue; &#125;&#125;if( pid.size() == 0)&#123; isRun = false;&#125;else&#123; //获取内存大小 isRun = true; int[] pids = new int[pid.size()]; for (int num=0; num&lt;pid.size(); num++) &#123; pids[num] = pid.get(num).intValue(); &#125; Debug.MemoryInfo[] mi = mActivityManager.getProcessMemoryInfo(pids); for (int num=0; num&lt;mi.length; num++) &#123; memUsed += (float)(mi[num].getTotalPrivateDirty()+mi[num].getTotalPss())/1024; &#125;&#125; 关闭和开启Receiver通过PackageManager.setComponentEnabledSetting方法,关闭和开启Receiver 1234567891011121314private void updatePackageReceiverState( PackageEntry item, boolean isChecked)&#123; String packageReceiverList[] = item.getPackageReceivers().split(\";\"); int newState = isChecked ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED : PackageManager.COMPONENT_ENABLED_STATE_DISABLED; for (int i=0; i&lt;packageReceiverList.length; i++) &#123; if( packageReceiverList[i] != null )&#123; ComponentName comName = new ComponentName(item.getPackageName(), packageReceiverList[i]); int flag = 0; if( item.getPackageName().equals(\"com.android.settings\") )&#123; flag = PackageManager.DONT_KILL_APP; &#125; mPackageManager.setComponentEnabledSetting(comName,newState, flag); &#125; &#125;&#125; 其他功能其他功能包括,列表排序,列表更新,无应用列表图片显示等,不在这里详细展开!","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"app","slug":"app","permalink":"https://austinxishou.github.io/tags/app/"}]},{"title":"Android发送广播详解","date":"2017-03-31T06:22:32.229Z","path":"android/cj1fzsj3r00300kpxc8jexeii/android/Android发送广播详解/","text":"调用ContextImpl进行发送同样，不管是Activity、Service上发送广播，最终实现都在ContextImpl，最后发送到ActivityManagerService处理 12345678910111213@Override public void sendBroadcast(Intent intent) &#123; warnIfCallingFromSystemProcess(); String resolvedType = intent.resolveTypeIfNeeded(getContentResolver()); try &#123; intent.prepareToLeaveProcess(); ActivityManagerNative.getDefault().broadcastIntent( mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, false, false, getUserId()); &#125; catch (RemoteException e) &#123; &#125; &#125; ActivityManagerProxy发送到AMS由ActivityManagerProxy发送到AMS 123456789101112131415161718192021222324252627282930//resultTo：null，resultCode：-resultData：null，map：null，requiredPermission：null//appOp：-1，serialized：false，sticky：falsepublic int broadcastIntent(IApplicationThread caller, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle map, String requiredPermission, int appOp, boolean serialized, boolean sticky, int userId) throws RemoteException&#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(caller != null ? caller.asBinder() : null); intent.writeToParcel(data, 0); data.writeString(resolvedType); data.writeStrongBinder(resultTo != null ? resultTo.asBinder() : null); data.writeInt(resultCode); data.writeString(resultData); data.writeBundle(map); data.writeString(requiredPermission); data.writeInt(appOp); data.writeInt(serialized ? 1 : 0); data.writeInt(sticky ? 1 : 0); data.writeInt(userId); mRemote.transact(BROADCAST_INTENT_TRANSACTION, data, reply, 0); reply.readException(); int res = reply.readInt(); reply.recycle(); data.recycle(); return res;&#125; AMS处理BROADCAST_INTENT_TRANSACTIONAMS处理BROADCAST_INTENT_TRANSACTION1234567891011121314151617181920212223242526//resultTo：null，resultCode：-resultData：null，map：null，requiredPermission：null//appOp：-1，serialized：false，sticky：falsecase BROADCAST_INTENT_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); IBinder b = data.readStrongBinder(); IApplicationThread app =b != null ? ApplicationThreadNative.asInterface(b) : null;//依然是Binder本地对象 Intent intent = Intent.CREATOR.createFromParcel(data); String resolvedType = data.readString(); b = data.readStrongBinder();//null IIntentReceiver resultTo =b != null ? IIntentReceiver.Stub.asInterface(b) : null;//null int resultCode = data.readInt();//-1 String resultData = data.readString();//null Bundle resultExtras = data.readBundle();//null String perm = data.readString();//null int appOp = data.readInt();//-1 boolean serialized = data.readInt() != 0;//0 boolean sticky = data.readInt() != 0;//0 int userId = data.readInt(); int res = broadcastIntent(app, intent, resolvedType, resultTo, resultCode, resultData, resultExtras, perm, appOp, serialized, sticky, userId); reply.writeNoException(); reply.writeInt(res); return true; &#125; 首先检验Intent的有效性，是否带文件描述符，如果进程未启动完成，带FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT，表示可以在进程未启动完之前接收广播，没有该标识则抛异常，接着调用方法broadcastIntentLocked处理1234567891011121314151617181920212223//resultTo：null，resultCode：-resultData：null，map：null，requiredPermission：null//appOp：-1，serialized：false，sticky：falsepublic final int broadcastIntent(IApplicationThread caller, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle map, String requiredPermission, int appOp, boolean serialized, boolean sticky, int userId) &#123; enforceNotIsolatedCaller(\"broadcastIntent\"); synchronized(this) &#123; //intent有效性检查，不能带文件描述符 intent = verifyBroadcastLocked(intent); final ProcessRecord callerApp = getRecordForAppLocked(caller); final int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); int res = broadcastIntentLocked(callerApp, callerApp != null ? callerApp.info.packageName : null, intent, resolvedType, resultTo, resultCode, resultData, map, requiredPermission, appOp, serialized, sticky, callingPid, callingUid, userId); Binder.restoreCallingIdentity(origId); return res; &#125;&#125; broadcastIntentLocked获取目标Receivers首先处理一些特殊的广播，如：接收到PackageManager发来的应用包移除广播，就会把所有属于该包下的ActivityRecord出栈等，AMS内有两种广播队列，分别是前台广播队列mFgBroadcastQueue保存带FLAG_RECEIVER_FOREGROUND的广播，和后台广播队列mBgBroadcastQueue，先会尝试向并行receivers递送广播，此时会调用到queue.scheduleBroadcastsLocked()，简单地说就是，新建一个BroadcastRecord节点，并插入对应的BroadcastQueue，最后发起实际的广播调度（scheduleBroadcastsLocked()），不光并行处理部分需要一个BroadcastRecord节点，串行处理部分也需要BroadcastRecord节点。也就是说，要激发一次广播，AMS必须构造一个或两个BroadcastRecord节点，并将之插入合适的广播队列。插入成功后，再执行队列的scheduleBroadcastsLocked()动作BroadcastRecord节点内部的receivers列表，记录着和这个广播动作相关的目标receiver信息，该列表内部的子节点可能是ResolveInfo类型的，也可能是BroadcastFilter类型的。ResolveInfo是从PKMS处查到的静态receiver的描述信息，它的源头是PKMS解析的那些AndroidManifest.xml文件。而BroadcastFilter来自于动态注册receiver时，保存在AMS成员变量mReceiverResolver123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332//resultTo：null，resultCode：-resultData：null，map：null，requiredPermission：null//appOp：-1，serialized：false，sticky：falseprivate final int broadcastIntentLocked(ProcessRecord callerApp, String callerPackage, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle map, String requiredPermission, int appOp, boolean ordered, boolean sticky, int callingPid, int callingUid, int userId) &#123; intent = new Intent(intent); // By default broadcasts do not go to stopped apps. //在Android3.1之后，PKMS加强了对“处于停止状态的”应用的管理。如果一个应用在安装后从来没有启动过，或者已经被用户强制停止了，那么这个应用就处于停止状态（stoppedstate）。为了达到精细调整的目的，Android增加了2个flag：FLAG_INCLUDE_STOPPED_PACKAGES和FLAG_EXCLUDE_STOPPED_PACKAGES，以此来表示intent是否要激活“处于停止状态的”应用。而默认则是不激活 intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES); //.... userId = handleIncomingUser(callingPid, callingUid, userId,true, false, \"broadcast\", callerPackage);//权限检测 // Make sure that the user who is receiving this broadcast is started. // If not, we will just skip it. if (userId != UserHandle.USER_ALL &amp;&amp; mStartedUsers.get(userId) == null) &#123; if (callingUid != Process.SYSTEM_UID || (intent.getFlags() &amp; Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) &#123; Slog.w(TAG, \"Skipping broadcast of \" + intent+ \": user \" + userId + \" is stopped\"); return ActivityManager.BROADCAST_SUCCESS; &#125; &#125; /* * Prevent non-system code (defined here to be non-persistent processes) from sending protected broadcasts. */ int callingAppId = UserHandle.getAppId(callingUid); if (callingAppId == Process.SYSTEM_UID || callingAppId == Process.PHONE_UID || callingAppId == Process.SHELL_UID || callingAppId == Process.BLUETOOTH_UID || callingUid == 0) &#123; // Always okay. &#125; else if (callerApp == null || !callerApp.persistent) &#123; //... &#125; // Handle special intents: if this broadcast is from the package // manager about a package being removed, we need to remove all of // its activities from the history stack. final boolean uidRemoved = Intent.ACTION_UID_REMOVED.equals(intent.getAction()); if (Intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction()) || uidRemoved) &#123; if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid, callingUid, -1, true) == PackageManager.PERMISSION_GRANTED) &#123; if (uidRemoved) &#123; final Bundle intentExtras = intent.getExtras(); final int uid = intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1; if (uid &gt;= 0) &#123; BatteryStatsImpl bs = mBatteryStatsService.getActiveStatistics(); synchronized (bs) &#123; bs.removeUidStatsLocked(uid); &#125; mAppOpsService.uidRemoved(uid); &#125; &#125; else &#123; // If resources are unavailable just force stop all // those packages and flush the attribute cache as well. if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())) &#123; String list[] = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST); if (list != null &amp;&amp; (list.length &gt; 0)) &#123; for (String pkg : list) &#123; forceStopPackageLocked(pkg, -1, false, true, true, false, userId, \"storage unmount\"); &#125; sendPackageBroadcastLocked( IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE, list, userId); &#125; &#125; else &#123; Uri data = intent.getData(); String ssp; if (data != null &amp;&amp; (ssp=data.getSchemeSpecificPart()) != null) &#123; boolean removed = Intent.ACTION_PACKAGE_REMOVED.equals( intent.getAction()); if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP, false)) &#123; forceStopPackageLocked(ssp, UserHandle.getAppId( intent.getIntExtra(Intent.EXTRA_UID, -1)), false, true, true, false, userId, removed ? \"pkg removed\" : \"pkg changed\"); &#125; if (removed) &#123; sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REMOVED, new String[] &#123;ssp&#125;, userId); if (!intent.getBooleanExtra(Intent.EXTRA_REPLACING, false)) &#123; mAppOpsService.packageRemoved( intent.getIntExtra(Intent.EXTRA_UID, -1), ssp); // Remove all permissions granted from/to this package removeUriPermissionsForPackageLocked(ssp, userId, true); &#125; &#125; &#125; &#125; &#125; &#125; else &#123; //\"Permission Denial: \" throw new SecurityException(msg); &#125; // Special case for adding a package: by default turn on compatibility mode. &#125; else if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())) &#123; Uri data = intent.getData(); String ssp; if (data != null &amp;&amp; (ssp=data.getSchemeSpecificPart()) != null) &#123; mCompatModePackages.handlePackageAddedLocked(ssp, intent.getBooleanExtra(Intent.EXTRA_REPLACING, false)); &#125; &#125; /* * If this is the time zone changed action, queue up a message that will reset the timezone * of all currently running processes. This message will get queued up before the broadcast * happens. */ if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) &#123; mHandler.sendEmptyMessage(UPDATE_TIME_ZONE); &#125; if (intent.ACTION_CLEAR_DNS_CACHE.equals(intent.getAction())) &#123; mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG); &#125; if (Proxy.PROXY_CHANGE_ACTION.equals(intent.getAction())) &#123; ProxyProperties proxy = intent.getParcelableExtra(\"proxy\"); mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG, proxy)); &#125; // Add to the sticky list if requested. if (sticky) &#123;//false，先忽略 if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid, callingUid) != PackageManager.PERMISSION_GRANTED) &#123; //... throw new SecurityException(msg); &#125; if (requiredPermission != null) &#123; Slog.w(TAG, \"Can't broadcast sticky intent \" + intent+ \" and enforce permission \" + requiredPermission); return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION; &#125; if (intent.getComponent() != null) &#123; throw new SecurityException(\"Sticky broadcasts can't target a specific component\"); &#125; // We use userId directly here, since the \"all\" target is maintained // as a separate set of sticky broadcasts. if (userId != UserHandle.USER_ALL) &#123; // But first, if this is not a broadcast to all users, then // make sure it doesn't conflict with an existing broadcast to // all users. ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get( UserHandle.USER_ALL); if (stickies != null) &#123; ArrayList&lt;Intent&gt; list = stickies.get(intent.getAction()); if (list != null) &#123; int N = list.size(); int i; for (i=0; i&lt;N; i++) &#123; if (intent.filterEquals(list.get(i))) &#123; throw new IllegalArgumentException( \"Sticky broadcast \" + intent + \" for user \" + userId + \" conflicts with existing global broadcast\"); &#125; &#125; &#125; &#125; &#125; ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(userId); if (stickies == null) &#123; stickies = new ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt;(); mStickyBroadcasts.put(userId, stickies); &#125; ArrayList&lt;Intent&gt; list = stickies.get(intent.getAction()); if (list == null) &#123; list = new ArrayList&lt;Intent&gt;(); stickies.put(intent.getAction(), list); &#125; int N = list.size(); int i; for (i=0; i&lt;N; i++) &#123; if (intent.filterEquals(list.get(i))) &#123; // This sticky already exists, replace it. list.set(i, new Intent(intent)); break; &#125; &#125; if (i &gt;= N) &#123; list.add(new Intent(intent)); &#125; &#125; int[] users; if (userId == UserHandle.USER_ALL) &#123; // Caller wants broadcast to go to all started users. users = mStartedUserArray; &#125; else &#123; // Caller wants broadcast to go to one specific user. users = new int[] &#123;userId&#125;; &#125; // Figure out who all will receive this broadcast. List receivers = null; List&lt;BroadcastFilter&gt; registeredReceivers = null; // Need to resolve the intent to interested receivers... //FLAG_RECEIVER_REGISTERED_ONLY标识标识的是动态注册的广播，至于静态注册的广播是通过PackageManager获得 if ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY)== 0) &#123; receivers = collectReceiverComponents(intent, resolvedType, users); &#125; if (intent.getComponent() == null) &#123; //找到符合的接受者（详细之后再看），返回结果按照优先级排序 registeredReceivers = mReceiverResolver.queryIntent(intent,resolvedType, false, userId); &#125; //是否替代 final boolean replacePending =(intent.getFlags()&amp;Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0; int NR = registeredReceivers != null ? registeredReceivers.size() : 0; if (!ordered &amp;&amp; NR &gt; 0) &#123; // If we are not serializing this broadcast, then send the // registered receivers separately so they don't wait for the // components to be launched. final BroadcastQueue queue = broadcastQueueForIntent(intent); BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, resolvedType, requiredPermission, appOp, registeredReceivers, resultTo, resultCode, resultData, map, ordered, sticky, false, userId); final boolean replaced = replacePending &amp;&amp; queue.replaceParallelBroadcastLocked(r); if (!replaced) &#123; queue.enqueueParallelBroadcastLocked(r); queue.scheduleBroadcastsLocked();// &#125; //上面完成了无序广播的调度 registeredReceivers = null; NR = 0; &#125; //看来是先处理动态注册的，之后才是静态注册的 // Merge into one list. int ir = 0; //receiver记录的是在清单文件夹静态注册的广播 if (receivers != null) &#123; // A special case for PACKAGE_ADDED: do not allow the package // being added to see this broadcast. This prevents them from // using this as a back door to get run as soon as they are // installed. Maybe in the future we want to have a special install // broadcast or such for apps, but we'd like to deliberately make // this decision. //防止监听自己的应用安装后自己收到广播而自动启动 String skipPackages[] = null; if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) &#123; Uri data = intent.getData(); if (data != null) &#123; String pkgName = data.getSchemeSpecificPart(); if (pkgName != null) &#123; skipPackages = new String[] &#123; pkgName &#125;; &#125; &#125; &#125; else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) &#123; skipPackages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST); &#125; //移除特定的广播任务 if (skipPackages != null &amp;&amp; (skipPackages.length &gt; 0)) &#123; for (String skipPackage : skipPackages) &#123; if (skipPackage != null) &#123; int NT = receivers.size(); for (int it=0; it&lt;NT; it++) &#123; ResolveInfo curt = (ResolveInfo)receivers.get(it); if (curt.activityInfo.packageName.equals(skipPackage)) &#123; receivers.remove(it); it--; NT--; &#125; &#125; &#125; &#125; &#125; //如果是无序广播，在上面NR已置为了0，下面是用于合并有序和静态注册的广播 int NT = receivers != null ? receivers.size() : 0;//静态注册的广播数量 int it = 0; ResolveInfo curt = null; BroadcastFilter curr = null; while (it &lt; NT &amp;&amp; ir &lt; NR) &#123; if (curt == null) &#123; curt = (ResolveInfo)receivers.get(it); &#125; if (curr == null) &#123; curr = registeredReceivers.get(ir); &#125; if (curr.getPriority() &gt;= curt.priority) &#123; // Insert this broadcast record into the final list. receivers.add(it, curr); ir++; curr = null; it++; NT++; &#125; else &#123; // Skip to the next ResolveInfo in the final list. it++; curt = null; &#125; &#125; &#125; while (ir &lt; NR) &#123; if (receivers == null) &#123; receivers = new ArrayList(); &#125; receivers.add(registeredReceivers.get(ir)); ir++; &#125; //下面的操作和处理无序广播一样 if ((receivers != null &amp;&amp; receivers.size() &gt; 0)|| resultTo != null) &#123; BroadcastQueue queue = broadcastQueueForIntent(intent); //resultTo：null，resultCode：-resultData：null，map：null，requiredPermission：null //appOp：-1，serialized：false，sticky：false BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, resolvedType, requiredPermission, appOp, receivers, resultTo, resultCode, resultData, map, ordered, sticky, false, userId); &#125; boolean replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r); if (!replaced) &#123; queue.enqueueOrderedBroadcastLocked(r); queue.scheduleBroadcastsLocked(); &#125; &#125; return ActivityManager.BROADCAST_SUCCESS;&#125; scheduleBroadcastsLocked调度执行以上不管是处理有序广播还是无序广播，最重要的无疑是scheduleBroadcastsLocked方法调用123456789BroadcastQueue.javapublic void scheduleBroadcastsLocked() &#123; if (mBroadcastsScheduled) &#123; return; &#125; mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this)); mBroadcastsScheduled = true; &#125; 处理BROADCAST_TIMEOUT_MSG消息 12345BroadcastQueue.javacase BROADCAST_INTENT_MSG: &#123; processNextBroadcast(true);&#125; break; 处理广播所有的静态receiver都是串行处理的，而动态receiver则会按照发广播时指定的方式，进行“并行”或“串行”处理。能够并行处理的广播，其对应的若干receiver一定都已经存在了，不会牵扯到启动新进程的操作，所以可以在一个while循环中，一次性全部deliver。而有序广播，则需要一个一个地处理，其滚动处理的手段是发送事件，也就是说，在一个receiver处理完毕后，会利用广播队列（BroadcastQueue）的mHandler，发送一个BROADCAST_INTENT_MSG事件，从而执行下一次的processNextBroadcast的调度 处理无序广播遍历并行列表（mParallelBroadcasts）的每一个BroadcastRecord以及其中的receivers列表。对于无序广播而言，receivers列表中的每个子节点是个BroadcastFilter。我们直接通过方法deliverToRegisteredReceiverLocked将广播递送出去即可 1234567891011121314151617181920212223242526272829final void processNextBroadcast(boolean fromMsg) &#123; synchronized(mService) &#123; BroadcastRecord r; mService.updateCpuStats(); if (fromMsg) &#123; //表示BROADCAST_INTENT_MSG消息已经处理完了 mBroadcastsScheduled = false; &#125; // First, deliver any non-serialized broadcasts right away. while (mParallelBroadcasts.size() &gt; 0) &#123; //BroadcastRecord类型的r内部记录了该广播的所有接收者 r = mParallelBroadcasts.remove(0); r.dispatchTime = SystemClock.uptimeMillis(); r.dispatchClockTime = System.currentTimeMillis(); final int N = r.receivers.size();//接收者数量 for (int i=0; i&lt;N; i++) &#123; Object target = r.receivers.get(i); //把非有序队列中各个广播发送给广播接收者 deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false); &#125; addBroadcastToHistoryLocked(r); &#125; //....... &#125; &#125; BroadcastQueue#deliverToRegisteredReceiverLocked先进行的权限判断、操作的检测、目标进程是否启动等操作，如果都OK，前面可知BroadcastFilter用来关联了动态注册的IIntentReceiver和IntentFilter,所以拿到一个BroadcastFilter接可以知道宿主IIntentReceiver，最后调用performReceiveLocked123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//order=false；private final void deliverToRegisteredReceiverLocked(BroadcastRecord r,BroadcastFilter filter, boolean ordered) &#123; boolean skip = false; if (filter.requiredPermission != null) &#123; int perm = mService.checkComponentPermission(filter.requiredPermission,r.callingPid, r.callingUid, -1, true); if (perm != PackageManager.PERMISSION_GRANTED) &#123; //Permission Denial: broadcasting skip = true; &#125; &#125; if (!skip &amp;&amp; r.requiredPermission != null) &#123; int perm = mService.checkComponentPermission(r.requiredPermission, filter.receiverList.pid, filter.receiverList.uid, -1, true); if (perm != PackageManager.PERMISSION_GRANTED) &#123; //Permission Denial: receiving skip = true; &#125; &#125; if (r.appOp != AppOpsManager.OP_NONE) &#123; int mode = mService.mAppOpsService.noteOperation(r.appOp, filter.receiverList.uid, filter.packageName); if (mode != AppOpsManager.MODE_ALLOWED) &#123; if (DEBUG_BROADCAST) Slog.v(TAG, \"App op \" + r.appOp + \" not allowed for broadcast to uid \" + filter.receiverList.uid + \" pkg \" + filter.packageName); skip = true; &#125; &#125; if (!skip) &#123; skip = !mService.mIntentFirewall.checkBroadcast(r.intent, r.callingUid, r.callingPid, r.resolvedType, filter.receiverList.uid); &#125; if (filter.receiverList.app == null || filter.receiverList.app.crashing) &#123; Slog.w(TAG, \"Skipping deliver [\" + mQueueName + \"] \" + r+ \" to \" + filter.receiverList + \": process crashing\"); skip = true; &#125; if (!skip) &#123; // If this is not being sent as an ordered broadcast, then we // don't want to touch the fields that keep track of the current // state of ordered broadcasts. if (ordered) &#123;//false r.receiver = filter.receiverList.receiver.asBinder();//记录的是IIntentReceiver的Binder本地对象 r.curFilter = filter; filter.receiverList.curBroadcast = r; r.state = BroadcastRecord.CALL_IN_RECEIVE; if (filter.receiverList.app != null) &#123; // Bump hosting application to no longer be in background scheduling class. Note that we can't do that if there // isn't an app... but we can only be in that case for things that directly call the IActivityManager API, which // are already core system stuff so don't matter for this. r.curApp = filter.receiverList.app; filter.receiverList.app.curReceiver = r; mService.updateOomAdjLocked(r.curApp, true); &#125; &#125; try &#123; //filter.receiverList.app:ApplicationThread //filter.receiverList.receiver： performReceiveLocked(filter.receiverList.app, filter.receiverList.receiver, new Intent(r.intent), r.resultCode, r.resultData, r.resultExtras, r.ordered, r.initialSticky, r.userId); if (ordered) &#123; r.state = BroadcastRecord.CALL_DONE_RECEIVE; &#125; &#125; catch (RemoteException e) &#123; Slog.w(TAG, \"Failure sending broadcast \" + r.intent, e); if (ordered) &#123; r.receiver = null; r.curFilter = null; filter.receiverList.curBroadcast = null; if (filter.receiverList.app != null) &#123; filter.receiverList.app.curReceiver = null; &#125; &#125; &#125; &#125;&#125; 6.3 BroadcastQueue#performReceiveLocked接着如果当前进程是存在的且已经启动，通过ApplicationThread来进行回调但实际上还是通过IIntentReceiver来回调，123456789101112131415BroadcastQueue.javaprivate static void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver, Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123; // Send the intent to the receiver asynchronously using one-way binder calls. if (app != null &amp;&amp; app.thread != null) &#123; // If we have an app thread, do the call through that so it is correctly ordered with other one-way calls. app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode, data, extras, ordered, sticky, sendingUser, app.repProcState); &#125; else &#123; receiver.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser); &#125;&#125; 6.4 IIntentReceiver#performReceive1234567891011121314151617181920212223242526LoadedApk#ReceiverDispatcher#IIntentReceiverpublic void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123; //获取宿主ReceiverDispatcher LoadedApk.ReceiverDispatcher rd = mDispatcher.get(); if (rd != null) &#123; rd.performReceive(intent, resultCode, data, extras,ordered, sticky, sendingUser); &#125; else &#123; // The activity manager dispatched a broadcast to a registered // receiver in this process, but before it could be delivered the // receiver was unregistered. Acknowledge the broadcast on its // behalf so that the system's broadcast sequence can continue. if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,\"Finishing broadcast to unregistered receiver\"); IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; if (extras != null) &#123; extras.setAllowFds(false); &#125; mgr.finishReceiver(this, resultCode, data, extras, false); &#125; catch (RemoteException e) &#123; Slog.w(ActivityThread.TAG, \"Couldn't finish broadcast to unregistered receiver\"); &#125; &#125; &#125; 6.5 ReceiverDispatcher#performReceive构造Args封装成一个消息,Args继承自PendingResult实现了Runnable接口1234567891011121314LoadedApk#ReceiverDispatcherpublic void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123; Args args = new Args(intent, resultCode, data, extras, ordered,sticky, sendingUser); if (!mActivityThread.post(args)) &#123; if (mRegistered &amp;&amp; ordered) &#123; IActivityManager mgr = ActivityManagerNative.getDefault(); args.sendFinished(mgr); &#125; &#125;&#125; 6.6 Args#run但是构造一个Args对象又有什么用？或者说PendingResult的作用是什么？这个PendingResult可以在BroadcastReceiver#onReceive方法中通过goAsync方法返回，表示的结果的状态，在一个广播处理完之后必须调用其finish方法（这个在回调onReceiver方法后会自动回调）,finish方法用来完成某个广播，对于一个已经处理完的广播，如果是有序广播，接收完之后需要向AMS发一个回包，以便AMS可以将这个有序广播发送给下一个广播接收者。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647final class Args extends BroadcastReceiver.PendingResult implements Runnable &#123; private Intent mCurIntent; private final boolean mOrdered; public Args(Intent intent, int resultCode, String resultData, Bundle resultExtras, boolean ordered, boolean sticky, int sendingUser) &#123; super(resultCode, resultData, resultExtras, mRegistered ? TYPE_REGISTERED : TYPE_UNREGISTERED, ordered, sticky, mIIntentReceiver.asBinder(), sendingUser); mCurIntent = intent; mOrdered = ordered; &#125; public void run() &#123; final BroadcastReceiver receiver = mReceiver;//具体注册的BroadcastReceiver，保存在ReceiverDispatcher成员变量 final boolean ordered = mOrdered; final IActivityManager mgr = ActivityManagerNative.getDefault(); final Intent intent = mCurIntent; mCurIntent = null; if (receiver == null || mForgotten) &#123; if (mRegistered &amp;&amp; ordered) &#123; sendFinished(mgr); &#125; return; &#125; try &#123; ClassLoader cl = mReceiver.getClass().getClassLoader(); intent.setExtrasClassLoader(cl); setExtrasClassLoader(cl); receiver.setPendingResult(this); receiver.onReceive(mContext, intent);//回调具体的Receiver &#125; catch (Exception e) &#123; if (mRegistered &amp;&amp; ordered) &#123; if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,\"Finishing failed broadcast to \" + mReceiver); sendFinished(mgr); &#125; //... &#125; if (receiver.getPendingResult() != null) &#123; finish(); &#125; &#125;&#125;","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"app","slug":"app","permalink":"https://austinxishou.github.io/tags/app/"},{"name":"sendBroadcast","slug":"sendBroadcast","permalink":"https://austinxishou.github.io/tags/sendBroadcast/"}]},{"title":"SEAndroid权限修改","date":"2017-03-29T05:39:55.224Z","path":"uncategorized/cj1fzsj46003i0kpxcmz5yyte/android/SEAndroid权限修改/","text":"权限修改方法1: adb在线修改seLinux Enforcing(表示已打开)，Permissive（表示已关闭） getenforce; //获取当前seLinux状态 setenforce 1; //打开seLinux setenforce 0; //关闭seLinux 方法2: 从kernel中彻底关闭修改LINUX/android/kernel/arch/arm64/configs/xxx_defconfig文件（xxx一般为手机产品名）， 去掉CONFIG_SECURITY_SELINUX=y的配置项 方法3: sepolicy中添加权限 修改依据，通过指令cat /proc/kmsg | grep denied，或者kernel的Log中定位到标志性log。 修改步骤 找相应的源类型.te文件，此文件可能的存放路径 (其中源类型见下方的标志性log格式) ： LINUX/android/external/sepolicy LINUX/android/device/qcom/sepolicy/common 标志性log 格式 avc: denied { 操作权限 } for pid=7201 comm=“进程名” scontext=u:r:源类型:s0 tcontext=u:r:目标类型:s0 tclass=访问类型 permissive=0 在相应源类型.te文件，添加如下格式的一行语句：(结尾别忘了分号) 格式：allow 源类型 目标类型:访问类型 {操作权限}; 实例 Kernel Log avc: denied {getattr read} for pid=7201 comm=&quot;xxx.xxx&quot; scontext=u:r:system_app:s0 tcontext=u:r:shell_data_file:s0 tclass=dir permissive=0 修改方案 在system_app.te文件中，添加下面语句： allow system_app shell_data_file:dir{getattr read};","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"security","slug":"security","permalink":"https://austinxishou.github.io/tags/security/"},{"name":"selinux","slug":"selinux","permalink":"https://austinxishou.github.io/tags/selinux/"}]},{"title":"GithubPages+Hexo3.0搭建静态博客网页","date":"2017-03-29T01:27:40.078Z","path":"webdesign/cj1fzsj4m003l0kpxljmjf7i2/webdesign/GithubPages+Hexo3.0搭建静态博客网页/","text":"AboutHexo 是一个轻量的静态博客框架。通过Hexo可以快速生成一个静态博客框架,仅需要几条命令就可以完成,相当方便。而架设Hexo的环境更简单了 不需要lnmp/lamp这些繁琐复杂的环境 仅仅需要一个简单的http服务器即可使用 或者使用互联网上免费的页面托管服务 比如Hexo的官方网站就是托管于github的pages服务上 Hexo配置方法进去之后加入hexo主程序和安装npm12hexo initnpm install 目录结构新建完成后，指定文件夹的目录如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 source资源文件夹是存放用户资源的地方。除 posts 文件夹之外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 Hexo全局配置用文本编辑器修改_config.yml这个文件 大致如下 只需要自行修改几个 其他保持默认即可 通常需要修改站点名称 /URL格式 /归档设置 /disqus评论用户名 /部署配置 这几项就可以了 注意冒号后面都要添加一个半角空格 之后才是设置参数 自定义域名设置 在 source 我文件夹下面新建 CNAME 文件 里面写入你的自定义域名 并设置您的dns配置cname方式到服务提供商的给的地址即可 目录source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public tag_dir 标签文件夹 tags archive_dir 归档文件夹 archives category_dir 分类文件夹 categories code_dir Include code 文件夹 downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染，您可使用 glob 来配置路径。 文章本地启动server1$ hexo server 可以观察命令行的输出，然后通过浏览器打开http://localhost:4000/，成功的情况下则会看到默认的欢迎页面。 部署到github pagesHexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。1$ hexo deploy 在开始之前，您必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数，例如： 12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] 1234参数 描述repo 库（Repository）地址branch 分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。message 自定义提交信息 (默认为 Site updated: &#123;&#123; now(&apos;YYYY-MM-DD HH:mm:ss&apos;) &#125;&#125;) 我的博客对应的参数设置为123456deploy: type: git repo: https://github.com/austinxishou/austinxishou.github.io.git branch: master name: austinxishou email: austinxishou@yahoo.com 安装 hexo-deployer-git 1$ npm install hexo-deployer-git --save 之后依次执行:123$ hexo clean$ hexo generate$ hexo deploy 上述命令只要Github的权限校验通过,基本都能成功; hexo主题收集主题 Next Nidigo 写文章使用草稿在 source/_drafts 文件夹中 创建的文章为草稿，默认情况下不生成；可以显示草稿1$ hexo --draft 生成sitemap站点地图安装插件12npm install -g hexo-generator-sitemap --savenpm install -g hexo-generator-baidu-sitemap --save 修改_config.yml文件12345# auto sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://austinxishou.github.io/tags/Hexo/"},{"name":"webdesign","slug":"webdesign","permalink":"https://austinxishou.github.io/tags/webdesign/"},{"name":"github","slug":"github","permalink":"https://austinxishou.github.io/tags/github/"}]},{"title":"Android组件生命周期解析","date":"2017-03-29T01:27:40.077Z","path":"android/cj1fzsj4600370kpxn7doyazr/android/Android组件生命周期解析/","text":"Activity在平时的应用开发中,接触最多的就是activity的生命周期。在生命周期回调方法中，您可以声明当用户离开并重新进入活动时，执行相应的代码行为。每一个回调工作，都应该执行特定动作，在正确的时间进行正确的工作并正确处理转换，才能够使应用程序更加健壮，更有效率。 如果没有处理好activity的生命周期，则有可能导致各种异常: 应用程序运行时被电话或者其他程序中断，导致崩溃； 没有正确释放资源时,消耗宝贵的系统资源，甚至OOM。 如果用户离开您的应用程序并在以后返回，则丢失用户的进度。 屏幕在横向和纵向方向之间旋转时，可能会崩溃或丢失用户的进度。 所以有必要深入一些，了解和掌握Activity的生命，下面先放一张activity的生命周期图： activity lifecycle 1.1 Activity状态根据具体的应用的复杂性，可能不需要实现所有的生命周期方法。 创建 onCreate()： 必须实现此回调，当系统首次创建活动时触发。 在该方法中，执行基本的应用程序启动逻辑，该逻辑在整个活动的整个生命周期中应该只发生一次。 例如，将数据绑定到列表，初始化后台线程，并实例化一些类范围变量。 此方法接收参数savedInstanceState，该参数是包含Bundle 活动之前保存的状态的对象。如果活动从未存在，则该Bundle对象的值为null。 开始 onStart()： 当活动进入“开始”状态时，系统将调用此回调。 该方法是应用程序初始化维护UI的代码的位置。 它也可以注册一个BroadcastReceiver 监视UI中响应的更改。 该状态只是过渡状态，非常快速完成，与“创建”状态一样，活动不会保持在“已启动”状态。一旦这个回调结束，活动进入 Resumed状态，系统调用该 onResume()方法。 恢复 onResume()： 这是应用程序与用户进行交互的状态。该应用程序停留在此状态，直到发生某些事情，将焦点从应用程序中移开。 当发生中断事件时，活动进入暂停 状态，系统调用 onPause()回调。 onResume状态说明activity在最上方，用户可以与它进行交互。所以那些仅在用户关注时才使用的组件应该在这个回调中初始化。 暂停 onPause()： 当前activity仍然是可见的。但被另一个activity处在最上方，最上方的activity是半透明的，或者是部分覆盖整个屏幕。被暂停的activity不会再接受用户的输入。 动画和音乐播放Activity在暂停状态下不应该继续。 进入暂停的时机有以下几种： 电话或者短信等系统中断； 在多窗口模式中，切换到其他窗口； 打开一个新的半透明活动（如对话框）; 当处于极度低内存的状态时，系统会杀掉该activity，释放相应资源。 onPause()执行非常简短，并不一定有足够的时间执行保存操作。保存应用程序或用户数据不应该在这步骤实现； 停止 onStop（）： 当前activity完全被隐藏，不被用户可见。可以认为是处于在后台。 由于对用户不再可见，只要有内存的需要，系统就会杀掉该activity来释放资源。 该状态由onStop()进入，或onRestart()或者onCreate()重新唤醒软件，或者被onDestroy()彻底死亡.. 销毁 onDestroy()： 在活动被销毁之前调用。这是活动收到的最后一个回调。 在该回调中，释放上述所有回调中未被销毁的资源； 当acitivty处于暂停或者停止状态，系统可以通过finish()或 android.os.Process.killProcess(android.os.Process.myPid())来杀死其进程。当该activity再次被打开时(结束或杀死后)，需要重新创建，走一遍完整的流程。 1.2 Activities调用流程当Activity A 启动 Activity B时，两个activity都有自个的生命周期。Activity A暂停或者停止，Activity B被创建。记住，在Activity B创建之前，Activity A并不会完全停止，流程如下： Activity A 进入onPause(); Activity B 依次 onCreate(), onStart(), onResume()。（此时Activity B得到了用户焦点） 如果Activity A不再可见，则进入onStop(). 1.3 代码实践利用下面的DemoActivity代码，可亲自感受每一个阶段的状态。比如点返回键，home键，menu键等操作，可以借助通过logcat查看该activity到底处于哪种状态，这里就不说结果了，自己动手，丰衣足食。 import android.app.Activity; import android.os.Bundle; import android.util.Log; public class DemoActivity extends Activity { private static final String TAG = &quot;demo&quot;; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Log.i(TAG,&quot;onCreate::The activity is being created.&quot;); } @Override protected void onStart() { super.onStart(); Log.i(TAG, &quot;onStart::The activity is about to become visible.&quot;); } @Override protected void onResume() { super.onResume(); Log.i(TAG, &quot;onResume::The activity has become visible.&quot;); } @Override protected void onPause() { super.onPause(); Log.i(TAG, &quot;onPause:: Another activity is taking focus.&quot;); } @Override protected void onStop() { super.onStop(); Log.i(TAG, &quot;onStop::The activity is no longer visible&quot;); } @Override protected void onDestroy() { super.onDestroy(); Log.i(TAG, &quot;onDestroy::The activity is about to be destroyed&quot;); } } Service理解activity的生命周期后，Service的生命周期也是大同小异，先看下Service的生命周期图： service lifecycle 2.1 启动方式：service有两种启动方式： startService() 启动本地服务Local Service bindService() 启动远程服务Remote Service 2.2 生命周期两种不同的启动方式决定了Service具有两种生命周期的可能（并非互斥的两种）。 start方式：onCreate()，onStartCommand()。onDestroy释放资源。 bind方式： onCreate()，onBind()方法。需要所有client全部调用unbindService()才能将Service释放资源，等待系统回收。 2.3 代码实践利用下面的DemoService代码，通过logcat自行感受每一个阶段的状态与场景的关系。 import android.app.Service; import android.content.Intent; import android.os.IBinder; import android.util.Log; public class DemoService extends Service { private static final String TAG = &quot;demo&quot;; int mStartMode; // service被杀掉的方式 IBinder mBinder; // clients绑定接口 boolean mAllowRebind; // 是否允许onRebind @Override public void onCreate() { Log.i(TAG,&quot;onCreate::The service is being created&quot;); } @Override public int onStartCommand(Intent intent, int flags, int startId) { Log.i(TAG,&quot;onStartCommand::The service is starting&quot;); return mStartMode; } @Override public IBinder onBind(Intent intent) { Log.i(TAG,&quot;onBind::A client is binding to the service&quot;); return mBinder; } @Override public boolean onUnbind(Intent intent) { Log.i(TAG,&quot;onUnbind::All clients have unbound&quot;); return mAllowRebind; } @Override public void onRebind(Intent intent) { Log.i(TAG,&quot;onRebind::A client rebind to the service &quot; + &quot;after onUnbind() has already been called&quot;); } @Override public void onDestroy() { Log.i(TAG,&quot;onDestroy::The service is no longer used&quot;); } }","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"activity","slug":"activity","permalink":"https://austinxishou.github.io/tags/activity/"}]}]