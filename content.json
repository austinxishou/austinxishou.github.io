[{"title":"RK3288平台img包解压修改","date":"2017-04-12T03:26:38.078Z","path":"android/cj1eg4q4h002rrcpxedmasioh/android/RK3288平台img包解压修改/","text":"解压update.img12./rkImageMaker -unpack update.img output ./afptool -unpack output/firmware.img output 解压 system.img123456789mount -o loop Image/system.img /mnt/systemumount /mnt/system//增加 128M 的空间dd if=/dev/zero bs=1M count=128 &gt;&gt; Image/system.img//扩展文件系统信息e2fsck -f Image/system.imgresize2fs Image/system.img 解压boot.img1234./rkunpack boot.img mkdir boot-extractedcd boot-extractedcat ../boot.img-raw | gunzip | cpio -i 解压resource.img12345resource_tool --unpack --image=resource.img Myresource//dtb 反编译成dts./dtc -I dtb -O dts rk-kernel.dtb &gt; my-rk-kernel.dts//单独编译dts./dtc -I dtS -O dtB &gt; rk-kernel.dts 打包 boot.img12find . | cpio -o -H newc | gzip &gt; ../opinions-on-teclast-p90hdst-boot.imgrkcrc -k test-boot.img newboot.img imgRePackerRK_105 工具imgRePackerRK_105百度云下载","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"app","slug":"app","permalink":"https://austinxishou.github.io/tags/app/"}]},{"title":"Android自启动管理功能","date":"2017-03-31T06:37:05.178Z","path":"android/cj1eg4q4f002mrcpx78ay7f7a/android/Android自启动管理功能/","text":"About基本功能: 获取设备上所有应用的开机启动完成的广播接收者,同时区分系统应用和用户应用.然后,提供界面接口给用户,统一管理应用的自启动功能,这样可以提升系统的运行性能和待机时长; 获取所有receivers 区分是否使能获取包含被禁止自启动receiver的信息1List&lt;ResolveInfo&gt; forbidInfoList = mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_DISABLED_COMPONENTS); 获取所有使能的 receivers1List&lt;ResolveInfo&gt; allowInfoList = mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_RECEIVERS); 两个列表比较,标志receivers是否开启12345for(int k=0; k&lt;allowInfoList.size(); k++)&#123; if( allowInfoList.get(k).activityInfo.packageName.equals(packageName) )&#123; isEnable =true; &#125;&#125; 判断是否为系统应用通过ApplicationInfo.FLAG_SYSTEM标志,判断是否为系统应用1234if((forbidInfoList.get(i).activityInfo.applicationInfo.flags&amp;ApplicationInfo.FLAG_SYSTEM)==1|| (forbidInfoList.get(i).activityInfo.applicationInfo.flags&amp;ApplicationInfo.FLAG_UPDATED_SYSTEM_APP)==1)&#123; isSystem = true;&#125; 判断是否运行并获取内存占用大小123456789101112131415161718192021222324252627float memUsed = 0;ArrayList&lt;Integer&gt; pid = new ArrayList&lt;Integer&gt;(runningApps.size());//循环处理正在运行进程for(int k=0; k&lt;runningApps.size(); k++)&#123; if(runningApps.get(k).processName.equals(packageName))&#123; // Log.e(\"ycltest\",\"in runningApps list find the right process,handle it\"); pid.add( Integer.valueOf(runningApps.get(k).pid) ); &#125;else&#123; continue; &#125;&#125;if( pid.size() == 0)&#123; isRun = false;&#125;else&#123; //获取内存大小 isRun = true; int[] pids = new int[pid.size()]; for (int num=0; num&lt;pid.size(); num++) &#123; pids[num] = pid.get(num).intValue(); &#125; Debug.MemoryInfo[] mi = mActivityManager.getProcessMemoryInfo(pids); for (int num=0; num&lt;mi.length; num++) &#123; memUsed += (float)(mi[num].getTotalPrivateDirty()+mi[num].getTotalPss())/1024; &#125;&#125; 关闭和开启Receiver通过PackageManager.setComponentEnabledSetting方法,关闭和开启Receiver 1234567891011121314private void updatePackageReceiverState( PackageEntry item, boolean isChecked)&#123; String packageReceiverList[] = item.getPackageReceivers().split(\";\"); int newState = isChecked ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED : PackageManager.COMPONENT_ENABLED_STATE_DISABLED; for (int i=0; i&lt;packageReceiverList.length; i++) &#123; if( packageReceiverList[i] != null )&#123; ComponentName comName = new ComponentName(item.getPackageName(), packageReceiverList[i]); int flag = 0; if( item.getPackageName().equals(\"com.android.settings\") )&#123; flag = PackageManager.DONT_KILL_APP; &#125; mPackageManager.setComponentEnabledSetting(comName,newState, flag); &#125; &#125;&#125; 其他功能其他功能包括,列表排序,列表更新,无应用列表图片显示等,不在这里详细展开!","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"app","slug":"app","permalink":"https://austinxishou.github.io/tags/app/"}]},{"title":"Android发送广播详解","date":"2017-03-31T06:22:32.229Z","path":"android/cj1eg4q4d002hrcpxzbmrrqe9/android/Android发送广播详解/","text":"调用ContextImpl进行发送同样，不管是Activity、Service上发送广播，最终实现都在ContextImpl，最后发送到ActivityManagerService处理 12345678910111213@Override public void sendBroadcast(Intent intent) &#123; warnIfCallingFromSystemProcess(); String resolvedType = intent.resolveTypeIfNeeded(getContentResolver()); try &#123; intent.prepareToLeaveProcess(); ActivityManagerNative.getDefault().broadcastIntent( mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, false, false, getUserId()); &#125; catch (RemoteException e) &#123; &#125; &#125; ActivityManagerProxy发送到AMS由ActivityManagerProxy发送到AMS 123456789101112131415161718192021222324252627282930//resultTo：null，resultCode：-resultData：null，map：null，requiredPermission：null//appOp：-1，serialized：false，sticky：falsepublic int broadcastIntent(IApplicationThread caller, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle map, String requiredPermission, int appOp, boolean serialized, boolean sticky, int userId) throws RemoteException&#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(caller != null ? caller.asBinder() : null); intent.writeToParcel(data, 0); data.writeString(resolvedType); data.writeStrongBinder(resultTo != null ? resultTo.asBinder() : null); data.writeInt(resultCode); data.writeString(resultData); data.writeBundle(map); data.writeString(requiredPermission); data.writeInt(appOp); data.writeInt(serialized ? 1 : 0); data.writeInt(sticky ? 1 : 0); data.writeInt(userId); mRemote.transact(BROADCAST_INTENT_TRANSACTION, data, reply, 0); reply.readException(); int res = reply.readInt(); reply.recycle(); data.recycle(); return res;&#125; AMS处理BROADCAST_INTENT_TRANSACTIONAMS处理BROADCAST_INTENT_TRANSACTION1234567891011121314151617181920212223242526//resultTo：null，resultCode：-resultData：null，map：null，requiredPermission：null//appOp：-1，serialized：false，sticky：falsecase BROADCAST_INTENT_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); IBinder b = data.readStrongBinder(); IApplicationThread app =b != null ? ApplicationThreadNative.asInterface(b) : null;//依然是Binder本地对象 Intent intent = Intent.CREATOR.createFromParcel(data); String resolvedType = data.readString(); b = data.readStrongBinder();//null IIntentReceiver resultTo =b != null ? IIntentReceiver.Stub.asInterface(b) : null;//null int resultCode = data.readInt();//-1 String resultData = data.readString();//null Bundle resultExtras = data.readBundle();//null String perm = data.readString();//null int appOp = data.readInt();//-1 boolean serialized = data.readInt() != 0;//0 boolean sticky = data.readInt() != 0;//0 int userId = data.readInt(); int res = broadcastIntent(app, intent, resolvedType, resultTo, resultCode, resultData, resultExtras, perm, appOp, serialized, sticky, userId); reply.writeNoException(); reply.writeInt(res); return true; &#125; 首先检验Intent的有效性，是否带文件描述符，如果进程未启动完成，带FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT，表示可以在进程未启动完之前接收广播，没有该标识则抛异常，接着调用方法broadcastIntentLocked处理1234567891011121314151617181920212223//resultTo：null，resultCode：-resultData：null，map：null，requiredPermission：null//appOp：-1，serialized：false，sticky：falsepublic final int broadcastIntent(IApplicationThread caller, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle map, String requiredPermission, int appOp, boolean serialized, boolean sticky, int userId) &#123; enforceNotIsolatedCaller(\"broadcastIntent\"); synchronized(this) &#123; //intent有效性检查，不能带文件描述符 intent = verifyBroadcastLocked(intent); final ProcessRecord callerApp = getRecordForAppLocked(caller); final int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); int res = broadcastIntentLocked(callerApp, callerApp != null ? callerApp.info.packageName : null, intent, resolvedType, resultTo, resultCode, resultData, map, requiredPermission, appOp, serialized, sticky, callingPid, callingUid, userId); Binder.restoreCallingIdentity(origId); return res; &#125;&#125; broadcastIntentLocked获取目标Receivers首先处理一些特殊的广播，如：接收到PackageManager发来的应用包移除广播，就会把所有属于该包下的ActivityRecord出栈等，AMS内有两种广播队列，分别是前台广播队列mFgBroadcastQueue保存带FLAG_RECEIVER_FOREGROUND的广播，和后台广播队列mBgBroadcastQueue，先会尝试向并行receivers递送广播，此时会调用到queue.scheduleBroadcastsLocked()，简单地说就是，新建一个BroadcastRecord节点，并插入对应的BroadcastQueue，最后发起实际的广播调度（scheduleBroadcastsLocked()），不光并行处理部分需要一个BroadcastRecord节点，串行处理部分也需要BroadcastRecord节点。也就是说，要激发一次广播，AMS必须构造一个或两个BroadcastRecord节点，并将之插入合适的广播队列。插入成功后，再执行队列的scheduleBroadcastsLocked()动作BroadcastRecord节点内部的receivers列表，记录着和这个广播动作相关的目标receiver信息，该列表内部的子节点可能是ResolveInfo类型的，也可能是BroadcastFilter类型的。ResolveInfo是从PKMS处查到的静态receiver的描述信息，它的源头是PKMS解析的那些AndroidManifest.xml文件。而BroadcastFilter来自于动态注册receiver时，保存在AMS成员变量mReceiverResolver123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332//resultTo：null，resultCode：-resultData：null，map：null，requiredPermission：null//appOp：-1，serialized：false，sticky：falseprivate final int broadcastIntentLocked(ProcessRecord callerApp, String callerPackage, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle map, String requiredPermission, int appOp, boolean ordered, boolean sticky, int callingPid, int callingUid, int userId) &#123; intent = new Intent(intent); // By default broadcasts do not go to stopped apps. //在Android3.1之后，PKMS加强了对“处于停止状态的”应用的管理。如果一个应用在安装后从来没有启动过，或者已经被用户强制停止了，那么这个应用就处于停止状态（stoppedstate）。为了达到精细调整的目的，Android增加了2个flag：FLAG_INCLUDE_STOPPED_PACKAGES和FLAG_EXCLUDE_STOPPED_PACKAGES，以此来表示intent是否要激活“处于停止状态的”应用。而默认则是不激活 intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES); //.... userId = handleIncomingUser(callingPid, callingUid, userId,true, false, \"broadcast\", callerPackage);//权限检测 // Make sure that the user who is receiving this broadcast is started. // If not, we will just skip it. if (userId != UserHandle.USER_ALL &amp;&amp; mStartedUsers.get(userId) == null) &#123; if (callingUid != Process.SYSTEM_UID || (intent.getFlags() &amp; Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) &#123; Slog.w(TAG, \"Skipping broadcast of \" + intent+ \": user \" + userId + \" is stopped\"); return ActivityManager.BROADCAST_SUCCESS; &#125; &#125; /* * Prevent non-system code (defined here to be non-persistent processes) from sending protected broadcasts. */ int callingAppId = UserHandle.getAppId(callingUid); if (callingAppId == Process.SYSTEM_UID || callingAppId == Process.PHONE_UID || callingAppId == Process.SHELL_UID || callingAppId == Process.BLUETOOTH_UID || callingUid == 0) &#123; // Always okay. &#125; else if (callerApp == null || !callerApp.persistent) &#123; //... &#125; // Handle special intents: if this broadcast is from the package // manager about a package being removed, we need to remove all of // its activities from the history stack. final boolean uidRemoved = Intent.ACTION_UID_REMOVED.equals(intent.getAction()); if (Intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction()) || uidRemoved) &#123; if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid, callingUid, -1, true) == PackageManager.PERMISSION_GRANTED) &#123; if (uidRemoved) &#123; final Bundle intentExtras = intent.getExtras(); final int uid = intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1; if (uid &gt;= 0) &#123; BatteryStatsImpl bs = mBatteryStatsService.getActiveStatistics(); synchronized (bs) &#123; bs.removeUidStatsLocked(uid); &#125; mAppOpsService.uidRemoved(uid); &#125; &#125; else &#123; // If resources are unavailable just force stop all // those packages and flush the attribute cache as well. if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())) &#123; String list[] = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST); if (list != null &amp;&amp; (list.length &gt; 0)) &#123; for (String pkg : list) &#123; forceStopPackageLocked(pkg, -1, false, true, true, false, userId, \"storage unmount\"); &#125; sendPackageBroadcastLocked( IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE, list, userId); &#125; &#125; else &#123; Uri data = intent.getData(); String ssp; if (data != null &amp;&amp; (ssp=data.getSchemeSpecificPart()) != null) &#123; boolean removed = Intent.ACTION_PACKAGE_REMOVED.equals( intent.getAction()); if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP, false)) &#123; forceStopPackageLocked(ssp, UserHandle.getAppId( intent.getIntExtra(Intent.EXTRA_UID, -1)), false, true, true, false, userId, removed ? \"pkg removed\" : \"pkg changed\"); &#125; if (removed) &#123; sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REMOVED, new String[] &#123;ssp&#125;, userId); if (!intent.getBooleanExtra(Intent.EXTRA_REPLACING, false)) &#123; mAppOpsService.packageRemoved( intent.getIntExtra(Intent.EXTRA_UID, -1), ssp); // Remove all permissions granted from/to this package removeUriPermissionsForPackageLocked(ssp, userId, true); &#125; &#125; &#125; &#125; &#125; &#125; else &#123; //\"Permission Denial: \" throw new SecurityException(msg); &#125; // Special case for adding a package: by default turn on compatibility mode. &#125; else if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())) &#123; Uri data = intent.getData(); String ssp; if (data != null &amp;&amp; (ssp=data.getSchemeSpecificPart()) != null) &#123; mCompatModePackages.handlePackageAddedLocked(ssp, intent.getBooleanExtra(Intent.EXTRA_REPLACING, false)); &#125; &#125; /* * If this is the time zone changed action, queue up a message that will reset the timezone * of all currently running processes. This message will get queued up before the broadcast * happens. */ if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) &#123; mHandler.sendEmptyMessage(UPDATE_TIME_ZONE); &#125; if (intent.ACTION_CLEAR_DNS_CACHE.equals(intent.getAction())) &#123; mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG); &#125; if (Proxy.PROXY_CHANGE_ACTION.equals(intent.getAction())) &#123; ProxyProperties proxy = intent.getParcelableExtra(\"proxy\"); mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG, proxy)); &#125; // Add to the sticky list if requested. if (sticky) &#123;//false，先忽略 if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid, callingUid) != PackageManager.PERMISSION_GRANTED) &#123; //... throw new SecurityException(msg); &#125; if (requiredPermission != null) &#123; Slog.w(TAG, \"Can't broadcast sticky intent \" + intent+ \" and enforce permission \" + requiredPermission); return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION; &#125; if (intent.getComponent() != null) &#123; throw new SecurityException(\"Sticky broadcasts can't target a specific component\"); &#125; // We use userId directly here, since the \"all\" target is maintained // as a separate set of sticky broadcasts. if (userId != UserHandle.USER_ALL) &#123; // But first, if this is not a broadcast to all users, then // make sure it doesn't conflict with an existing broadcast to // all users. ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get( UserHandle.USER_ALL); if (stickies != null) &#123; ArrayList&lt;Intent&gt; list = stickies.get(intent.getAction()); if (list != null) &#123; int N = list.size(); int i; for (i=0; i&lt;N; i++) &#123; if (intent.filterEquals(list.get(i))) &#123; throw new IllegalArgumentException( \"Sticky broadcast \" + intent + \" for user \" + userId + \" conflicts with existing global broadcast\"); &#125; &#125; &#125; &#125; &#125; ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(userId); if (stickies == null) &#123; stickies = new ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt;(); mStickyBroadcasts.put(userId, stickies); &#125; ArrayList&lt;Intent&gt; list = stickies.get(intent.getAction()); if (list == null) &#123; list = new ArrayList&lt;Intent&gt;(); stickies.put(intent.getAction(), list); &#125; int N = list.size(); int i; for (i=0; i&lt;N; i++) &#123; if (intent.filterEquals(list.get(i))) &#123; // This sticky already exists, replace it. list.set(i, new Intent(intent)); break; &#125; &#125; if (i &gt;= N) &#123; list.add(new Intent(intent)); &#125; &#125; int[] users; if (userId == UserHandle.USER_ALL) &#123; // Caller wants broadcast to go to all started users. users = mStartedUserArray; &#125; else &#123; // Caller wants broadcast to go to one specific user. users = new int[] &#123;userId&#125;; &#125; // Figure out who all will receive this broadcast. List receivers = null; List&lt;BroadcastFilter&gt; registeredReceivers = null; // Need to resolve the intent to interested receivers... //FLAG_RECEIVER_REGISTERED_ONLY标识标识的是动态注册的广播，至于静态注册的广播是通过PackageManager获得 if ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY)== 0) &#123; receivers = collectReceiverComponents(intent, resolvedType, users); &#125; if (intent.getComponent() == null) &#123; //找到符合的接受者（详细之后再看），返回结果按照优先级排序 registeredReceivers = mReceiverResolver.queryIntent(intent,resolvedType, false, userId); &#125; //是否替代 final boolean replacePending =(intent.getFlags()&amp;Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0; int NR = registeredReceivers != null ? registeredReceivers.size() : 0; if (!ordered &amp;&amp; NR &gt; 0) &#123; // If we are not serializing this broadcast, then send the // registered receivers separately so they don't wait for the // components to be launched. final BroadcastQueue queue = broadcastQueueForIntent(intent); BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, resolvedType, requiredPermission, appOp, registeredReceivers, resultTo, resultCode, resultData, map, ordered, sticky, false, userId); final boolean replaced = replacePending &amp;&amp; queue.replaceParallelBroadcastLocked(r); if (!replaced) &#123; queue.enqueueParallelBroadcastLocked(r); queue.scheduleBroadcastsLocked();// &#125; //上面完成了无序广播的调度 registeredReceivers = null; NR = 0; &#125; //看来是先处理动态注册的，之后才是静态注册的 // Merge into one list. int ir = 0; //receiver记录的是在清单文件夹静态注册的广播 if (receivers != null) &#123; // A special case for PACKAGE_ADDED: do not allow the package // being added to see this broadcast. This prevents them from // using this as a back door to get run as soon as they are // installed. Maybe in the future we want to have a special install // broadcast or such for apps, but we'd like to deliberately make // this decision. //防止监听自己的应用安装后自己收到广播而自动启动 String skipPackages[] = null; if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) &#123; Uri data = intent.getData(); if (data != null) &#123; String pkgName = data.getSchemeSpecificPart(); if (pkgName != null) &#123; skipPackages = new String[] &#123; pkgName &#125;; &#125; &#125; &#125; else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) &#123; skipPackages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST); &#125; //移除特定的广播任务 if (skipPackages != null &amp;&amp; (skipPackages.length &gt; 0)) &#123; for (String skipPackage : skipPackages) &#123; if (skipPackage != null) &#123; int NT = receivers.size(); for (int it=0; it&lt;NT; it++) &#123; ResolveInfo curt = (ResolveInfo)receivers.get(it); if (curt.activityInfo.packageName.equals(skipPackage)) &#123; receivers.remove(it); it--; NT--; &#125; &#125; &#125; &#125; &#125; //如果是无序广播，在上面NR已置为了0，下面是用于合并有序和静态注册的广播 int NT = receivers != null ? receivers.size() : 0;//静态注册的广播数量 int it = 0; ResolveInfo curt = null; BroadcastFilter curr = null; while (it &lt; NT &amp;&amp; ir &lt; NR) &#123; if (curt == null) &#123; curt = (ResolveInfo)receivers.get(it); &#125; if (curr == null) &#123; curr = registeredReceivers.get(ir); &#125; if (curr.getPriority() &gt;= curt.priority) &#123; // Insert this broadcast record into the final list. receivers.add(it, curr); ir++; curr = null; it++; NT++; &#125; else &#123; // Skip to the next ResolveInfo in the final list. it++; curt = null; &#125; &#125; &#125; while (ir &lt; NR) &#123; if (receivers == null) &#123; receivers = new ArrayList(); &#125; receivers.add(registeredReceivers.get(ir)); ir++; &#125; //下面的操作和处理无序广播一样 if ((receivers != null &amp;&amp; receivers.size() &gt; 0)|| resultTo != null) &#123; BroadcastQueue queue = broadcastQueueForIntent(intent); //resultTo：null，resultCode：-resultData：null，map：null，requiredPermission：null //appOp：-1，serialized：false，sticky：false BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, resolvedType, requiredPermission, appOp, receivers, resultTo, resultCode, resultData, map, ordered, sticky, false, userId); &#125; boolean replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r); if (!replaced) &#123; queue.enqueueOrderedBroadcastLocked(r); queue.scheduleBroadcastsLocked(); &#125; &#125; return ActivityManager.BROADCAST_SUCCESS;&#125; scheduleBroadcastsLocked调度执行以上不管是处理有序广播还是无序广播，最重要的无疑是scheduleBroadcastsLocked方法调用123456789BroadcastQueue.javapublic void scheduleBroadcastsLocked() &#123; if (mBroadcastsScheduled) &#123; return; &#125; mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this)); mBroadcastsScheduled = true; &#125; 处理BROADCAST_TIMEOUT_MSG消息 12345BroadcastQueue.javacase BROADCAST_INTENT_MSG: &#123; processNextBroadcast(true);&#125; break; 处理广播所有的静态receiver都是串行处理的，而动态receiver则会按照发广播时指定的方式，进行“并行”或“串行”处理。能够并行处理的广播，其对应的若干receiver一定都已经存在了，不会牵扯到启动新进程的操作，所以可以在一个while循环中，一次性全部deliver。而有序广播，则需要一个一个地处理，其滚动处理的手段是发送事件，也就是说，在一个receiver处理完毕后，会利用广播队列（BroadcastQueue）的mHandler，发送一个BROADCAST_INTENT_MSG事件，从而执行下一次的processNextBroadcast的调度 处理无序广播遍历并行列表（mParallelBroadcasts）的每一个BroadcastRecord以及其中的receivers列表。对于无序广播而言，receivers列表中的每个子节点是个BroadcastFilter。我们直接通过方法deliverToRegisteredReceiverLocked将广播递送出去即可 1234567891011121314151617181920212223242526272829final void processNextBroadcast(boolean fromMsg) &#123; synchronized(mService) &#123; BroadcastRecord r; mService.updateCpuStats(); if (fromMsg) &#123; //表示BROADCAST_INTENT_MSG消息已经处理完了 mBroadcastsScheduled = false; &#125; // First, deliver any non-serialized broadcasts right away. while (mParallelBroadcasts.size() &gt; 0) &#123; //BroadcastRecord类型的r内部记录了该广播的所有接收者 r = mParallelBroadcasts.remove(0); r.dispatchTime = SystemClock.uptimeMillis(); r.dispatchClockTime = System.currentTimeMillis(); final int N = r.receivers.size();//接收者数量 for (int i=0; i&lt;N; i++) &#123; Object target = r.receivers.get(i); //把非有序队列中各个广播发送给广播接收者 deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false); &#125; addBroadcastToHistoryLocked(r); &#125; //....... &#125; &#125; BroadcastQueue#deliverToRegisteredReceiverLocked先进行的权限判断、操作的检测、目标进程是否启动等操作，如果都OK，前面可知BroadcastFilter用来关联了动态注册的IIntentReceiver和IntentFilter,所以拿到一个BroadcastFilter接可以知道宿主IIntentReceiver，最后调用performReceiveLocked123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//order=false；private final void deliverToRegisteredReceiverLocked(BroadcastRecord r,BroadcastFilter filter, boolean ordered) &#123; boolean skip = false; if (filter.requiredPermission != null) &#123; int perm = mService.checkComponentPermission(filter.requiredPermission,r.callingPid, r.callingUid, -1, true); if (perm != PackageManager.PERMISSION_GRANTED) &#123; //Permission Denial: broadcasting skip = true; &#125; &#125; if (!skip &amp;&amp; r.requiredPermission != null) &#123; int perm = mService.checkComponentPermission(r.requiredPermission, filter.receiverList.pid, filter.receiverList.uid, -1, true); if (perm != PackageManager.PERMISSION_GRANTED) &#123; //Permission Denial: receiving skip = true; &#125; &#125; if (r.appOp != AppOpsManager.OP_NONE) &#123; int mode = mService.mAppOpsService.noteOperation(r.appOp, filter.receiverList.uid, filter.packageName); if (mode != AppOpsManager.MODE_ALLOWED) &#123; if (DEBUG_BROADCAST) Slog.v(TAG, \"App op \" + r.appOp + \" not allowed for broadcast to uid \" + filter.receiverList.uid + \" pkg \" + filter.packageName); skip = true; &#125; &#125; if (!skip) &#123; skip = !mService.mIntentFirewall.checkBroadcast(r.intent, r.callingUid, r.callingPid, r.resolvedType, filter.receiverList.uid); &#125; if (filter.receiverList.app == null || filter.receiverList.app.crashing) &#123; Slog.w(TAG, \"Skipping deliver [\" + mQueueName + \"] \" + r+ \" to \" + filter.receiverList + \": process crashing\"); skip = true; &#125; if (!skip) &#123; // If this is not being sent as an ordered broadcast, then we // don't want to touch the fields that keep track of the current // state of ordered broadcasts. if (ordered) &#123;//false r.receiver = filter.receiverList.receiver.asBinder();//记录的是IIntentReceiver的Binder本地对象 r.curFilter = filter; filter.receiverList.curBroadcast = r; r.state = BroadcastRecord.CALL_IN_RECEIVE; if (filter.receiverList.app != null) &#123; // Bump hosting application to no longer be in background scheduling class. Note that we can't do that if there // isn't an app... but we can only be in that case for things that directly call the IActivityManager API, which // are already core system stuff so don't matter for this. r.curApp = filter.receiverList.app; filter.receiverList.app.curReceiver = r; mService.updateOomAdjLocked(r.curApp, true); &#125; &#125; try &#123; //filter.receiverList.app:ApplicationThread //filter.receiverList.receiver： performReceiveLocked(filter.receiverList.app, filter.receiverList.receiver, new Intent(r.intent), r.resultCode, r.resultData, r.resultExtras, r.ordered, r.initialSticky, r.userId); if (ordered) &#123; r.state = BroadcastRecord.CALL_DONE_RECEIVE; &#125; &#125; catch (RemoteException e) &#123; Slog.w(TAG, \"Failure sending broadcast \" + r.intent, e); if (ordered) &#123; r.receiver = null; r.curFilter = null; filter.receiverList.curBroadcast = null; if (filter.receiverList.app != null) &#123; filter.receiverList.app.curReceiver = null; &#125; &#125; &#125; &#125;&#125; 6.3 BroadcastQueue#performReceiveLocked接着如果当前进程是存在的且已经启动，通过ApplicationThread来进行回调但实际上还是通过IIntentReceiver来回调，123456789101112131415BroadcastQueue.javaprivate static void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver, Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123; // Send the intent to the receiver asynchronously using one-way binder calls. if (app != null &amp;&amp; app.thread != null) &#123; // If we have an app thread, do the call through that so it is correctly ordered with other one-way calls. app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode, data, extras, ordered, sticky, sendingUser, app.repProcState); &#125; else &#123; receiver.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser); &#125;&#125; 6.4 IIntentReceiver#performReceive1234567891011121314151617181920212223242526LoadedApk#ReceiverDispatcher#IIntentReceiverpublic void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123; //获取宿主ReceiverDispatcher LoadedApk.ReceiverDispatcher rd = mDispatcher.get(); if (rd != null) &#123; rd.performReceive(intent, resultCode, data, extras,ordered, sticky, sendingUser); &#125; else &#123; // The activity manager dispatched a broadcast to a registered // receiver in this process, but before it could be delivered the // receiver was unregistered. Acknowledge the broadcast on its // behalf so that the system's broadcast sequence can continue. if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,\"Finishing broadcast to unregistered receiver\"); IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; if (extras != null) &#123; extras.setAllowFds(false); &#125; mgr.finishReceiver(this, resultCode, data, extras, false); &#125; catch (RemoteException e) &#123; Slog.w(ActivityThread.TAG, \"Couldn't finish broadcast to unregistered receiver\"); &#125; &#125; &#125; 6.5 ReceiverDispatcher#performReceive构造Args封装成一个消息,Args继承自PendingResult实现了Runnable接口1234567891011121314LoadedApk#ReceiverDispatcherpublic void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123; Args args = new Args(intent, resultCode, data, extras, ordered,sticky, sendingUser); if (!mActivityThread.post(args)) &#123; if (mRegistered &amp;&amp; ordered) &#123; IActivityManager mgr = ActivityManagerNative.getDefault(); args.sendFinished(mgr); &#125; &#125;&#125; 6.6 Args#run但是构造一个Args对象又有什么用？或者说PendingResult的作用是什么？这个PendingResult可以在BroadcastReceiver#onReceive方法中通过goAsync方法返回，表示的结果的状态，在一个广播处理完之后必须调用其finish方法（这个在回调onReceiver方法后会自动回调）,finish方法用来完成某个广播，对于一个已经处理完的广播，如果是有序广播，接收完之后需要向AMS发一个回包，以便AMS可以将这个有序广播发送给下一个广播接收者。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647final class Args extends BroadcastReceiver.PendingResult implements Runnable &#123; private Intent mCurIntent; private final boolean mOrdered; public Args(Intent intent, int resultCode, String resultData, Bundle resultExtras, boolean ordered, boolean sticky, int sendingUser) &#123; super(resultCode, resultData, resultExtras, mRegistered ? TYPE_REGISTERED : TYPE_UNREGISTERED, ordered, sticky, mIIntentReceiver.asBinder(), sendingUser); mCurIntent = intent; mOrdered = ordered; &#125; public void run() &#123; final BroadcastReceiver receiver = mReceiver;//具体注册的BroadcastReceiver，保存在ReceiverDispatcher成员变量 final boolean ordered = mOrdered; final IActivityManager mgr = ActivityManagerNative.getDefault(); final Intent intent = mCurIntent; mCurIntent = null; if (receiver == null || mForgotten) &#123; if (mRegistered &amp;&amp; ordered) &#123; sendFinished(mgr); &#125; return; &#125; try &#123; ClassLoader cl = mReceiver.getClass().getClassLoader(); intent.setExtrasClassLoader(cl); setExtrasClassLoader(cl); receiver.setPendingResult(this); receiver.onReceive(mContext, intent);//回调具体的Receiver &#125; catch (Exception e) &#123; if (mRegistered &amp;&amp; ordered) &#123; if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,\"Finishing failed broadcast to \" + mReceiver); sendFinished(mgr); &#125; //... &#125; if (receiver.getPendingResult() != null) &#123; finish(); &#125; &#125;&#125;","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"app","slug":"app","permalink":"https://austinxishou.github.io/tags/app/"},{"name":"sendBroadcast","slug":"sendBroadcast","permalink":"https://austinxishou.github.io/tags/sendBroadcast/"}]},{"title":"SEAndroid权限修改","date":"2017-03-29T05:39:55.224Z","path":"uncategorized/cj1eg4q4p0030rcpxtt3w5mr1/android/SEAndroid权限修改/","text":"权限修改方法1: adb在线修改seLinux Enforcing(表示已打开)，Permissive（表示已关闭） getenforce; //获取当前seLinux状态 setenforce 1; //打开seLinux setenforce 0; //关闭seLinux 方法2: 从kernel中彻底关闭修改LINUX/android/kernel/arch/arm64/configs/xxx_defconfig文件（xxx一般为手机产品名）， 去掉CONFIG_SECURITY_SELINUX=y的配置项 方法3: sepolicy中添加权限 修改依据，通过指令cat /proc/kmsg | grep denied，或者kernel的Log中定位到标志性log。 修改步骤 找相应的源类型.te文件，此文件可能的存放路径 (其中源类型见下方的标志性log格式) ： LINUX/android/external/sepolicy LINUX/android/device/qcom/sepolicy/common 标志性log 格式 avc: denied { 操作权限 } for pid=7201 comm=“进程名” scontext=u:r:源类型:s0 tcontext=u:r:目标类型:s0 tclass=访问类型 permissive=0 在相应源类型.te文件，添加如下格式的一行语句：(结尾别忘了分号) 格式：allow 源类型 目标类型:访问类型 {操作权限}; 实例 Kernel Log avc: denied {getattr read} for pid=7201 comm=&quot;xxx.xxx&quot; scontext=u:r:system_app:s0 tcontext=u:r:shell_data_file:s0 tclass=dir permissive=0 修改方案 在system_app.te文件中，添加下面语句： allow system_app shell_data_file:dir{getattr read};","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"security","slug":"security","permalink":"https://austinxishou.github.io/tags/security/"},{"name":"selinux","slug":"selinux","permalink":"https://austinxishou.github.io/tags/selinux/"}]},{"title":"GithubPages+Hexo3.0搭建静态博客网页","date":"2017-03-29T01:27:40.078Z","path":"webdesign/cj1eg4q4l002vrcpx0rgcylka/webdesign/GithubPages+Hexo3.0搭建静态博客网页/","text":"AboutHexo 是一个轻量的静态博客框架。通过Hexo可以快速生成一个静态博客框架,仅需要几条命令就可以完成,相当方便。而架设Hexo的环境更简单了 不需要lnmp/lamp这些繁琐复杂的环境 仅仅需要一个简单的http服务器即可使用 或者使用互联网上免费的页面托管服务 比如Hexo的官方网站就是托管于github的pages服务上 Hexo配置方法进去之后加入hexo主程序和安装npm12hexo initnpm install 目录结构新建完成后，指定文件夹的目录如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 source资源文件夹是存放用户资源的地方。除 posts 文件夹之外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 Hexo全局配置用文本编辑器修改_config.yml这个文件 大致如下 只需要自行修改几个 其他保持默认即可 通常需要修改站点名称 /URL格式 /归档设置 /disqus评论用户名 /部署配置 这几项就可以了 注意冒号后面都要添加一个半角空格 之后才是设置参数 自定义域名设置 在 source 我文件夹下面新建 CNAME 文件 里面写入你的自定义域名 并设置您的dns配置cname方式到服务提供商的给的地址即可 目录source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public tag_dir 标签文件夹 tags archive_dir 归档文件夹 archives category_dir 分类文件夹 categories code_dir Include code 文件夹 downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染，您可使用 glob 来配置路径。 文章本地启动server1$ hexo server 可以观察命令行的输出，然后通过浏览器打开http://localhost:4000/，成功的情况下则会看到默认的欢迎页面。 部署到github pagesHexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。1$ hexo deploy 在开始之前，您必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数，例如： 12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] 1234参数 描述repo 库（Repository）地址branch 分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。message 自定义提交信息 (默认为 Site updated: &#123;&#123; now(&apos;YYYY-MM-DD HH:mm:ss&apos;) &#125;&#125;) 我的博客对应的参数设置为123456deploy: type: git repo: https://github.com/austinxishou/austinxishou.github.io.git branch: master name: austinxishou email: austinxishou@yahoo.com 安装 hexo-deployer-git 1$ npm install hexo-deployer-git --save 之后依次执行:123$ hexo clean$ hexo generate$ hexo deploy 上述命令只要Github的权限校验通过,基本都能成功; hexo主题收集主题 Next Nidigo 写文章使用草稿在 source/_drafts 文件夹中 创建的文章为草稿，默认情况下不生成；可以显示草稿1$ hexo --draft 生成sitemap站点地图安装插件12npm install -g hexo-generator-sitemap --savenpm install -g hexo-generator-baidu-sitemap --save 修改_config.yml文件12345# auto sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml","tags":[{"name":"webdesign","slug":"webdesign","permalink":"https://austinxishou.github.io/tags/webdesign/"},{"name":"Hexo","slug":"Hexo","permalink":"https://austinxishou.github.io/tags/Hexo/"},{"name":"github","slug":"github","permalink":"https://austinxishou.github.io/tags/github/"}]},{"title":"Android组件生命周期解析","date":"2017-03-29T01:27:40.077Z","path":"android/cj1eg4q4e002jrcpx7t5jysg9/android/Android组件生命周期解析/","text":"Activity在平时的应用开发中,接触最多的就是activity的生命周期。在生命周期回调方法中，您可以声明当用户离开并重新进入活动时，执行相应的代码行为。每一个回调工作，都应该执行特定动作，在正确的时间进行正确的工作并正确处理转换，才能够使应用程序更加健壮，更有效率。 如果没有处理好activity的生命周期，则有可能导致各种异常: 应用程序运行时被电话或者其他程序中断，导致崩溃； 没有正确释放资源时,消耗宝贵的系统资源，甚至OOM。 如果用户离开您的应用程序并在以后返回，则丢失用户的进度。 屏幕在横向和纵向方向之间旋转时，可能会崩溃或丢失用户的进度。 所以有必要深入一些，了解和掌握Activity的生命，下面先放一张activity的生命周期图： activity lifecycle 1.1 Activity状态根据具体的应用的复杂性，可能不需要实现所有的生命周期方法。 创建 onCreate()： 必须实现此回调，当系统首次创建活动时触发。 在该方法中，执行基本的应用程序启动逻辑，该逻辑在整个活动的整个生命周期中应该只发生一次。 例如，将数据绑定到列表，初始化后台线程，并实例化一些类范围变量。 此方法接收参数savedInstanceState，该参数是包含Bundle 活动之前保存的状态的对象。如果活动从未存在，则该Bundle对象的值为null。 开始 onStart()： 当活动进入“开始”状态时，系统将调用此回调。 该方法是应用程序初始化维护UI的代码的位置。 它也可以注册一个BroadcastReceiver 监视UI中响应的更改。 该状态只是过渡状态，非常快速完成，与“创建”状态一样，活动不会保持在“已启动”状态。一旦这个回调结束，活动进入 Resumed状态，系统调用该 onResume()方法。 恢复 onResume()： 这是应用程序与用户进行交互的状态。该应用程序停留在此状态，直到发生某些事情，将焦点从应用程序中移开。 当发生中断事件时，活动进入暂停 状态，系统调用 onPause()回调。 onResume状态说明activity在最上方，用户可以与它进行交互。所以那些仅在用户关注时才使用的组件应该在这个回调中初始化。 暂停 onPause()： 当前activity仍然是可见的。但被另一个activity处在最上方，最上方的activity是半透明的，或者是部分覆盖整个屏幕。被暂停的activity不会再接受用户的输入。 动画和音乐播放Activity在暂停状态下不应该继续。 进入暂停的时机有以下几种： 电话或者短信等系统中断； 在多窗口模式中，切换到其他窗口； 打开一个新的半透明活动（如对话框）; 当处于极度低内存的状态时，系统会杀掉该activity，释放相应资源。 onPause()执行非常简短，并不一定有足够的时间执行保存操作。保存应用程序或用户数据不应该在这步骤实现； 停止 onStop（）： 当前activity完全被隐藏，不被用户可见。可以认为是处于在后台。 由于对用户不再可见，只要有内存的需要，系统就会杀掉该activity来释放资源。 该状态由onStop()进入，或onRestart()或者onCreate()重新唤醒软件，或者被onDestroy()彻底死亡.. 销毁 onDestroy()： 在活动被销毁之前调用。这是活动收到的最后一个回调。 在该回调中，释放上述所有回调中未被销毁的资源； 当acitivty处于暂停或者停止状态，系统可以通过finish()或 android.os.Process.killProcess(android.os.Process.myPid())来杀死其进程。当该activity再次被打开时(结束或杀死后)，需要重新创建，走一遍完整的流程。 1.2 Activities调用流程当Activity A 启动 Activity B时，两个activity都有自个的生命周期。Activity A暂停或者停止，Activity B被创建。记住，在Activity B创建之前，Activity A并不会完全停止，流程如下： Activity A 进入onPause(); Activity B 依次 onCreate(), onStart(), onResume()。（此时Activity B得到了用户焦点） 如果Activity A不再可见，则进入onStop(). 1.3 代码实践利用下面的DemoActivity代码，可亲自感受每一个阶段的状态。比如点返回键，home键，menu键等操作，可以借助通过logcat查看该activity到底处于哪种状态，这里就不说结果了，自己动手，丰衣足食。 import android.app.Activity; import android.os.Bundle; import android.util.Log; public class DemoActivity extends Activity { private static final String TAG = &quot;demo&quot;; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Log.i(TAG,&quot;onCreate::The activity is being created.&quot;); } @Override protected void onStart() { super.onStart(); Log.i(TAG, &quot;onStart::The activity is about to become visible.&quot;); } @Override protected void onResume() { super.onResume(); Log.i(TAG, &quot;onResume::The activity has become visible.&quot;); } @Override protected void onPause() { super.onPause(); Log.i(TAG, &quot;onPause:: Another activity is taking focus.&quot;); } @Override protected void onStop() { super.onStop(); Log.i(TAG, &quot;onStop::The activity is no longer visible&quot;); } @Override protected void onDestroy() { super.onDestroy(); Log.i(TAG, &quot;onDestroy::The activity is about to be destroyed&quot;); } } Service理解activity的生命周期后，Service的生命周期也是大同小异，先看下Service的生命周期图： service lifecycle 2.1 启动方式：service有两种启动方式： startService() 启动本地服务Local Service bindService() 启动远程服务Remote Service 2.2 生命周期两种不同的启动方式决定了Service具有两种生命周期的可能（并非互斥的两种）。 start方式：onCreate()，onStartCommand()。onDestroy释放资源。 bind方式： onCreate()，onBind()方法。需要所有client全部调用unbindService()才能将Service释放资源，等待系统回收。 2.3 代码实践利用下面的DemoService代码，通过logcat自行感受每一个阶段的状态与场景的关系。 import android.app.Service; import android.content.Intent; import android.os.IBinder; import android.util.Log; public class DemoService extends Service { private static final String TAG = &quot;demo&quot;; int mStartMode; // service被杀掉的方式 IBinder mBinder; // clients绑定接口 boolean mAllowRebind; // 是否允许onRebind @Override public void onCreate() { Log.i(TAG,&quot;onCreate::The service is being created&quot;); } @Override public int onStartCommand(Intent intent, int flags, int startId) { Log.i(TAG,&quot;onStartCommand::The service is starting&quot;); return mStartMode; } @Override public IBinder onBind(Intent intent) { Log.i(TAG,&quot;onBind::A client is binding to the service&quot;); return mBinder; } @Override public boolean onUnbind(Intent intent) { Log.i(TAG,&quot;onUnbind::All clients have unbound&quot;); return mAllowRebind; } @Override public void onRebind(Intent intent) { Log.i(TAG,&quot;onRebind::A client rebind to the service &quot; + &quot;after onUnbind() has already been called&quot;); } @Override public void onDestroy() { Log.i(TAG,&quot;onDestroy::The service is no longer used&quot;); } }","tags":[{"name":"android","slug":"android","permalink":"https://austinxishou.github.io/tags/android/"},{"name":"activity","slug":"activity","permalink":"https://austinxishou.github.io/tags/activity/"}]}]