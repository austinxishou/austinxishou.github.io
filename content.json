[{"title":"Android NFC 解析","date":"2017-03-28T10:03:13.731Z","path":"2017/03/28/android/Android-nfc-解析/","text":"","tags":[{"name":"android activity","slug":"android-activity","permalink":"https://austinxishou.github.io/tags/android-activity/"}]},{"title":"微信公众号开发-微擎系统相关学习","date":"2017-03-28T09:08:23.184Z","path":"2017/03/28/微信公众号开发-微擎系统相关学习/","text":"官方文档 微擎官网 微擎文档 微擎开发文档","tags":[]},{"title":"Android组件生命周期解析","date":"2017-03-28T07:41:14.446Z","path":"2017/03/28/android/Android组件生命周期解析/","text":"Activity在平时的应用开发中,接触最多的就是activity的生命周期。在生命周期回调方法中，您可以声明当用户离开并重新进入活动时，执行相应的代码行为。每一个回调工作，都应该执行特定动作，在正确的时间进行正确的工作并正确处理转换，才能够使应用程序更加健壮，更有效率。 如果没有处理好activity的生命周期，则有可能导致各种异常: 应用程序运行时被电话或者其他程序中断，导致崩溃； 没有正确释放资源时,消耗宝贵的系统资源，甚至OOM。 如果用户离开您的应用程序并在以后返回，则丢失用户的进度。 屏幕在横向和纵向方向之间旋转时，可能会崩溃或丢失用户的进度。 所以有必要深入一些，了解和掌握Activity的生命，下面先放一张activity的生命周期图： activity lifecycle 1.1 Activity状态根据具体的应用的复杂性，可能不需要实现所有的生命周期方法。 创建 onCreate()： 必须实现此回调，当系统首次创建活动时触发。 在该方法中，执行基本的应用程序启动逻辑，该逻辑在整个活动的整个生命周期中应该只发生一次。 例如，将数据绑定到列表，初始化后台线程，并实例化一些类范围变量。 此方法接收参数savedInstanceState，该参数是包含Bundle 活动之前保存的状态的对象。如果活动从未存在，则该Bundle对象的值为null。 开始 onStart()： 当活动进入“开始”状态时，系统将调用此回调。 该方法是应用程序初始化维护UI的代码的位置。 它也可以注册一个BroadcastReceiver 监视UI中响应的更改。 该状态只是过渡状态，非常快速完成，与“创建”状态一样，活动不会保持在“已启动”状态。一旦这个回调结束，活动进入 Resumed状态，系统调用该 onResume()方法。 恢复 onResume()： 这是应用程序与用户进行交互的状态。该应用程序停留在此状态，直到发生某些事情，将焦点从应用程序中移开。 当发生中断事件时，活动进入暂停 状态，系统调用 onPause()回调。 onResume状态说明activity在最上方，用户可以与它进行交互。所以那些仅在用户关注时才使用的组件应该在这个回调中初始化。 暂停 onPause()： 当前activity仍然是可见的。但被另一个activity处在最上方，最上方的activity是半透明的，或者是部分覆盖整个屏幕。被暂停的activity不会再接受用户的输入。 动画和音乐播放Activity在暂停状态下不应该继续。 进入暂停的时机有以下几种： 电话或者短信等系统中断； 在多窗口模式中，切换到其他窗口； 打开一个新的半透明活动（如对话框）; 当处于极度低内存的状态时，系统会杀掉该activity，释放相应资源。 onPause()执行非常简短，并不一定有足够的时间执行保存操作。保存应用程序或用户数据不应该在这步骤实现； 停止 onStop（）： 当前activity完全被隐藏，不被用户可见。可以认为是处于在后台。 由于对用户不再可见，只要有内存的需要，系统就会杀掉该activity来释放资源。 该状态由onStop()进入，或onRestart()或者onCreate()重新唤醒软件，或者被onDestroy()彻底死亡.. 销毁 onDestroy()： 在活动被销毁之前调用。这是活动收到的最后一个回调。 在该回调中，释放上述所有回调中未被销毁的资源； 当acitivty处于暂停或者停止状态，系统可以通过finish()或 android.os.Process.killProcess(android.os.Process.myPid())来杀死其进程。当该activity再次被打开时(结束或杀死后)，需要重新创建，走一遍完整的流程。 1.2 Activities调用流程当Activity A 启动 Activity B时，两个activity都有自个的生命周期。Activity A暂停或者停止，Activity B被创建。记住，在Activity B创建之前，Activity A并不会完全停止，流程如下： Activity A 进入onPause(); Activity B 依次 onCreate(), onStart(), onResume()。（此时Activity B得到了用户焦点） 如果Activity A不再可见，则进入onStop(). 1.3 代码实践利用下面的DemoActivity代码，可亲自感受每一个阶段的状态。比如点返回键，home键，menu键等操作，可以借助通过logcat查看该activity到底处于哪种状态，这里就不说结果了，自己动手，丰衣足食。 import android.app.Activity; import android.os.Bundle; import android.util.Log; public class DemoActivity extends Activity { private static final String TAG = &quot;demo&quot;; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Log.i(TAG,&quot;onCreate::The activity is being created.&quot;); } @Override protected void onStart() { super.onStart(); Log.i(TAG, &quot;onStart::The activity is about to become visible.&quot;); } @Override protected void onResume() { super.onResume(); Log.i(TAG, &quot;onResume::The activity has become visible.&quot;); } @Override protected void onPause() { super.onPause(); Log.i(TAG, &quot;onPause:: Another activity is taking focus.&quot;); } @Override protected void onStop() { super.onStop(); Log.i(TAG, &quot;onStop::The activity is no longer visible&quot;); } @Override protected void onDestroy() { super.onDestroy(); Log.i(TAG, &quot;onDestroy::The activity is about to be destroyed&quot;); } } Service理解activity的生命周期后，Service的生命周期也是大同小异，先看下Service的生命周期图： service lifecycle 2.1 启动方式：service有两种启动方式： startService() 启动本地服务Local Service bindService() 启动远程服务Remote Service 2.2 生命周期两种不同的启动方式决定了Service具有两种生命周期的可能（并非互斥的两种）。 start方式：onCreate()，onStartCommand()。onDestroy释放资源。 bind方式： onCreate()，onBind()方法。需要所有client全部调用unbindService()才能将Service释放资源，等待系统回收。 2.3 代码实践利用下面的DemoService代码，通过logcat自行感受每一个阶段的状态与场景的关系。 import android.app.Service; import android.content.Intent; import android.os.IBinder; import android.util.Log; public class DemoService extends Service { private static final String TAG = &quot;demo&quot;; int mStartMode; // service被杀掉的方式 IBinder mBinder; // clients绑定接口 boolean mAllowRebind; // 是否允许onRebind @Override public void onCreate() { Log.i(TAG,&quot;onCreate::The service is being created&quot;); } @Override public int onStartCommand(Intent intent, int flags, int startId) { Log.i(TAG,&quot;onStartCommand::The service is starting&quot;); return mStartMode; } @Override public IBinder onBind(Intent intent) { Log.i(TAG,&quot;onBind::A client is binding to the service&quot;); return mBinder; } @Override public boolean onUnbind(Intent intent) { Log.i(TAG,&quot;onUnbind::All clients have unbound&quot;); return mAllowRebind; } @Override public void onRebind(Intent intent) { Log.i(TAG,&quot;onRebind::A client rebind to the service &quot; + &quot;after onUnbind() has already been called&quot;); } @Override public void onDestroy() { Log.i(TAG,&quot;onDestroy::The service is no longer used&quot;); } }","tags":[{"name":"android activity","slug":"android-activity","permalink":"https://austinxishou.github.io/tags/android-activity/"}]},{"title":"Hexo 3.0 使用指南","date":"2017-03-28T02:01:27.807Z","path":"2017/03/28/webdesign/Hexo3.0使用指南/","text":"AboutHexo 是一个轻量的静态博客框架。通过Hexo可以快速生成一个静态博客框架,仅需要几条命令就可以完成,相当方便。而架设Hexo的环境更简单了 不需要lnmp/lamp这些繁琐复杂的环境 仅仅需要一个简单的http服务器即可使用 或者使用互联网上免费的页面托管服务 比如Hexo的官方网站就是托管于github的pages服务上 Hexo配置方法进去之后加入hexo主程序和安装npm12hexo initnpm install 目录结构新建完成后，指定文件夹的目录如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 source资源文件夹是存放用户资源的地方。除 posts 文件夹之外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 Hexo全局配置用文本编辑器修改_config.yml这个文件 大致如下 只需要自行修改几个 其他保持默认即可 通常需要修改站点名称 /URL格式 /归档设置 /disqus评论用户名 /部署配置 这几项就可以了 注意冒号后面都要添加一个半角空格 之后才是设置参数 自定义域名设置 在 source 我文件夹下面新建 CNAME 文件 里面写入你的自定义域名 并设置您的dns配置cname方式到服务提供商的给的地址即可 目录source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public tag_dir 标签文件夹 tags archive_dir 归档文件夹 archives category_dir 分类文件夹 categories code_dir Include code 文件夹 downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染，您可使用 glob 来配置路径。 文章本地启动server1$ hexo server 可以观察命令行的输出，然后通过浏览器打开http://localhost:4000/，成功的情况下则会看到默认的欢迎页面。 部署到github pagesHexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。1$ hexo deploy 在开始之前，您必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数，例如： 12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] 1234参数 描述repo 库（Repository）地址branch 分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。message 自定义提交信息 (默认为 Site updated: &#123;&#123; now(&apos;YYYY-MM-DD HH:mm:ss&apos;) &#125;&#125;) 我的博客对应的参数设置为123456deploy: type: git repo: https://github.com/austinxishou/austinxishou.github.io.git branch: master name: austinxishou email: austinxishou@yahoo.com 安装 hexo-deployer-git 1$ npm install hexo-deployer-git --save 之后依次执行:123$ hexo clean$ hexo generate$ hexo deploy 上述命令只要Github的权限校验通过,基本都能成功; hexo主题收集主题 Next Nidigo 写文章使用草稿在 source/_drafts 文件夹中 创建的文章为草稿，默认情况下不生成；可以显示草稿1$ hexo --draft ###","tags":[]}]